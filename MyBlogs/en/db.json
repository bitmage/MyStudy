{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/polarbear/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/polarbear/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/js/src/theme.js","path":"js/src/theme.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/jquery/jquery-3.1.1.min.js","path":"lib/jquery/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/polarbear/.eslintrc","hash":"38131da004ee91a91f25644508b377b261f59687","modified":1490852820000},{"_id":"themes/polarbear/LICENSE","hash":"6fd796a4c624297885ceed920ac7130a96f29a85","modified":1490852820000},{"_id":"themes/polarbear/README.md","hash":"f63d09789eb79bf4ab255b050051ea9ee14d4f33","modified":1490852820000},{"_id":"themes/polarbear/_config.yml","hash":"8f43f4999db094f88b2ea9d11b05c339646d6fc7","modified":1490852820000},{"_id":"themes/polarbear/package.json","hash":"6291ee37b082aabb68b14c0ede7971306c613b86","modified":1490852820000},{"_id":"source/_posts/132Pattern.md","hash":"e463c3d6369981f77cbf15ada12e12163ea33a66","modified":1484276978000},{"_id":"source/_posts/01Matrix.md","hash":"9e19c64ecc6fa5c486f763498171dfe7be0e4cf1","modified":1490095646000},{"_id":"source/_posts/4SumII.md","hash":"d47f88b41688ccd7b8e7eecbcb9ebd2d4d92d4b9","modified":1487813067000},{"_id":"source/_posts/403Forbidden.md","hash":"e0536cc456f725414ebeb8c92c2bcef8346c53a5","modified":1487141082000},{"_id":"source/_posts/Base7.md","hash":"26aa2c95b973dd02bd5b82bf1600aedefdd3b175","modified":1486877694000},{"_id":"source/_posts/BattleshipsinaBoard.md","hash":"7b802fc1894ee7a8064d72053fad5abcb5ec4a8f","modified":1483595187000},{"_id":"source/_posts/BeautifulArrangement.md","hash":"bf935d1a7e43ec7c568c4d466013059c7a203c02","modified":1487928233000},{"_id":"source/_posts/CoinChange.md","hash":"a9ad85d481fa3ddabb192a6fdda89ac9d15be0ca","modified":1484395787000},{"_id":"source/_posts/CanIWin.md","hash":"371c3a91d74cd3697ce10a12615049e20cd7fcb2","modified":1489489717000},{"_id":"source/_posts/BestTimetoBuyandSellStockwithCooldown.md","hash":"e5967c09d77fd26347713818129cbd5dcc78e3ae","modified":1486370100000},{"_id":"source/_posts/BulbSwitcher.md","hash":"6d6fdb29d9b5c20bfd4ac65bdb6baf9fa9ba0db1","modified":1490689181000},{"_id":"source/_posts/CombinationSumIV.md","hash":"7f093afd316469167fbf76379d2ec4d73f648439","modified":1484276990000},{"_id":"source/_posts/ContiguousArray.md","hash":"fe11731afe57a10088e0ee4d20c8e5fecec6b959","modified":1487667202000},{"_id":"source/_posts/ContainsDuplicateIII.md","hash":"dd27b0715783560b8ee9fece42bd54b4ef07e2ba","modified":1490600372000},{"_id":"source/_posts/DecodeString.md","hash":"8079af62e674ead7977527a3a1a3a7acab79121b","modified":1485525942000},{"_id":"source/_posts/ContainerWithMostWater.md","hash":"555b70485a4f1e2e7ed9389f9c14f84029886fc5","modified":1488108641000},{"_id":"source/_posts/DetectCapital.md","hash":"0ee5fc56ad8d066acac2f47d346076e83646db31","modified":1487996102000},{"_id":"source/_posts/DiameterofBinaryTree.md","hash":"f6725e8d9dc633295a85af566f4a0113232b3c96","modified":1490013928000},{"_id":"source/_posts/ContinuousSubarraySum.md","hash":"ace1089592dae2a0e4b06632b776fa87038a47b7","modified":1488950168000},{"_id":"source/_posts/CountNumberswithUniqueDigits.md","hash":"e1b5ac465538e460af1203b74b9bdd1e6c37b188","modified":1490595772000},{"_id":"source/_posts/DiagonalTraverse.md","hash":"1d77bf2c9ac29fbe96249aba99ed479d63414ef7","modified":1487055776000},{"_id":"source/_posts/FindModeinBinarySearchTree.md","hash":"19490351bcef175c4477f128500c5018bfac98f4","modified":1485965708000},{"_id":"source/_posts/EvaluateReversePolishNotation.md","hash":"037d030ace4b3ef1be01eb81806ee0ad4d53f9db","modified":1490543642000},{"_id":"source/_posts/EncodeandDecodeTinyURL.md","hash":"4ad484b31c5832ccbabe831d6b377619e3f91432","modified":1488632442000},{"_id":"source/_posts/FindLargestElementinEachRow.md","hash":"d3ef7450ab2967e95a2ba4d2a015f699c018f627","modified":1487141292000},{"_id":"source/_posts/FindLeftMostElement.md","hash":"e8fe1cdce0c622f5158c725aee0e846433faec1c","modified":1487055833000},{"_id":"source/_posts/GroupAnagrams.md","hash":"25bc7e9150f527f4c8e5603f37c591319fa9a755","modified":1487055866000},{"_id":"source/_posts/Heaters.md","hash":"f6b1d02ddd7647d8cd6512efefe8f0b2c9205f93","modified":1483507667000},{"_id":"source/_posts/HouseRobberIII.md","hash":"739b8c75c9b9101f288a171d7fb699a055852117","modified":1487055909000},{"_id":"source/_posts/FindtheDuplicateNumber.md","hash":"ec46ffcc4d9a0549fdecfbbfdd8013dae8922259","modified":1486529425000},{"_id":"source/_posts/IncreasingSubsequences.md","hash":"01685747e4812efad6593dfc8cc97953b65c56de","modified":1485704340000},{"_id":"source/_posts/FontSize.md","hash":"607bffa975215c9321f02591a04e2ba5dd580449","modified":1487136171000},{"_id":"source/_posts/IntegerBreak.md","hash":"41b3d9047cccacc4243ad97f610dd128b99fefd9","modified":1489210526000},{"_id":"source/_posts/IntegerReplacement.md","hash":"51c8dfaf049ceb5b448009bf05d1238aa76838a3","modified":1485272461000},{"_id":"source/_posts/LicenseKeyFormatting.md","hash":"3fc30a342173883a86126b490ab49adb7da1ac94","modified":1484667180000},{"_id":"source/_posts/LargestDivisibleSubset.md","hash":"549acae7f7b6f7f01cabb4f508ca5369ee9af559","modified":1484395907000},{"_id":"source/_posts/IntersectionofTwoArraysII.md","hash":"99d1ce4e9874ac725ecf2079404fcf40ab4f4faf","modified":1483887680000},{"_id":"source/_posts/K-diffPairsinanArray.md","hash":"1fb1f82f7a75e0582f085501b20422f9b10b9c59","modified":1488723705000},{"_id":"source/_posts/KeyboardRow.md","hash":"2473f84282bc533247b45f36a035a65936d7e67a","modified":1487558686000},{"_id":"source/_posts/LongestIncreasingPathinaMatrix.md","hash":"b0c9d9cc27c46fd7d00e96a11eee85694aa63ab0","modified":1483950266000},{"_id":"source/_posts/LonelyPixelII.md","hash":"dcb651704096ab56c8ce2de8bb3f1cb3e27d1098","modified":1488939758000},{"_id":"source/_posts/LongestIncreasingSubsequence.md","hash":"e7b9dd5f7a1176654ea8faa2a3b9f080d592bcb6","modified":1490173243000},{"_id":"source/_posts/MatchstickstoSquare.md","hash":"c322da8438dba110f82734999ba0a116d48bcf5a","modified":1486194549000},{"_id":"source/_posts/MaxConsecutiveOnesII.md","hash":"a9760cb3278a7fa40ec94e5158da7a781d18bf0b","modified":1484461913000},{"_id":"source/_posts/LongestWordinDictionarythroughDeleting.md","hash":"4de4686ba780ba345358d0942a0efdc51beb0e91","modified":1488333720000},{"_id":"source/_posts/MaximumProductofWordLengths.md","hash":"a473acb044875d93b72311bcf390bbf38011a498","modified":1485526112000},{"_id":"source/_posts/LongestPalindromicSubsequence.md","hash":"be9127754649afb62bbe7c1d5b5b4db3ba1a6d65","modified":1487744442000},{"_id":"source/_posts/MaxConsecutiveOnes.md","hash":"dd77253a7fb1dd271bb80ca323453ab6e786cddd","modified":1487495351000},{"_id":"source/_posts/LongestSubstringwithAtLeastKRepeatingCharacters.md","hash":"a29cd1308cd8b9a6f0879a7ce1f6af30284f83a0","modified":1490766643000},{"_id":"source/_posts/MaximumXORofTwoNumbersinanArray.md","hash":"b8a5d90ec0500bbea682358908715db315033c5a","modified":1486653085000},{"_id":"source/_posts/MinimumMovestoEqualArrayElementsII.md","hash":"a5414a770a4279f3ad2b188118ab734a6d8c5259","modified":1485442375000},{"_id":"source/_posts/MergeIntervals.md","hash":"031ee6fc460eb032bd2003e83fcc64121e92d168","modified":1490848917000},{"_id":"source/_posts/MinimumAbsoluteDifferenceinBST.md","hash":"3932c1f1f64f1dfd41c3652fc209817feaf6754e","modified":1488510122000},{"_id":"source/_posts/Minesweeper.md","hash":"8984bff8982f8aa591f3d4e8cb06a86b0ec20e4d","modified":1488248645000},{"_id":"source/_posts/MinimumTimeDifference.md","hash":"03750cdd05ab954cc0a56f8701c75afcdfb4b37c","modified":1489478849000},{"_id":"source/_posts/NewStart.md","hash":"8e373a9c4e54ad72603e05d0edd11cdfeb3a0673","modified":1483426041000},{"_id":"source/_posts/MostFrequentSubtreeSum.md","hash":"5833605ace7a00020f50a8bdbf159cf897958a86","modified":1487056007000},{"_id":"source/_posts/NumberComplement.md","hash":"7b6a24daf1a7d7c5478d9ddee083f4bb2e620062","modified":1485273094000},{"_id":"source/_posts/NextGreaterElementI.md","hash":"0d4fe0c3278b3544288b7d7b08db4ebcdd8c06e1","modified":1486276056000},{"_id":"source/_posts/OnesandZeroes.md","hash":"1db9b0fd255ea9a02593ee7b19f15a349cb23968","modified":1484929423000},{"_id":"source/_posts/PartitionEqualSubsetSum.md","hash":"2827ec318420479702406f9becd5a4df120550ed","modified":1484277030000},{"_id":"source/_posts/PathSumIII.md","hash":"c3d67bb6e610f0e952e7b504fc236aafe6f88a38","modified":1487056069000},{"_id":"source/_posts/NextGreaterElementII.md","hash":"57cc6334c4b929b0e8c6f21ac6f8a17ba8ffcc53","modified":1488178506000},{"_id":"source/_posts/PerfectSquares.md","hash":"f780574e45803d0562454812f066e6d2cd2d6029","modified":1484554268000},{"_id":"source/_posts/PredicttheWinner.md","hash":"aa1979cfe6126cf87fca5b2e497519f1bd325d48","modified":1486194619000},{"_id":"source/_posts/Permutations.md","hash":"2b0e871582d031934ce8b5d2017b1bc04125388a","modified":1487056097000},{"_id":"source/_posts/RansomNote.md","hash":"c7d244c776cd29768df6800b24e7666342208fdd","modified":1484236683000},{"_id":"source/_posts/PowerofFour.md","hash":"4d755bc580344ab54c88761f89fc659d95186dad","modified":1490276513000},{"_id":"source/_posts/RelativeRanks.md","hash":"4a9609dbf63265f9a6601562381880857ed2b819","modified":1486277334000},{"_id":"source/_posts/TargetSum.md","hash":"064b84c71bbfb4c2f5599fdd42b1c7a4101740bc","modified":1485618060000},{"_id":"source/_posts/TeemoAttacking.md","hash":"d4586c75ec7794fd8ae62c49a24cb4c5e6d5e107","modified":1486039618000},{"_id":"source/_posts/TotalHammingDistance.md","hash":"3543dc2fb9cd9417061fd0377a0725999b835a6b","modified":1484277003000},{"_id":"source/_posts/SurroundedRegions.md","hash":"e1f75c8862ba7f07474f9b39a5f71e0234f49ebe","modified":1489300552000},{"_id":"source/_posts/UniqueSubstringsinWraparoundString.md","hash":"c027d2558f269dc70155641f9c05e5f0d4158873","modified":1485788870000},{"_id":"source/_posts/SingleElementinaSortedArray.md","hash":"2021c817cb0a8a185965ff3fa887b2ec1d2587a5","modified":1489046175000},{"_id":"themes/polarbear/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1490852820000},{"_id":"themes/polarbear/.git/config","hash":"497c37732e950146f4540cf1e5d70e1d203bb69b","modified":1490852820000},{"_id":"themes/polarbear/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1490852815000},{"_id":"themes/polarbear/.git/index","hash":"a62311fa9c09429422837297ffa321a4a58320e2","modified":1490852820000},{"_id":"source/tags/index.md","hash":"c7903929418ffa391eb94fa1ee0cb8238a53132d","modified":1484113382000},{"_id":"source/_posts/ValidPerfectSquare.md","hash":"894e31eaa400441be33bdb1ebcaae08fadf202cb","modified":1485354344000},{"_id":"source/_posts/ReverseStringII.md","hash":"9eee2e8762edeabdf8a7680d56b77a110f98715e","modified":1489650929000},{"_id":"themes/polarbear/.git/packed-refs","hash":"7b5f932aa9b5a504b9cdeebf49b5f557b83de5e7","modified":1490852820000},{"_id":"themes/polarbear/languages/default.yml","hash":"5687525dd72a436ce0970f0b844dc7251069400a","modified":1490852820000},{"_id":"themes/polarbear/languages/en.yml","hash":"5687525dd72a436ce0970f0b844dc7251069400a","modified":1490852820000},{"_id":"themes/polarbear/languages/zh-cn.yml","hash":"be347d8f215c1d36a7a906143b1411e5aaf5d500","modified":1490852820000},{"_id":"themes/polarbear/layout/_layout.swig","hash":"60ad6ead7c72b9d94a4adf073884edc23f0751ea","modified":1490852820000},{"_id":"themes/polarbear/layout/archive.swig","hash":"600c71de731ac0ac8c281c3c9df1d7e9b62d2a9d","modified":1490852820000},{"_id":"themes/polarbear/layout/categories.swig","hash":"dc244e0ee1fc34f43d5b195b9c1f6ef6d3ad2d0d","modified":1490852820000},{"_id":"themes/polarbear/layout/index.swig","hash":"5c1dce2ea06d8de6f05f92f95cb1449cefc846bc","modified":1490852820000},{"_id":"themes/polarbear/layout/page.swig","hash":"a168c6e1dcf21af6408a713f8512b77de0dc60f3","modified":1490852820000},{"_id":"themes/polarbear/layout/post.swig","hash":"f7a8b96953374694c50d131b1b760fd84b2d2d51","modified":1490852820000},{"_id":"themes/polarbear/source/favicon.ico","hash":"7d7c441f635c35b73f060f698773b14b7f306f4c","modified":1490852820000},{"_id":"themes/polarbear/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1490852815000},{"_id":"themes/polarbear/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1490852815000},{"_id":"themes/polarbear/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1490852815000},{"_id":"themes/polarbear/.git/logs/HEAD","hash":"07d647eb33813f2bb09e102c04fc0273c9fae871","modified":1490852820000},{"_id":"themes/polarbear/layout/_macro/archive.swig","hash":"1b9a0263c877ce801c0dc0ba256c799d54638825","modified":1490852820000},{"_id":"themes/polarbear/layout/_macro/post.swig","hash":"26367661ff9535359d420943d5b29bd5b8c5911f","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/comments.swig","hash":"9ba815734a4d807859f0aeafd5536b2d35d26074","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/footer.swig","hash":"4b88f30ad6218c87d27bc5c5b37bbbd97732cf59","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/head.swig","hash":"44c45d90d9a3db3401f6aa219cd26f38cdd0960b","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/header.swig","hash":"2e7d1faf49dadbf87b5925ff8da643cb470d6199","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/pagination.swig","hash":"3843e523b9a7a1c5973d0c2de05cc88467733e09","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/widget.swig","hash":"d8181794388ef3baa26c2d5cf8d71ae05472b32e","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/analytics.swig","hash":"24ba4a8adcaf09c9ede76405ee732385595d8e39","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/comments.swig","hash":"256713e117d67e2caad21db52bc0d51460e4ff7e","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/config.swig","hash":"4532063827e51b5c0dc3f58ca8c37896959887ac","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/libs.swig","hash":"615f82ddd2f89e87a604b51773fd719c78f90580","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/theme.swig","hash":"44582de16d91f5cde5fa28a21db408385a46ff8e","modified":1490852820000},{"_id":"themes/polarbear/source/css/_base.scss","hash":"27c36dfe4b2d159c64e666bfe8561fbdc591e6a5","modified":1490852820000},{"_id":"themes/polarbear/source/css/_layout.scss","hash":"adfe6b08a183326e2115974860d1862288d4789c","modified":1490852820000},{"_id":"themes/polarbear/source/css/_variables.scss","hash":"d3f72d21bdd3cae17118323ae7f20f04d484a0f5","modified":1490852820000},{"_id":"themes/polarbear/source/css/style.scss","hash":"2f1d29a63c3c8f8c615049b0233db528b6ab3230","modified":1490852820000},{"_id":"themes/polarbear/.git/objects/pack/pack-0c6ac493ff22961635844ab9acb16de2b224573d.idx","hash":"9d912d46a2e7283875b95ec16418404f585001ad","modified":1490852820000},{"_id":"themes/polarbear/.git/refs/heads/master","hash":"dc1e7e1f4630adf2ed6f5e9d788d0648dc475230","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/_head/meta.swig","hash":"5eef6defbaf10f3f6d3b341d2d1af2e4d7aeb5a9","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/_widget/categories.swig","hash":"8bb8094fd3d96c0dd7e58fd658384a5df3a7e2ec","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/_widget/custom.swig","hash":"a82b64295f240d40cd86f400faf875d90d150b20","modified":1490852820000},{"_id":"themes/polarbear/layout/_partial/_widget/tags.swig","hash":"a14e2bda31b15cac11c29d0abb623543a6c87edc","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/_analytics/baidu-analytics.swig","hash":"5d62309b16071f1b6952891ec8e1f1d42e38a088","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/_analytics/google-analytics.swig","hash":"f44684799386fbd4af6e5994b0c14c85eeff060c","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/_comments/disqus.swig","hash":"f0e8b2ff1556622c0dee10a82e77646695b0f8dd","modified":1490852820000},{"_id":"themes/polarbear/layout/_script/_comments/duoshou.swig","hash":"582cf94bc12b56c6a16b5f3aa0067b51f74b0d40","modified":1490852820000},{"_id":"themes/polarbear/source/css/_common/_animation.scss","hash":"725af3ea621de186d6d61749836d5b491a96c1e4","modified":1490852820000},{"_id":"themes/polarbear/source/css/_common/_normalize.scss","hash":"259a1a0584f43efa6de2573a45fedfd59d4f39c0","modified":1490852820000},{"_id":"themes/polarbear/source/css/_common/_utils.scss","hash":"7719505ff3185a9f8fad05fe092fa91dd63d900c","modified":1490852820000},{"_id":"themes/polarbear/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_archive.scss","hash":"d4fa3756a4cab145f76fccc3c69d81b3412cec36","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_back-to-top.scss","hash":"c6f586ac04a9a0f3633dadf5c66be9e0c4027f1d","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_categories.scss","hash":"eb9fa27704fa280c6e8cc7b7f44b283cd2fe4ad3","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_footer.scss","hash":"5d708caa8a96f84642404fe8a0d7a755092710db","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_header.scss","hash":"b4e97e6704ab530ec3b789866d689b736e36de9e","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_iconfont.scss","hash":"ae9d1019bdbe6de4fe97aabbd42f489039e978a0","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_pagination.scss","hash":"7362208b41453429adae449acc916f8633077248","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_post.scss","hash":"71bfa582c26c491c8791dadbc3cb135284a123a2","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_tags.scss","hash":"1928c8483f51035edccd6899d7f4ee06673f2804","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_widget.scss","hash":"2fcea4e8e43b79c73bf4bd6dbf0c1a2368d4c6ef","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.css","hash":"79df8b1839cbcb82a0fd9738289eb43c1bc77026","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/jquery.fancybox.js","hash":"39357ff994e53ea15c582b6106094396835a8be0","modified":1490852820000},{"_id":"themes/polarbear/source/js/src/bootstrap.js","hash":"edb8690492039f4a4c9b83a3b9abda6d8a214984","modified":1490852820000},{"_id":"themes/polarbear/source/js/src/theme.js","hash":"5e2e4a290e595a5ebdd8b6866a08700ca20f1c2c","modified":1490852820000},{"_id":"themes/polarbear/.git/objects/pack/pack-0c6ac493ff22961635844ab9acb16de2b224573d.pack","hash":"9c0787d5f9d0bea138cb388b1e49adf1ab0f627c","modified":1490852820000},{"_id":"themes/polarbear/source/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1490852820000},{"_id":"themes/polarbear/.git/logs/refs/heads/master","hash":"07d647eb33813f2bb09e102c04fc0273c9fae871","modified":1490852820000},{"_id":"themes/polarbear/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_post/_code.scss","hash":"446dbbc70ba45e41079e2954549c248f5affc7c0","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_post/_content.scss","hash":"899c7c25bfa4fe00d85734af0d71bc4caf2a7337","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_post/_footer.scss","hash":"d4c0fc62e69412304691d58984fec0aa963e1117","modified":1490852820000},{"_id":"themes/polarbear/source/css/_partial/_post/_header.scss","hash":"ceca6f4b00154542c57bc6fe451e01892a9338d2","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1490852820000},{"_id":"themes/polarbear/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1490852820000},{"_id":"themes/polarbear/.git/logs/refs/remotes/origin/HEAD","hash":"07d647eb33813f2bb09e102c04fc0273c9fae871","modified":1490852820000},{"_id":"public/atom.xml","hash":"026b6a898a01fa110efdbd46b20e2e2ea895c8f4","modified":1490852863524},{"_id":"public/sitemap.xml","hash":"c152b4d6ead419b534a4b7a53249faa565a91713","modified":1490852863552},{"_id":"public/tags/index.html","hash":"1678fd2b5f3890b746190d97e8c0bb96db6b648f","modified":1490852863562},{"_id":"public/2017/03/29/LongestSubstringwithAtLeastKRepeatingCharacters/index.html","hash":"a723f91515b9ba1ae253a426cf6bd0ca849ded60","modified":1490852863562},{"_id":"public/2017/03/30/MergeIntervals/index.html","hash":"13922b7d7e42c565d91e28de5b17612cb0ffcc2f","modified":1490852863562},{"_id":"public/2017/03/28/BulbSwitcher/index.html","hash":"da95f2b94ed75267b48d68fff4988ec4bb43def3","modified":1490852863563},{"_id":"public/2017/03/27/ContainsDuplicateIII/index.html","hash":"80a9e1fa392c6ed8ae3dfa99d0e22730f3c8d9d5","modified":1490852863563},{"_id":"public/2017/03/26/EvaluateReversePolishNotation/index.html","hash":"deefed771aef16b761304e9842650aec0ad7ed30","modified":1490852863563},{"_id":"public/2017/03/24/CountNumberswithUniqueDigits/index.html","hash":"1314eaa995bbf89f63a4248465ec603d92f10698","modified":1490852863563},{"_id":"public/2017/03/23/PowerofFour/index.html","hash":"51101fb3a03d8ea1939907eabd92d357b3b78848","modified":1490852863563},{"_id":"public/2017/03/22/LongestIncreasingSubsequence/index.html","hash":"9392081a1e157d9261050d36f39affd83f10155e","modified":1490852863563},{"_id":"public/2017/03/20/DiameterofBinaryTree/index.html","hash":"5d1f24bc762fa7b5fa480c6c574ce15f48ce6e3f","modified":1490852863563},{"_id":"public/2017/03/16/ReverseStringII/index.html","hash":"ac9ea4c970c165297c9b9a9d609ff39b11c1c4d7","modified":1490852863563},{"_id":"public/2017/03/14/MinimumTimeDifference/index.html","hash":"aa9bbbdd9970ce616974c1bc955cc3c98502213b","modified":1490852863563},{"_id":"public/2017/03/13/CanIWin/index.html","hash":"68a61fa2f539be74b6299ed874c75c61e3c6c39c","modified":1490852863563},{"_id":"public/2017/03/12/SurroundedRegions/index.html","hash":"17c1f1cddb6727dc2e6967077d87e3dbed2ee495","modified":1490852863563},{"_id":"public/2017/03/09/SingleElementinaSortedArray/index.html","hash":"cec145d9a93b80d08c135a551a940f09ebf004df","modified":1490852863563},{"_id":"public/2017/03/11/IntegerBreak/index.html","hash":"b31ea9453de82328750d9e5e515583e769554e4c","modified":1490852863563},{"_id":"public/2017/03/08/ContinuousSubarraySum/index.html","hash":"dc05d6085e1fa9a7686a4c208b34bf375b7773f9","modified":1490852863563},{"_id":"public/2017/03/06/LonelyPixelII/index.html","hash":"840971c221db2019648e33f948fc7b4842b9b842","modified":1490852863563},{"_id":"public/2017/03/05/K-diffPairsinanArray/index.html","hash":"4f125cd04cbd476ea9ea7a3b88bcbfa09bca7723","modified":1490852863563},{"_id":"public/2017/03/04/EncodeandDecodeTinyURL/index.html","hash":"52fd910b1c534bbe41087c0d1f4498e5eb9de558","modified":1490852863563},{"_id":"public/2017/03/03/MinimumAbsoluteDifferenceinBST/index.html","hash":"0612332761480f115097f96ad4f0a8325e4a7bdb","modified":1490852863563},{"_id":"public/2017/02/28/Minesweeper/index.html","hash":"4d078b43a8dbb927414e4782693af23d9ec759e0","modified":1490852863563},{"_id":"public/2017/02/27/NextGreaterElementII/index.html","hash":"0a6aef38f6c8f77fcd61546bbb4089a289e7f515","modified":1490852863563},{"_id":"public/2017/02/26/ContainerWithMostWater/index.html","hash":"ff89e1372869cf2fb8733a0f53dc312227baead8","modified":1490852863563},{"_id":"public/2017/02/25/DetectCapital/index.html","hash":"aca57b44806d0564b0678b2a61098ec45bc1e2f5","modified":1490852863563},{"_id":"public/2017/02/24/BeautifulArrangement/index.html","hash":"49d5f13342507971382e1436c481d77787c7ed0f","modified":1490852863563},{"_id":"public/2017/02/23/4SumII/index.html","hash":"44059ea93f31e64c37aa3c09dd3e179692b91c49","modified":1490852863564},{"_id":"public/2017/02/22/LongestPalindromicSubsequence/index.html","hash":"15fcf51b7d15d744ed575bfab501a70a29b25ccd","modified":1490852863564},{"_id":"public/2017/02/21/ContiguousArray/index.html","hash":"5dc878f8c77d5e8a0ecc1e47eea3d34dfa1a3ef2","modified":1490852863564},{"_id":"public/2017/02/20/KeyboardRow/index.html","hash":"d60953a365a098bbef369b102c6ce8dd9141858e","modified":1490852863564},{"_id":"public/2017/02/19/MaxConsecutiveOnes/index.html","hash":"11c57adce453dd5a4bb5b651fd1a205485989f68","modified":1490852863564},{"_id":"public/2017/02/14/FontSize/index.html","hash":"08b68d3d16c2e99f10fa178665c24ba26a0d28d9","modified":1490852863564},{"_id":"public/2017/02/13/Permutations/index.html","hash":"c67abcaed5f637de2e55fb0d7b111d256278f250","modified":1490852863564},{"_id":"public/2017/02/12/FindLargestElementinEachRow/index.html","hash":"31fd124d927057fb350cff2cdca4a357057337a6","modified":1490852863564},{"_id":"public/2017/02/12/FindLeftMostElement/index.html","hash":"6b354aabeb99a1424a760600bf4b6e340dc539ec","modified":1490852863564},{"_id":"public/2017/02/11/Base7/index.html","hash":"4478e17aaba233fa393c8ce7c6c119ecf9dd7970","modified":1490852863564},{"_id":"public/2017/02/10/DiagonalTraverse/index.html","hash":"de6e8751b6a329a4ba9624eaba15b9220a090fe5","modified":1490852863564},{"_id":"public/2017/02/09/MaximumXORofTwoNumbersinanArray/index.html","hash":"2be0fb82c9ed8e058136253eba63e4f6d41fc6eb","modified":1490852863564},{"_id":"public/2017/02/08/FindtheDuplicateNumber/index.html","hash":"d4c14278eab75a10e3bf803385b3fa3b44fbea52","modified":1490852863564},{"_id":"public/2017/02/06/BestTimetoBuyandSellStockwithCooldown/index.html","hash":"77162e5ab6b58659e6297c84c3231e3c84952dc7","modified":1490852863564},{"_id":"public/2017/02/07/MostFrequentSubtreeSum/index.html","hash":"fb0a0b36145758cc3fe5c6139fd0a29408996493","modified":1490852863564},{"_id":"public/2017/02/05/NextGreaterElementI/index.html","hash":"72d3a4824b1af1f9e611b888d4c41a7e0c420159","modified":1490852863564},{"_id":"public/2017/02/05/RelativeRanks/index.html","hash":"b7da8cf723eb469a69394f580c9c0243ffef8ad5","modified":1490852863564},{"_id":"public/2017/02/03/PredicttheWinner/index.html","hash":"a0ccfbc7e56f16118d2552bca3786c6d0eba1e34","modified":1490852863564},{"_id":"public/2017/02/04/MatchstickstoSquare/index.html","hash":"3b15a5843a07b06dbdc3224a1ad7aab5e694662d","modified":1490852863564},{"_id":"public/2017/02/02/TeemoAttacking/index.html","hash":"2323c66c0442253a18cbad54945fb24c54a6181a","modified":1490852863564},{"_id":"public/2017/02/01/FindModeinBinarySearchTree/index.html","hash":"a8a806f0eeff6b64ca6ebec74d667e77ce0000b6","modified":1490852863565},{"_id":"public/2017/01/30/UniqueSubstringsinWraparoundString/index.html","hash":"5dcb9bb89f97b231c81dedb9168990e30ece608d","modified":1490852863565},{"_id":"public/2017/01/29/IncreasingSubsequences/index.html","hash":"8afa4a80925e721ffd897bc7ee332808027464d0","modified":1490852863565},{"_id":"public/2017/01/28/TargetSum/index.html","hash":"17120c40a058e55339f128274b165b75cbde3000","modified":1490852863565},{"_id":"public/2017/01/27/DecodeString/index.html","hash":"7a44b7a143db5bfd179f565812cc2082bbebf645","modified":1490852863565},{"_id":"public/2017/01/25/ValidPerfectSquare/index.html","hash":"1a586d3f3df65e7f036314d9f91c58a1d40fecc5","modified":1490852863565},{"_id":"public/2017/01/26/MinimumMovestoEqualArrayElementsII/index.html","hash":"9603839486b7007c046744fdfcd192789051b52c","modified":1490852863565},{"_id":"public/2017/01/24/NumberComplement/index.html","hash":"e7c7536be913730f828dd9f1216de0aab43dba47","modified":1490852863565},{"_id":"public/2017/01/22/IntegerReplacement/index.html","hash":"86e60a572bf8adabf95b1c132c1b09a31447343d","modified":1490852863565},{"_id":"public/2017/01/21/HouseRobberIII/index.html","hash":"437f9c002f4a8515c2e8efed94d701ff31d98c2c","modified":1490852863565},{"_id":"public/2017/01/20/OnesandZeroes/index.html","hash":"80c5e06ab34ce3f94a72e2960fd8b3fac8599df6","modified":1490852863565},{"_id":"public/2017/01/18/MaximumProductofWordLengths/index.html","hash":"ac04aaa4ae2400f27ecd6ed10e156e78e5ddd476","modified":1490852863565},{"_id":"public/2017/01/17/LicenseKeyFormatting/index.html","hash":"768c7b17fc40a26846fd255595611d0a5e7813f0","modified":1490852863565},{"_id":"public/2017/01/16/PerfectSquares/index.html","hash":"20dfed15368e4f21d15628aced9b835da7b4b71d","modified":1490852863565},{"_id":"public/2017/01/15/MaxConsecutiveOnesII/index.html","hash":"40d9d0cecacf7bc74c742475cbe2f667e90ba307","modified":1490852863565},{"_id":"public/2017/01/14/CoinChange/index.html","hash":"e26d0a13bd16a115c3931de962de3a2cd442f537","modified":1490852863565},{"_id":"public/2017/01/13/LargestDivisibleSubset/index.html","hash":"4f45ab4cddb12995c7e3e66c98cce2655177a6d9","modified":1490852863565},{"_id":"public/2017/01/12/RansomNote/index.html","hash":"9ad9cec00afc788353a6c98d269287f11ef99d35","modified":1490852863565},{"_id":"public/2017/01/11/CombinationSumIV/index.html","hash":"8753a53bdd4deb1a37438e32d53f7e3869a1ca20","modified":1490852863565},{"_id":"public/2017/01/10/GroupAnagrams/index.html","hash":"8288442f101ed8f171ace825728fc18502bd0878","modified":1490852863565},{"_id":"public/2017/01/09/LongestIncreasingPathinaMatrix/index.html","hash":"fe844cf09f5bbf59be6e1da9c32f1f20e162662b","modified":1490852863566},{"_id":"public/2017/01/08/IntersectionofTwoArraysII/index.html","hash":"b6e8e210504c946a7a951f4e29eebd8a8f358a7b","modified":1490852863566},{"_id":"public/2017/01/07/PathSumIII/index.html","hash":"69557495b0bb1f51872d52e2c7f84c7dcd911d20","modified":1490852863566},{"_id":"public/2017/01/06/PartitionEqualSubsetSum/index.html","hash":"d01b149b4b46af9ad5d405769e60a135eda03703","modified":1490852863566},{"_id":"public/2017/01/04/Heaters/index.html","hash":"08354816747d798dfc72611fdf27f4aa2c75e53a","modified":1490852863566},{"_id":"public/2017/01/03/132Pattern/index.html","hash":"b4512f06252e5e8b4102a156cb17b866b54c9def","modified":1490852863566},{"_id":"public/2017/01/02/TotalHammingDistance/index.html","hash":"52546a6cfb588ffda2b5e0b4db29531ef91b88c2","modified":1490852863566},{"_id":"public/2017/01/01/NewStart/index.html","hash":"29530665bd0b78ab0a2d4f6c18d3e454bd969a52","modified":1490852863566},{"_id":"public/archives/2017/01/index.html","hash":"3e509c93fd6582c34a51bbf1ffc514e8038bb61a","modified":1490852863566},{"_id":"public/archives/2017/02/index.html","hash":"6201f043793edff20160b91d21ed70b5795d4c62","modified":1490852863566},{"_id":"public/archives/2017/03/index.html","hash":"12e1961cd940b69f160bf703d2dc054083119d91","modified":1490852863566},{"_id":"public/index.html","hash":"04ea257d9fc27d9b0311a4857620083c6598abac","modified":1490852863566},{"_id":"public/page/2/index.html","hash":"5020ddc3dabf6a94e6ada2be6d92e5b2e9816dda","modified":1490852863566},{"_id":"public/page/3/index.html","hash":"fbc60139fb7399925be4d42a002153d97097df37","modified":1490852863566},{"_id":"public/page/4/index.html","hash":"fd85e01285ef251e14484afec7a7135f6a9f2ceb","modified":1490852863566},{"_id":"public/page/5/index.html","hash":"1247eb2d843e28d04a304541d2e49b91ea28a992","modified":1490852863566},{"_id":"public/page/6/index.html","hash":"5d117e27182386d80dc27b33fe88699584d1f7ad","modified":1490852863566},{"_id":"public/page/7/index.html","hash":"00de7d60dfd4f97b5af3361f4cc623d03dafa379","modified":1490852863566},{"_id":"public/page/8/index.html","hash":"9fec1460e08a546d959ad6f3780a91170749057d","modified":1490852863566},{"_id":"public/page/9/index.html","hash":"0493bb9b27dce92449043fa9d6d05ba687bb616c","modified":1490852863566},{"_id":"public/page/10/index.html","hash":"a9ba70e6c66372ada05a965568d9b5238988d8d7","modified":1490852863566},{"_id":"public/page/11/index.html","hash":"7fdd7b8cf05b49bfc47ca4d0477e97f42908c41a","modified":1490852863567},{"_id":"public/page/12/index.html","hash":"178784be5dfcef4d3d8629b68fe99112e5db2f56","modified":1490852863567},{"_id":"public/page/13/index.html","hash":"757bf2a73809042b8d072d98cb2b4a0d07b3cf7f","modified":1490852863567},{"_id":"public/page/14/index.html","hash":"489d6a4b424a3481759d790007bd0a10b0b0fbde","modified":1490852863567},{"_id":"public/page/15/index.html","hash":"fec8b4446aeb050e600eaae4cbdc47e5a5a4b35c","modified":1490852863567},{"_id":"public/page/16/index.html","hash":"634596bbcf0b5c620b8aecd44bfa93f52f6fb4c5","modified":1490852863567},{"_id":"public/tags/Stack/index.html","hash":"356e44b93e1592c90c8dac25e3cd194b372dbd03","modified":1490852863567},{"_id":"public/tags/Binary-Search/index.html","hash":"2825eba21563d101d31ba974a83baa8fc2e784e7","modified":1490852863567},{"_id":"public/tags/Hash-Table/index.html","hash":"f1a3db539eac6cbb35e232f12abad5636f16738b","modified":1490852863567},{"_id":"public/tags/Depth-first-Search/index.html","hash":"abdfd5f4e15dd4fd97aff0138e2d661073076b41","modified":1490852863567},{"_id":"public/tags/Breadth-first-Search/index.html","hash":"266e1a00ca4faf925d1be2222203f2b6f00205f1","modified":1490852863567},{"_id":"public/tags/Array/index.html","hash":"5b26b155233f72ba26a12b14038070fe25b4f4ef","modified":1490852863567},{"_id":"public/tags/Trie/index.html","hash":"09f2d934633b604be3a0c69e66fa0a84b3a00ad4","modified":1490852863567},{"_id":"public/tags/Math/index.html","hash":"4775e7cd4ed90e12e8f5ea315ee0bc0bac84cc1b","modified":1490852863567},{"_id":"public/tags/Simulation/index.html","hash":"1a833df5d4d95761064af6e19af199573aeb2148","modified":1490852863567},{"_id":"public/tags/Backtracking/index.html","hash":"ceb9e17b83c11e158e6ec970a1762526d2ded29e","modified":1490852863567},{"_id":"public/tags/Dynamic-Programming/index.html","hash":"508d07b1307e6c14c8d05ffa7209a66b90530ae4","modified":1490852863567},{"_id":"public/tags/Minimax/index.html","hash":"bb9870fa55c959fc675d682c0ef3e5c64f116a6e","modified":1490852863567},{"_id":"public/tags/Brainteaser/index.html","hash":"ceda90f3938f675e5ce9c902eea70c8c58e53c5c","modified":1490852863567},{"_id":"public/tags/Binary-Search-Tree/index.html","hash":"3fb179a6162f8ec985bbdaae3d207782720b903f","modified":1490852863567},{"_id":"public/tags/Two-Pointers/index.html","hash":"f52ca80dcd74ea60b686a89c588c0a5fc65dedb1","modified":1490852863567},{"_id":"public/tags/String/index.html","hash":"c11caa502a97f2f62e8db2a044fd99b2940f5b20","modified":1490852863567},{"_id":"public/tags/Tree/index.html","hash":"ea96ffff9b8adb4760a17be6d13bcc9a2640948b","modified":1490852863567},{"_id":"public/tags/Bitmap/index.html","hash":"1f04185426951ca5e9c0084f736fb8925e128b3d","modified":1490852863567},{"_id":"public/tags/Sort/index.html","hash":"33d5946d6e954eaa68a35f1d7629fd1358ed6429","modified":1490852863568},{"_id":"public/tags/Memoization/index.html","hash":"4745ccc4810f474c1df38f0bcc83de5ff8ee7952","modified":1490852863568},{"_id":"public/tags/Topological-sort/index.html","hash":"112c75d4f7cc9cd17cab6910c62c14f88e50aa9e","modified":1490852863568},{"_id":"public/tags/Bit-Manipulation/index.html","hash":"a3551b0585f204178da23b7fd92bc83321921cbd","modified":1490852863568},{"_id":"public/tags/Description/index.html","hash":"6630a824a0221b96a320908a1e0d7ed9c6497421","modified":1490852863568},{"_id":"public/tags/Union-Find/index.html","hash":"701310154abf228b3c03aef738df0ac72dbc6f59","modified":1490852863568},{"_id":"public/2017/03/21/01Matrix/index.html","hash":"865478e9d7e5905619368e3efb743603d8a5e5c4","modified":1490852863568},{"_id":"public/2017/03/01/LongestWordinDictionarythroughDeleting/index.html","hash":"4bfd073db6dac7bcb2187ee27b2b64aae66be288","modified":1490852863568},{"_id":"public/2017/02/15/403Forbidden/index.html","hash":"3d3ae6c8f634740914f55cc58f8d876a38369f2e","modified":1490852863568},{"_id":"public/2017/01/05/BattleshipsinaBoard/index.html","hash":"d3ac062b448cadfb5d70c89dd34a2d7ed4bf7cf7","modified":1490852863568},{"_id":"public/archives/index.html","hash":"1b3e822674381c45ab8f61df8a9cebeb42680115","modified":1490852863568},{"_id":"public/archives/2017/index.html","hash":"8ae3afec2eeb63690c71cfc4867105f259048939","modified":1490852863568},{"_id":"public/favicon.ico","hash":"7d7c441f635c35b73f060f698773b14b7f306f4c","modified":1490852863572},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1490852863572},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1490852863572},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1490852863572},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1490852863573},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1490852863573},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1490852863573},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1490852863573},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"79df8b1839cbcb82a0fd9738289eb43c1bc77026","modified":1490852863593},{"_id":"public/js/src/bootstrap.js","hash":"edb8690492039f4a4c9b83a3b9abda6d8a214984","modified":1490852863593},{"_id":"public/js/src/theme.js","hash":"5e2e4a290e595a5ebdd8b6866a08700ca20f1c2c","modified":1490852863593},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1490852863593},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1490852863593},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1490852863593},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1490852863593},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1490852863593},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1490852863593},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"39357ff994e53ea15c582b6106094396835a8be0","modified":1490852863593},{"_id":"public/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1490852863593},{"_id":"public/css/style.css","hash":"baa4d132879ef3c7a9aa2d939ceb6912ff0e026b","modified":1490852863624}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2017-01-11T05:42:42.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-01-11 13:42:42\ntype: \"tags\"\n---\n","updated":"2017-01-11T05:43:02.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj0vzatty0001g5f4h2t8doh7","content":"","excerpt":"","more":""}],"Post":[{"title":"132 Pattern","date":"2017-01-03T05:46:25.000Z","_content":"\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n> Input: [1, 2, 3, 4]\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n> \n> Example 2:\n> Input: [3, 1, 4, 2]\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n> Input: [-1, 3, 2, 0]\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","source":"_posts/132Pattern.md","raw":"---\ntitle: 132 Pattern\ndate: 2017-01-03 13:46:25\ntags:\n    - Stack\n---\n\n> Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\n>\n> Note: n will be less than 15,000.\n>\n> Example 1:\n> Input: [1, 2, 3, 4]\n> Output: False\n>\n> Explanation: There is no 132 pattern in the sequence.\n> \n> Example 2:\n> Input: [3, 1, 4, 2]\n> Output: True\n>\n> Explanation: There is a 132 pattern in the sequence: [1, 4, 2].\n>\n> Example 3:\n> Input: [-1, 3, 2, 0]\n> Output: True\n>\n> Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n<!--more-->\n\nThis is Leetcode 456. As the problem description, we can quickly write this solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool find132pattern(vector<int>& nums) {\n            for (int i = 0; i < (int)nums.size() - 2; i++) {\n                for (int j = i + 1; j < (int)nums.size() - 1; j++) {\n                    for (int k = j + 1; k < (int)nums.size(); k++) {\n                        if (check(nums, i, j, k)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        bool check(vector<int> &nums, int idx, int idy, int idz) {\n            if (nums[idx] < nums[idy]\n                    && nums[idz] < nums[idy]\n                    && nums[idx] < nums[idz]) {\n                return true;\n            }\n            return false;\n        }\n};\n```\nBut it's time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 < S2 < S3, we will find use two pointers to aim at the start and the end of the array.\n\nSo, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.\n\nFor more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:\n\nEXAMPLE:\n + i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty\n + i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]\n + i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]\n + i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]\n + i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 < 9, sequence found!\n\nSo, the solution is:\n\n```\nbool find132pattern(vector<int>& nums) {\n    int s3 = INT_MIN, s1;\n    std::stack<int> stack;\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        s1 = nums[i];\n        if (s3 > s1) {\n            return true;\n        } else {\n            while (!stack.empty() && nums[i] > stack.top()) {\n                s3 = stack.top();\n                stack.pop();\n            }\n        }\n        stack.push(nums[i]);\n    }\n    return false;\n}\n```\n","slug":"132Pattern","published":1,"updated":"2017-01-13T03:09:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzattt0000g5f4e6eeeleu","content":"<blockquote>\n<p>Given a sequence of n integers a1, a2, , an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:<br>Input: [1, 2, 3, 4]<br>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:<br>Input: [3, 1, 4, 2]<br>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:<br>Input: [-1, 3, 2, 0]<br>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But its time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given a sequence of n integers a1, a2, , an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>\n<p>Note: n will be less than 15,000.</p>\n<p>Example 1:<br>Input: [1, 2, 3, 4]<br>Output: False</p>\n<p>Explanation: There is no 132 pattern in the sequence.</p>\n<p>Example 2:<br>Input: [3, 1, 4, 2]<br>Output: True</p>\n<p>Explanation: There is a 132 pattern in the sequence: [1, 4, 2].</p>\n<p>Example 3:<br>Input: [-1, 3, 2, 0]<br>Output: True</p>\n<p>Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].</p>\n</blockquote>","more":"<p>This is Leetcode 456. As the problem description, we can quickly write this solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size() - 2; i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size() - 1; j++) &#123;</div><div class=\"line\">                    for (int k = j + 1; k &lt; (int)nums.size(); k++) &#123;</div><div class=\"line\">                        if (check(nums, i, j, k)) &#123;</div><div class=\"line\">                            return true;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(vector&lt;int&gt; &amp;nums, int idx, int idy, int idz) &#123;</div><div class=\"line\">            if (nums[idx] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idz] &lt; nums[idy]</div><div class=\"line\">                    &amp;&amp; nums[idx] &lt; nums[idz]) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But its time complex is O(n^3), and it will get TLE. So, we try to think another way. As a similar problem, try to find a array S1 &lt; S2 &lt; S3, we will find use two pointers to aim at the start and the end of the array.</p>\n<p>So, here we can use a similar solution. We can use a stack to store the num which is bigger than S3, and store it try to find the possible S3.</p>\n<p>For more detail, use [9, 11, 8, 9, 10, 7, 9] as an example:</p>\n<p>EXAMPLE:</p>\n<ul>\n<li>i = 6, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = None, Stack = Empty</li>\n<li>i = 5, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 7, S3 candidate = None, Stack = [9]</li>\n<li>i = 4, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 10, S3 candidate = None, Stack = [9,7]</li>\n<li>i = 3, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 9, S3 candidate = 9, Stack = [10]</li>\n<li>i = 2, nums = [ 9, 11, 8, 9, 10, 7, 9 ], S1 candidate = 8, S3 candidate = 9, Stack = [10,9] We have 8 &lt; 9, sequence found!</li>\n</ul>\n<p>So, the solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool find132pattern(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int s3 = INT_MIN, s1;</div><div class=\"line\">    std::stack&lt;int&gt; stack;</div><div class=\"line\">    for (int i = nums.size() - 1; i &gt;= 0; i--) &#123;</div><div class=\"line\">        s1 = nums[i];</div><div class=\"line\">        if (s3 &gt; s1) &#123;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            while (!stack.empty() &amp;&amp; nums[i] &gt; stack.top()) &#123;</div><div class=\"line\">                s3 = stack.top();</div><div class=\"line\">                stack.pop();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        stack.push(nums[i]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"4Sum II","date":"2017-02-23T01:11:17.000Z","_content":"\n\n> Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\n>\n> To make problem a bit easier, all A, B, C, D have same length of N where 0  N  500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.\n>\n> Example:\n>\n> Input:\n> ```\n A = [ 1, 2]\n B = [-2,-1]\n C = [-1, 2]\n D = [ 0, 2]\n```\n> Output:\n> 2\n>\n> Explanation:\n>\n> The two tuples are:\n> 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n> 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n\n<!--more-->\n\nIt is Leetcode No.454, and I quickly find a simple solution. Because if we use the traditional backtracing solution , the time complex will be O(n^4).\n\nSo I just divide the four array into two part. And I use a map to store the result as <sum, times>.\n\nSo the time complex will be O(2*n^2) and then I can use O(n) to find the total nums.\n\n```\nclass Solution {\n    public:\n        int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n            map<int, int> sums1, sums2;\n            for (int i = 0; i < (int)A.size(); i++) {\n                for (int j = 0; j < (int)B.size(); j++) {\n                    if (sums1.find(A[i] + B[j]) != sums1.end()) {\n                        sums1.find(A[i] + B[j])->second++;\n                    } else {\n                        sums1.insert(pair<int, int>(A[i] + B[j], 1));\n                    }\n                }\n            }\n            for (int i = 0; i < (int)C.size(); i++) {\n                for (int j = 0; j < (int)D.size(); j++) {\n                    if (sums2.find(C[i] + D[j]) != sums2.end()) {\n                        sums2.find(C[i] + D[j])->second++;\n                    } else {\n                        sums2.insert(pair<int, int>(C[i] + D[j], 1));\n                    }\n                }\n            }\n\n            int res = 0;\n            for (auto i : sums1) {\n                if (sums2.find(0 - i.first) != sums2.end()) {\n                    res = res + i.second * sums2.find(0 - i.first)->second;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIt is not the best solution but I think it is a easy-understand solution. Also, it gets AC.\n","source":"_posts/4SumII.md","raw":"---\ntitle: 4Sum II\ndate: 2017-02-23 09:11:17\ntags:\n    - Binary Search\n    - Hash Table\n---\n\n\n> Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.\n>\n> To make problem a bit easier, all A, B, C, D have same length of N where 0  N  500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.\n>\n> Example:\n>\n> Input:\n> ```\n A = [ 1, 2]\n B = [-2,-1]\n C = [-1, 2]\n D = [ 0, 2]\n```\n> Output:\n> 2\n>\n> Explanation:\n>\n> The two tuples are:\n> 1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n> 2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n\n<!--more-->\n\nIt is Leetcode No.454, and I quickly find a simple solution. Because if we use the traditional backtracing solution , the time complex will be O(n^4).\n\nSo I just divide the four array into two part. And I use a map to store the result as <sum, times>.\n\nSo the time complex will be O(2*n^2) and then I can use O(n) to find the total nums.\n\n```\nclass Solution {\n    public:\n        int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {\n            map<int, int> sums1, sums2;\n            for (int i = 0; i < (int)A.size(); i++) {\n                for (int j = 0; j < (int)B.size(); j++) {\n                    if (sums1.find(A[i] + B[j]) != sums1.end()) {\n                        sums1.find(A[i] + B[j])->second++;\n                    } else {\n                        sums1.insert(pair<int, int>(A[i] + B[j], 1));\n                    }\n                }\n            }\n            for (int i = 0; i < (int)C.size(); i++) {\n                for (int j = 0; j < (int)D.size(); j++) {\n                    if (sums2.find(C[i] + D[j]) != sums2.end()) {\n                        sums2.find(C[i] + D[j])->second++;\n                    } else {\n                        sums2.insert(pair<int, int>(C[i] + D[j], 1));\n                    }\n                }\n            }\n\n            int res = 0;\n            for (auto i : sums1) {\n                if (sums2.find(0 - i.first) != sums2.end()) {\n                    res = res + i.second * sums2.find(0 - i.first)->second;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIt is not the best solution but I think it is a easy-understand solution. Also, it gets AC.\n","slug":"4SumII","published":1,"updated":"2017-02-23T01:24:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatu10002g5f4sgkyfsk1","content":"<blockquote>\n<p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>\n<p>To make problem a bit easier, all A, B, C, D have same length of N where 0  N  500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>\n<p>Example:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">A = [ 1, 2]</div><div class=\"line\">B = [-2,-1]</div><div class=\"line\">C = [-1, 2]</div><div class=\"line\">D = [ 0, 2]</div></pre></td></tr></table></figure></p>\n<p>Output:<br>2</p>\n<p>Explanation:</p>\n<p>The two tuples are:</p>\n<ol>\n<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>\n<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is Leetcode No.454, and I quickly find a simple solution. Because if we use the traditional backtracing solution , the time complex will be O(n^4).</p>\n<p>So I just divide the four array into two part. And I use a map to store the result as <sum, times=\"\">.</sum,></p>\n<p>So the time complex will be O(2*n^2) and then I can use O(n) to find the total nums.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;</div><div class=\"line\">            map&lt;int, int&gt; sums1, sums2;</div><div class=\"line\">            for (int i = 0; i &lt; (int)A.size(); i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; (int)B.size(); j++) &#123;</div><div class=\"line\">                    if (sums1.find(A[i] + B[j]) != sums1.end()) &#123;</div><div class=\"line\">                        sums1.find(A[i] + B[j])-&gt;second++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        sums1.insert(pair&lt;int, int&gt;(A[i] + B[j], 1));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)C.size(); i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; (int)D.size(); j++) &#123;</div><div class=\"line\">                    if (sums2.find(C[i] + D[j]) != sums2.end()) &#123;</div><div class=\"line\">                        sums2.find(C[i] + D[j])-&gt;second++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        sums2.insert(pair&lt;int, int&gt;(C[i] + D[j], 1));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto i : sums1) &#123;</div><div class=\"line\">                if (sums2.find(0 - i.first) != sums2.end()) &#123;</div><div class=\"line\">                    res = res + i.second * sums2.find(0 - i.first)-&gt;second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is not the best solution but I think it is a easy-understand solution. Also, it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>\n<p>To make problem a bit easier, all A, B, C, D have same length of N where 0  N  500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>\n<p>Example:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">A = [ 1, 2]</div><div class=\"line\">B = [-2,-1]</div><div class=\"line\">C = [-1, 2]</div><div class=\"line\">D = [ 0, 2]</div></pre></td></tr></table></figure></p>\n<p>Output:<br>2</p>\n<p>Explanation:</p>\n<p>The two tuples are:</p>\n<ol>\n<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li>\n<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li>\n</ol>\n</blockquote>","more":"<p>It is Leetcode No.454, and I quickly find a simple solution. Because if we use the traditional backtracing solution , the time complex will be O(n^4).</p>\n<p>So I just divide the four array into two part. And I use a map to store the result as <sum, times>.</p>\n<p>So the time complex will be O(2*n^2) and then I can use O(n) to find the total nums.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;</div><div class=\"line\">            map&lt;int, int&gt; sums1, sums2;</div><div class=\"line\">            for (int i = 0; i &lt; (int)A.size(); i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; (int)B.size(); j++) &#123;</div><div class=\"line\">                    if (sums1.find(A[i] + B[j]) != sums1.end()) &#123;</div><div class=\"line\">                        sums1.find(A[i] + B[j])-&gt;second++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        sums1.insert(pair&lt;int, int&gt;(A[i] + B[j], 1));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)C.size(); i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; (int)D.size(); j++) &#123;</div><div class=\"line\">                    if (sums2.find(C[i] + D[j]) != sums2.end()) &#123;</div><div class=\"line\">                        sums2.find(C[i] + D[j])-&gt;second++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        sums2.insert(pair&lt;int, int&gt;(C[i] + D[j], 1));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto i : sums1) &#123;</div><div class=\"line\">                if (sums2.find(0 - i.first) != sums2.end()) &#123;</div><div class=\"line\">                    res = res + i.second * sums2.find(0 - i.first)-&gt;second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is not the best solution but I think it is a easy-understand solution. Also, it gets AC.</p>"},{"title":"01 Matrix","date":"2017-03-21T02:44:42.000Z","_content":"\n> Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\n> The distance between two adjacent cells is 1.\n>\n> Example 1:\n>\n> ```\nInput:\n0 0 0\n0 1 0\n0 0 0\nOutput:\n0 0 0\n0 1 0\n0 0 0\n```\n> Example 2:\n>\n> ```\nInput:\n0 0 0\n0 1 0\n1 1 1\nOutput:\n0 0 0\n0 1 0\n1 2 1\n```\n> Note:\n>  + The number of elements of the given matrix will not exceed 10,000.\n>  + There are at least one 0 in the given matrix.\n>  + The cells are adjacent in only four directions: up, down, left and right.\n\n<!--more-->\n\nThis is Leetcode No.542. It is a common problem of Searching. I think it is better to use breadth-first search rather than depth-first search.\n\nHere is my first code:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<int> > updateMatrix(vector<vector<int> >& matrix) {\n            vector<vector<int> > res;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                vector<int> level(matrix[0].size());\n                res.push_back(level);\n            }\n\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                    res[idx][idy] = check(matrix, idx, idy, 0);\n                }\n            }\n\n            return res;\n        }\n\n        int check(vector<vector<int> > matrix, int idx, int idy, int current) {\n            if (idx < 0 || idx >= (int)matrix.size()) {\n                return INT_MAX;\n            }\n            if (idy < 0 || idy >= (int)matrix[0].size()) {\n                return INT_MAX;\n            }\n\n            if (matrix[idx][idy] == 0) {\n                return current;\n            } else {\n                return min(\n                        min(check(matrix, idx - 1, idy, current + 1), check(matrix, idx, idy - 1, current + 1)),\n                        min(check(matrix, idx + 1, idy, current + 1), check(matrix, idx, idy + 1, current + 1))\n                        );\n            }\n\n        }\n};\n```\n\nEasy to understand, but there are some problems, for example the visited cell will be visited twice. So I add the visited array to mark the visited cells.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<int> > updateMatrix(vector<vector<int> >& matrix) {\n            vector<vector<int> > res;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                vector<int> level(matrix[0].size());\n                res.push_back(level);\n            }\n\n            vector<vector<int> > visited;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                vector<int> level(matrix[0].size());\n                visited.push_back(level);\n            }\n\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                    clearVisited(visited);\n                    res[idx][idy] = check(matrix, idx, idy, 0L, visited);\n                    cout << idx << ':' << idy << '=' << res[idx][idy] << endl;\n                }\n            }\n            return res;\n        }\n\n        void clearVisited(vector<vector<int> > &visited) {\n            for (int idx = 0; idx < (int)visited.size(); idx++) {\n                for (int idy = 0; idy < (int)visited[0].size(); idy++) {\n                    visited[idx][idy] = 0;\n                }\n            }\n        }\n\n        int check(vector<vector<int> > matrix, int idx, int idy, long current, vector<vector<int> > &visited) {\n            if (idx < 0 || idx >= (int)matrix.size()) {\n                return INT_MAX;\n            }\n            if (idy < 0 || idy >= (int)matrix[0].size()) {\n                return INT_MAX;\n            }\n            if (visited[idx][idy] == 1) {\n                return INT_MAX;\n            } else {\n                visited[idx][idy] = 1;\n            }\n\n            if (matrix[idx][idy] == 0) {\n                return current;\n            } else {\n                long res = min(\n                        min(check(matrix, idx - 1, idy, current + 1, visited),\n                            check(matrix, idx, idy - 1, current + 1, visited)),\n                        min(check(matrix, idx + 1, idy, current + 1, visited),\n                            check(matrix, idx, idy + 1, current + 1, visited))\n                        );\n                visited[idx][idy] = 0;\n                return res;\n            }\n        }\n};\n```\n\nBut it get a TLE, because the same cell will be counted more than once. So I have to figure out some more solutions.\n\nYou may think about a DP or memerized method based on BFS or DFS.\n\nHowever, you can find another better way to solve the problem.\n\n0. mark all cells expect 0 to INT_MAX.\n1. find all the 0 cell.\n2. find all neighbours around this 0 cell and mark them 1.\n3. then find all the 1 cell and do No.1 step.\n\nThe time complex is O(n).\n\nAnd the solution is like these:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<int> > updateMatrix(vector<vector<int> >& matrix) {\n            int remain = 0;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                    if (matrix[idx][idy] != 0) {\n                        matrix[idx][idy] = INT_MAX;\n                        remain++;\n                    }\n                }\n            }\n            int flag = 1;\n            do {\n                for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                    for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                        if (matrix[idx][idy] == flag - 1) {\n                            if (idx - 1 >= 0 && matrix[idx - 1][idy] == INT_MAX) {\n                                matrix[idx - 1][idy] = flag;\n                                remain--;\n                            }\n                            if (idx + 1 < (int)matrix.size() && matrix[idx + 1][idy] == INT_MAX) {\n                                matrix[idx + 1][idy] = flag;\n                                remain--;\n                            }\n                            if (idy - 1 >= 0 && matrix[idx][idy - 1] == INT_MAX) {\n                                matrix[idx][idy - 1] = flag;\n                                remain--;\n                            }\n                            if (idy + 1 < (int)matrix[0].size() && matrix[idx][idy + 1] == INT_MAX) {\n                                matrix[idx][idy + 1] = flag;\n                                remain--;\n                            }\n                        }\n                    }\n                }\n                flag++;\n            } while (remain > 0);\n\n            return matrix;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/01Matrix.md","raw":"---\ntitle: 01 Matrix\ndate: 2017-03-21 10:44:42\ntags:\n    - Depth-first Search\n    - Breadth-first Search\n---\n\n> Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\n> The distance between two adjacent cells is 1.\n>\n> Example 1:\n>\n> ```\nInput:\n0 0 0\n0 1 0\n0 0 0\nOutput:\n0 0 0\n0 1 0\n0 0 0\n```\n> Example 2:\n>\n> ```\nInput:\n0 0 0\n0 1 0\n1 1 1\nOutput:\n0 0 0\n0 1 0\n1 2 1\n```\n> Note:\n>  + The number of elements of the given matrix will not exceed 10,000.\n>  + There are at least one 0 in the given matrix.\n>  + The cells are adjacent in only four directions: up, down, left and right.\n\n<!--more-->\n\nThis is Leetcode No.542. It is a common problem of Searching. I think it is better to use breadth-first search rather than depth-first search.\n\nHere is my first code:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<int> > updateMatrix(vector<vector<int> >& matrix) {\n            vector<vector<int> > res;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                vector<int> level(matrix[0].size());\n                res.push_back(level);\n            }\n\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                    res[idx][idy] = check(matrix, idx, idy, 0);\n                }\n            }\n\n            return res;\n        }\n\n        int check(vector<vector<int> > matrix, int idx, int idy, int current) {\n            if (idx < 0 || idx >= (int)matrix.size()) {\n                return INT_MAX;\n            }\n            if (idy < 0 || idy >= (int)matrix[0].size()) {\n                return INT_MAX;\n            }\n\n            if (matrix[idx][idy] == 0) {\n                return current;\n            } else {\n                return min(\n                        min(check(matrix, idx - 1, idy, current + 1), check(matrix, idx, idy - 1, current + 1)),\n                        min(check(matrix, idx + 1, idy, current + 1), check(matrix, idx, idy + 1, current + 1))\n                        );\n            }\n\n        }\n};\n```\n\nEasy to understand, but there are some problems, for example the visited cell will be visited twice. So I add the visited array to mark the visited cells.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<int> > updateMatrix(vector<vector<int> >& matrix) {\n            vector<vector<int> > res;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                vector<int> level(matrix[0].size());\n                res.push_back(level);\n            }\n\n            vector<vector<int> > visited;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                vector<int> level(matrix[0].size());\n                visited.push_back(level);\n            }\n\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                    clearVisited(visited);\n                    res[idx][idy] = check(matrix, idx, idy, 0L, visited);\n                    cout << idx << ':' << idy << '=' << res[idx][idy] << endl;\n                }\n            }\n            return res;\n        }\n\n        void clearVisited(vector<vector<int> > &visited) {\n            for (int idx = 0; idx < (int)visited.size(); idx++) {\n                for (int idy = 0; idy < (int)visited[0].size(); idy++) {\n                    visited[idx][idy] = 0;\n                }\n            }\n        }\n\n        int check(vector<vector<int> > matrix, int idx, int idy, long current, vector<vector<int> > &visited) {\n            if (idx < 0 || idx >= (int)matrix.size()) {\n                return INT_MAX;\n            }\n            if (idy < 0 || idy >= (int)matrix[0].size()) {\n                return INT_MAX;\n            }\n            if (visited[idx][idy] == 1) {\n                return INT_MAX;\n            } else {\n                visited[idx][idy] = 1;\n            }\n\n            if (matrix[idx][idy] == 0) {\n                return current;\n            } else {\n                long res = min(\n                        min(check(matrix, idx - 1, idy, current + 1, visited),\n                            check(matrix, idx, idy - 1, current + 1, visited)),\n                        min(check(matrix, idx + 1, idy, current + 1, visited),\n                            check(matrix, idx, idy + 1, current + 1, visited))\n                        );\n                visited[idx][idy] = 0;\n                return res;\n            }\n        }\n};\n```\n\nBut it get a TLE, because the same cell will be counted more than once. So I have to figure out some more solutions.\n\nYou may think about a DP or memerized method based on BFS or DFS.\n\nHowever, you can find another better way to solve the problem.\n\n0. mark all cells expect 0 to INT_MAX.\n1. find all the 0 cell.\n2. find all neighbours around this 0 cell and mark them 1.\n3. then find all the 1 cell and do No.1 step.\n\nThe time complex is O(n).\n\nAnd the solution is like these:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<int> > updateMatrix(vector<vector<int> >& matrix) {\n            int remain = 0;\n            for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                    if (matrix[idx][idy] != 0) {\n                        matrix[idx][idy] = INT_MAX;\n                        remain++;\n                    }\n                }\n            }\n            int flag = 1;\n            do {\n                for (int idx = 0; idx < (int)matrix.size(); idx++) {\n                    for (int idy = 0; idy < (int)matrix[0].size(); idy++) {\n                        if (matrix[idx][idy] == flag - 1) {\n                            if (idx - 1 >= 0 && matrix[idx - 1][idy] == INT_MAX) {\n                                matrix[idx - 1][idy] = flag;\n                                remain--;\n                            }\n                            if (idx + 1 < (int)matrix.size() && matrix[idx + 1][idy] == INT_MAX) {\n                                matrix[idx + 1][idy] = flag;\n                                remain--;\n                            }\n                            if (idy - 1 >= 0 && matrix[idx][idy - 1] == INT_MAX) {\n                                matrix[idx][idy - 1] = flag;\n                                remain--;\n                            }\n                            if (idy + 1 < (int)matrix[0].size() && matrix[idx][idy + 1] == INT_MAX) {\n                                matrix[idx][idy + 1] = flag;\n                                remain--;\n                            }\n                        }\n                    }\n                }\n                flag++;\n            } while (remain > 0);\n\n            return matrix;\n        }\n};\n```\n\nIt gets AC.\n","slug":"01Matrix","published":1,"updated":"2017-03-21T11:27:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatu60004g5f4ofzf7m3x","content":"<blockquote>\n<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.<br>The distance between two adjacent cells is 1.</p>\n<p>Example 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">0 0 0</div><div class=\"line\">Output:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">0 0 0</div></pre></td></tr></table></figure>\n<p>Example 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">1 1 1</div><div class=\"line\">Output:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">1 2 1</div></pre></td></tr></table></figure>\n<p>Note:</p>\n<ul>\n<li>The number of elements of the given matrix will not exceed 10,000.</li>\n<li>There are at least one 0 in the given matrix.</li>\n<li>The cells are adjacent in only four directions: up, down, left and right.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.542. It is a common problem of Searching. I think it is better to use breadth-first search rather than depth-first search.</p>\n<p>Here is my first code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; updateMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                vector&lt;int&gt; level(matrix[0].size());</div><div class=\"line\">                res.push_back(level);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                    res[idx][idy] = check(matrix, idx, idy, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int check(vector&lt;vector&lt;int&gt; &gt; matrix, int idx, int idy, int current) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idx &gt;= (int)matrix.size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idy &lt; 0 || idy &gt;= (int)matrix[0].size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (matrix[idx][idy] == 0) &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return min(</div><div class=\"line\">                        min(check(matrix, idx - 1, idy, current + 1), check(matrix, idx, idy - 1, current + 1)),</div><div class=\"line\">                        min(check(matrix, idx + 1, idy, current + 1), check(matrix, idx, idy + 1, current + 1))</div><div class=\"line\">                        );</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Easy to understand, but there are some problems, for example the visited cell will be visited twice. So I add the visited array to mark the visited cells.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; updateMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                vector&lt;int&gt; level(matrix[0].size());</div><div class=\"line\">                res.push_back(level);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; visited;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                vector&lt;int&gt; level(matrix[0].size());</div><div class=\"line\">                visited.push_back(level);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                    clearVisited(visited);</div><div class=\"line\">                    res[idx][idy] = check(matrix, idx, idy, 0L, visited);</div><div class=\"line\">                    cout &lt;&lt; idx &lt;&lt; &apos;:&apos; &lt;&lt; idy &lt;&lt; &apos;=&apos; &lt;&lt; res[idx][idy] &lt;&lt; endl;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void clearVisited(vector&lt;vector&lt;int&gt; &gt; &amp;visited) &#123;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)visited.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)visited[0].size(); idy++) &#123;</div><div class=\"line\">                    visited[idx][idy] = 0;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int check(vector&lt;vector&lt;int&gt; &gt; matrix, int idx, int idy, long current, vector&lt;vector&lt;int&gt; &gt; &amp;visited) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idx &gt;= (int)matrix.size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idy &lt; 0 || idy &gt;= (int)matrix[0].size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (visited[idx][idy] == 1) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                visited[idx][idy] = 1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (matrix[idx][idy] == 0) &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                long res = min(</div><div class=\"line\">                        min(check(matrix, idx - 1, idy, current + 1, visited),</div><div class=\"line\">                            check(matrix, idx, idy - 1, current + 1, visited)),</div><div class=\"line\">                        min(check(matrix, idx + 1, idy, current + 1, visited),</div><div class=\"line\">                            check(matrix, idx, idy + 1, current + 1, visited))</div><div class=\"line\">                        );</div><div class=\"line\">                visited[idx][idy] = 0;</div><div class=\"line\">                return res;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it get a TLE, because the same cell will be counted more than once. So I have to figure out some more solutions.</p>\n<p>You may think about a DP or memerized method based on BFS or DFS.</p>\n<p>However, you can find another better way to solve the problem.</p>\n<ol>\n<li>mark all cells expect 0 to INT_MAX.</li>\n<li>find all the 0 cell.</li>\n<li>find all neighbours around this 0 cell and mark them 1.</li>\n<li>then find all the 1 cell and do No.1 step.</li>\n</ol>\n<p>The time complex is O(n).</p>\n<p>And the solution is like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; updateMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            int remain = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                    if (matrix[idx][idy] != 0) &#123;</div><div class=\"line\">                        matrix[idx][idy] = INT_MAX;</div><div class=\"line\">                        remain++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int flag = 1;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                    for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                        if (matrix[idx][idy] == flag - 1) &#123;</div><div class=\"line\">                            if (idx - 1 &gt;= 0 &amp;&amp; matrix[idx - 1][idy] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx - 1][idy] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            if (idx + 1 &lt; (int)matrix.size() &amp;&amp; matrix[idx + 1][idy] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx + 1][idy] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            if (idy - 1 &gt;= 0 &amp;&amp; matrix[idx][idy - 1] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx][idy - 1] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            if (idy + 1 &lt; (int)matrix[0].size() &amp;&amp; matrix[idx][idy + 1] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx][idy + 1] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                flag++;</div><div class=\"line\">            &#125; while (remain &gt; 0);</div><div class=\"line\"></div><div class=\"line\">            return matrix;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.<br>The distance between two adjacent cells is 1.</p>\n<p>Example 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">0 0 0</div><div class=\"line\">Output:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">0 0 0</div></pre></td></tr></table></figure>\n<p>Example 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">1 1 1</div><div class=\"line\">Output:</div><div class=\"line\">0 0 0</div><div class=\"line\">0 1 0</div><div class=\"line\">1 2 1</div></pre></td></tr></table></figure>\n<p>Note:</p>\n<ul>\n<li>The number of elements of the given matrix will not exceed 10,000.</li>\n<li>There are at least one 0 in the given matrix.</li>\n<li>The cells are adjacent in only four directions: up, down, left and right.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.542. It is a common problem of Searching. I think it is better to use breadth-first search rather than depth-first search.</p>\n<p>Here is my first code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; updateMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                vector&lt;int&gt; level(matrix[0].size());</div><div class=\"line\">                res.push_back(level);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                    res[idx][idy] = check(matrix, idx, idy, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int check(vector&lt;vector&lt;int&gt; &gt; matrix, int idx, int idy, int current) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idx &gt;= (int)matrix.size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idy &lt; 0 || idy &gt;= (int)matrix[0].size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (matrix[idx][idy] == 0) &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return min(</div><div class=\"line\">                        min(check(matrix, idx - 1, idy, current + 1), check(matrix, idx, idy - 1, current + 1)),</div><div class=\"line\">                        min(check(matrix, idx + 1, idy, current + 1), check(matrix, idx, idy + 1, current + 1))</div><div class=\"line\">                        );</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Easy to understand, but there are some problems, for example the visited cell will be visited twice. So I add the visited array to mark the visited cells.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; updateMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                vector&lt;int&gt; level(matrix[0].size());</div><div class=\"line\">                res.push_back(level);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; visited;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                vector&lt;int&gt; level(matrix[0].size());</div><div class=\"line\">                visited.push_back(level);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                    clearVisited(visited);</div><div class=\"line\">                    res[idx][idy] = check(matrix, idx, idy, 0L, visited);</div><div class=\"line\">                    cout &lt;&lt; idx &lt;&lt; &apos;:&apos; &lt;&lt; idy &lt;&lt; &apos;=&apos; &lt;&lt; res[idx][idy] &lt;&lt; endl;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void clearVisited(vector&lt;vector&lt;int&gt; &gt; &amp;visited) &#123;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)visited.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)visited[0].size(); idy++) &#123;</div><div class=\"line\">                    visited[idx][idy] = 0;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int check(vector&lt;vector&lt;int&gt; &gt; matrix, int idx, int idy, long current, vector&lt;vector&lt;int&gt; &gt; &amp;visited) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idx &gt;= (int)matrix.size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idy &lt; 0 || idy &gt;= (int)matrix[0].size()) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (visited[idx][idy] == 1) &#123;</div><div class=\"line\">                return INT_MAX;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                visited[idx][idy] = 1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (matrix[idx][idy] == 0) &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                long res = min(</div><div class=\"line\">                        min(check(matrix, idx - 1, idy, current + 1, visited),</div><div class=\"line\">                            check(matrix, idx, idy - 1, current + 1, visited)),</div><div class=\"line\">                        min(check(matrix, idx + 1, idy, current + 1, visited),</div><div class=\"line\">                            check(matrix, idx, idy + 1, current + 1, visited))</div><div class=\"line\">                        );</div><div class=\"line\">                visited[idx][idy] = 0;</div><div class=\"line\">                return res;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But it get a TLE, because the same cell will be counted more than once. So I have to figure out some more solutions.</p>\n<p>You may think about a DP or memerized method based on BFS or DFS.</p>\n<p>However, you can find another better way to solve the problem.</p>\n<ol>\n<li>mark all cells expect 0 to INT_MAX.</li>\n<li>find all the 0 cell.</li>\n<li>find all neighbours around this 0 cell and mark them 1.</li>\n<li>then find all the 1 cell and do No.1 step.</li>\n</ol>\n<p>The time complex is O(n).</p>\n<p>And the solution is like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; updateMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            int remain = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                    if (matrix[idx][idy] != 0) &#123;</div><div class=\"line\">                        matrix[idx][idy] = INT_MAX;</div><div class=\"line\">                        remain++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int flag = 1;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                for (int idx = 0; idx &lt; (int)matrix.size(); idx++) &#123;</div><div class=\"line\">                    for (int idy = 0; idy &lt; (int)matrix[0].size(); idy++) &#123;</div><div class=\"line\">                        if (matrix[idx][idy] == flag - 1) &#123;</div><div class=\"line\">                            if (idx - 1 &gt;= 0 &amp;&amp; matrix[idx - 1][idy] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx - 1][idy] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            if (idx + 1 &lt; (int)matrix.size() &amp;&amp; matrix[idx + 1][idy] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx + 1][idy] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            if (idy - 1 &gt;= 0 &amp;&amp; matrix[idx][idy - 1] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx][idy - 1] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            if (idy + 1 &lt; (int)matrix[0].size() &amp;&amp; matrix[idx][idy + 1] == INT_MAX) &#123;</div><div class=\"line\">                                matrix[idx][idy + 1] = flag;</div><div class=\"line\">                                remain--;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                flag++;</div><div class=\"line\">            &#125; while (remain &gt; 0);</div><div class=\"line\"></div><div class=\"line\">            return matrix;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"403 Forbidden","date":"2017-02-15T05:15:56.000Z","_content":"\n\n> **Description**\n> Little Hi runs a web server. Sometimes he has to deny access from a certain set of malicious IP addresses while his friends are still allow to access his server. To do this he writes N rules in the configuration file which look like:\n> ```\nallow 1.2.3.4/30\ndeny 1.1.1.1\nallow 127.0.0.1\nallow 123.234.12.23/3\ndeny 0.0.0.0/0\n```\n> Each rule is in the form: allow | deny address or allow | deny address/mask.\n>\n> When there comes a request, the rules are checked in sequence until the first match is found. If no rule is matched the request will be allowed. Rule and request are matched if the request address is the same as the rule address or they share the same first mask digits when both written as 32bit binary number.\n>\n> For example IP \"1.2.3.4\" matches rule \"allow 1.2.3.4\" because the addresses are the same. And IP \"128.127.8.125\" matches rule \"deny 128.127.4.100/20\" because 10000000011111110000010001100100 (128.127.4.100 as binary number) shares the first 20 (mask) digits with 10000000011111110000100001111101 (128.127.8.125 as binary number).\n>\n> Now comes M access requests. Given their IP addresses, your task is to find out which ones are allowed and which ones are denied.\n>\n> **Input**\n>\n> + Line 1: two integers N and M.\n> + Line 2-N+1: one rule on each line.\n> + Line N+2-N+M+1: one IP address on each line.\n> + All addresses are IPv4 addresses(0.0.0.0 - 255.255.255.255). 0 <= mask <= 32.\n> + For 40% of the data: 1 <= N, M <= 1000.\n> + For 100% of the data: 1 <= N, M <= 100000.\n>\n> **Output**\n>\n> For each request output \"YES\" or \"NO\" according to whether it is allowed.\n>\n<!--more-->\n>\n> ** Sample Input**\n> ```\n5 5\nallow 1.2.3.4/30\ndeny 1.1.1.1\nallow 127.0.0.1\nallow 123.234.12.23/3\ndeny 0.0.0.0/0\n1.2.3.4\n1.2.3.5\n1.1.1.1\n100.100.100.100\n219.142.53.100\n```\n> **Sample Output**\n> ```\nYES\nYES\nNO\nYES\nNO\n ```\n<!--more-->\n\nIt is one of the Microsoft 2016 Campus Hiring Contest - April. It is fun and it is such a problem to test our basic programming skills.\n\nI just find that Java may be a better language to solve this problem. So I use Java to deal with this problem.\n\nIt's complex and easy to get 40% data.\n\n```\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class P1289 {\n\n    static class Rule {\n        public String  address;\n        public boolean isAllowed;\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Rule address1 = (Rule) o;\n\n            if (isAllowed != address1.isAllowed) return false;\n            return address != null ? address.equals(address1.address) : address1.address == null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = address != null ? address.hashCode() : 0;\n            result = 31 * result + (isAllowed ? 1 : 0);\n            return result;\n        }\n    }\n\n    public static String append8bit(String binary) {\n        switch (binary.length()) {\n            case 0:\n                return \"00000000\";\n            case 1:\n                return \"0000000\" + binary;\n            case 2:\n                return \"000000\" + binary;\n            case 3:\n                return \"00000\" + binary;\n            case 4:\n                return \"0000\" + binary;\n            case 5:\n                return \"000\" + binary;\n            case 6:\n                return \"00\" + binary;\n            case 7:\n                return \"0\" + binary;\n            default:\n                return binary;\n        }\n    }\n\n    public static String ip2str(String ip) {\n        StringBuilder stringBuilder = new StringBuilder(32);\n        String res = null;\n        String[] parts = ip.split(\"\\\\.\");\n\n        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[0]))));\n        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[1]))));\n        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[2]))));\n        if (parts[3].contains(\"/\")) {\n            String[] ip_mask = parts[3].split(\"/\");\n            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(ip_mask[0]))));\n            res = stringBuilder.substring(0, Integer.valueOf(ip_mask[1]));\n        } else {\n            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[3]))));\n            res = stringBuilder.toString();\n        }\n        return res;\n    }\n\n    public static boolean check(String address, Vector<Rule> rules) {\n        for (int i = 0; i < rules.size(); i++) {\n            if (address.startsWith(rules.get(i).address)) {\n                return rules.get(i).isAllowed;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int M, N;\n        while (scanner.hasNext()) {\n            N = scanner.nextInt();\n            M = scanner.nextInt();\n            scanner.nextLine();\n            Vector<Rule> rules = new Vector<Rule>(N);\n            for (int i = 0; i < N; i++) {\n                String ruleStr = scanner.nextLine();\n                Rule rule = new Rule();\n                if (ruleStr.startsWith(\"a\")) {\n                    ruleStr = ruleStr.substring(6);\n                    rule.isAllowed = true;\n                    rule.address = ip2str(ruleStr);\n                } else {\n                    ruleStr = ruleStr.substring(5);\n                    rule.isAllowed = false;\n                    rule.address = ip2str(ruleStr);\n                }\n                rules.add(rule);\n            }\n\n            for (int i = 0; i < M; i++) {\n                String IP = ip2str(scanner.nextLine());\n                if (check(IP, rules)) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n}\n```\n\nIt passed 40% data. And I think if I want to pass the total data, I should do something better, like combining the rules.\n\nI will check the better solution later.\n","source":"_posts/403Forbidden.md","raw":"---\ntitle: 403 Forbidden\ndate: 2017-02-15 13:15:56\ntags:\n    - Array\n    - Trie\n    - Hash Table\n---\n\n\n> **Description**\n> Little Hi runs a web server. Sometimes he has to deny access from a certain set of malicious IP addresses while his friends are still allow to access his server. To do this he writes N rules in the configuration file which look like:\n> ```\nallow 1.2.3.4/30\ndeny 1.1.1.1\nallow 127.0.0.1\nallow 123.234.12.23/3\ndeny 0.0.0.0/0\n```\n> Each rule is in the form: allow | deny address or allow | deny address/mask.\n>\n> When there comes a request, the rules are checked in sequence until the first match is found. If no rule is matched the request will be allowed. Rule and request are matched if the request address is the same as the rule address or they share the same first mask digits when both written as 32bit binary number.\n>\n> For example IP \"1.2.3.4\" matches rule \"allow 1.2.3.4\" because the addresses are the same. And IP \"128.127.8.125\" matches rule \"deny 128.127.4.100/20\" because 10000000011111110000010001100100 (128.127.4.100 as binary number) shares the first 20 (mask) digits with 10000000011111110000100001111101 (128.127.8.125 as binary number).\n>\n> Now comes M access requests. Given their IP addresses, your task is to find out which ones are allowed and which ones are denied.\n>\n> **Input**\n>\n> + Line 1: two integers N and M.\n> + Line 2-N+1: one rule on each line.\n> + Line N+2-N+M+1: one IP address on each line.\n> + All addresses are IPv4 addresses(0.0.0.0 - 255.255.255.255). 0 <= mask <= 32.\n> + For 40% of the data: 1 <= N, M <= 1000.\n> + For 100% of the data: 1 <= N, M <= 100000.\n>\n> **Output**\n>\n> For each request output \"YES\" or \"NO\" according to whether it is allowed.\n>\n<!--more-->\n>\n> ** Sample Input**\n> ```\n5 5\nallow 1.2.3.4/30\ndeny 1.1.1.1\nallow 127.0.0.1\nallow 123.234.12.23/3\ndeny 0.0.0.0/0\n1.2.3.4\n1.2.3.5\n1.1.1.1\n100.100.100.100\n219.142.53.100\n```\n> **Sample Output**\n> ```\nYES\nYES\nNO\nYES\nNO\n ```\n<!--more-->\n\nIt is one of the Microsoft 2016 Campus Hiring Contest - April. It is fun and it is such a problem to test our basic programming skills.\n\nI just find that Java may be a better language to solve this problem. So I use Java to deal with this problem.\n\nIt's complex and easy to get 40% data.\n\n```\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class P1289 {\n\n    static class Rule {\n        public String  address;\n        public boolean isAllowed;\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Rule address1 = (Rule) o;\n\n            if (isAllowed != address1.isAllowed) return false;\n            return address != null ? address.equals(address1.address) : address1.address == null;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = address != null ? address.hashCode() : 0;\n            result = 31 * result + (isAllowed ? 1 : 0);\n            return result;\n        }\n    }\n\n    public static String append8bit(String binary) {\n        switch (binary.length()) {\n            case 0:\n                return \"00000000\";\n            case 1:\n                return \"0000000\" + binary;\n            case 2:\n                return \"000000\" + binary;\n            case 3:\n                return \"00000\" + binary;\n            case 4:\n                return \"0000\" + binary;\n            case 5:\n                return \"000\" + binary;\n            case 6:\n                return \"00\" + binary;\n            case 7:\n                return \"0\" + binary;\n            default:\n                return binary;\n        }\n    }\n\n    public static String ip2str(String ip) {\n        StringBuilder stringBuilder = new StringBuilder(32);\n        String res = null;\n        String[] parts = ip.split(\"\\\\.\");\n\n        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[0]))));\n        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[1]))));\n        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[2]))));\n        if (parts[3].contains(\"/\")) {\n            String[] ip_mask = parts[3].split(\"/\");\n            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(ip_mask[0]))));\n            res = stringBuilder.substring(0, Integer.valueOf(ip_mask[1]));\n        } else {\n            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[3]))));\n            res = stringBuilder.toString();\n        }\n        return res;\n    }\n\n    public static boolean check(String address, Vector<Rule> rules) {\n        for (int i = 0; i < rules.size(); i++) {\n            if (address.startsWith(rules.get(i).address)) {\n                return rules.get(i).isAllowed;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int M, N;\n        while (scanner.hasNext()) {\n            N = scanner.nextInt();\n            M = scanner.nextInt();\n            scanner.nextLine();\n            Vector<Rule> rules = new Vector<Rule>(N);\n            for (int i = 0; i < N; i++) {\n                String ruleStr = scanner.nextLine();\n                Rule rule = new Rule();\n                if (ruleStr.startsWith(\"a\")) {\n                    ruleStr = ruleStr.substring(6);\n                    rule.isAllowed = true;\n                    rule.address = ip2str(ruleStr);\n                } else {\n                    ruleStr = ruleStr.substring(5);\n                    rule.isAllowed = false;\n                    rule.address = ip2str(ruleStr);\n                }\n                rules.add(rule);\n            }\n\n            for (int i = 0; i < M; i++) {\n                String IP = ip2str(scanner.nextLine());\n                if (check(IP, rules)) {\n                    System.out.println(\"YES\");\n                } else {\n                    System.out.println(\"NO\");\n                }\n            }\n        }\n    }\n}\n```\n\nIt passed 40% data. And I think if I want to pass the total data, I should do something better, like combining the rules.\n\nI will check the better solution later.\n","slug":"403Forbidden","published":1,"updated":"2017-02-15T06:44:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatua0005g5f4xv55sexb","content":"<blockquote>\n<p><strong>Description</strong><br>Little Hi runs a web server. Sometimes he has to deny access from a certain set of malicious IP addresses while his friends are still allow to access his server. To do this he writes N rules in the configuration file which look like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">allow 1.2.3.4/30</div><div class=\"line\">deny 1.1.1.1</div><div class=\"line\">allow 127.0.0.1</div><div class=\"line\">allow 123.234.12.23/3</div><div class=\"line\">deny 0.0.0.0/0</div></pre></td></tr></table></figure></p>\n<p>Each rule is in the form: allow | deny address or allow | deny address/mask.</p>\n<p>When there comes a request, the rules are checked in sequence until the first match is found. If no rule is matched the request will be allowed. Rule and request are matched if the request address is the same as the rule address or they share the same first mask digits when both written as 32bit binary number.</p>\n<p>For example IP 1.2.3.4 matches rule allow 1.2.3.4 because the addresses are the same. And IP 128.127.8.125 matches rule deny 128.127.4.100/20 because 10000000011111110000010001100100 (128.127.4.100 as binary number) shares the first 20 (mask) digits with 10000000011111110000100001111101 (128.127.8.125 as binary number).</p>\n<p>Now comes M access requests. Given their IP addresses, your task is to find out which ones are allowed and which ones are denied.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li>Line 1: two integers N and M.</li>\n<li>Line 2-N+1: one rule on each line.</li>\n<li>Line N+2-N+M+1: one IP address on each line.</li>\n<li>All addresses are IPv4 addresses(0.0.0.0 - 255.255.255.255). 0 &lt;= mask &lt;= 32.</li>\n<li>For 40% of the data: 1 &lt;= N, M &lt;= 1000.</li>\n<li>For 100% of the data: 1 &lt;= N, M &lt;= 100000.</li>\n</ul>\n<p><strong>Output</strong></p>\n<p>For each request output YES or NO according to whether it is allowed.</p>\n<a id=\"more\"></a>\n<p><strong> Sample Input</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">5 5</div><div class=\"line\">allow 1.2.3.4/30</div><div class=\"line\">deny 1.1.1.1</div><div class=\"line\">allow 127.0.0.1</div><div class=\"line\">allow 123.234.12.23/3</div><div class=\"line\">deny 0.0.0.0/0</div><div class=\"line\">1.2.3.4</div><div class=\"line\">1.2.3.5</div><div class=\"line\">1.1.1.1</div><div class=\"line\">100.100.100.100</div><div class=\"line\">219.142.53.100</div></pre></td></tr></table></figure></p>\n<p><strong>Sample Output</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">YES</div><div class=\"line\">YES</div><div class=\"line\">NO</div><div class=\"line\">YES</div><div class=\"line\">NO</div></pre></td></tr></table></figure></p>\n</blockquote>\n<!--more-->\n<p>It is one of the Microsoft 2016 Campus Hiring Contest - April. It is fun and it is such a problem to test our basic programming skills.</p>\n<p>I just find that Java may be a better language to solve this problem. So I use Java to deal with this problem.</p>\n<p>Its complex and easy to get 40% data.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.util.Scanner;</div><div class=\"line\">import java.util.Vector;</div><div class=\"line\"></div><div class=\"line\">public class P1289 &#123;</div><div class=\"line\"></div><div class=\"line\">    static class Rule &#123;</div><div class=\"line\">        public String  address;</div><div class=\"line\">        public boolean isAllowed;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public boolean equals(Object o) &#123;</div><div class=\"line\">            if (this == o) return true;</div><div class=\"line\">            if (o == null || getClass() != o.getClass()) return false;</div><div class=\"line\"></div><div class=\"line\">            Rule address1 = (Rule) o;</div><div class=\"line\"></div><div class=\"line\">            if (isAllowed != address1.isAllowed) return false;</div><div class=\"line\">            return address != null ? address.equals(address1.address) : address1.address == null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public int hashCode() &#123;</div><div class=\"line\">            int result = address != null ? address.hashCode() : 0;</div><div class=\"line\">            result = 31 * result + (isAllowed ? 1 : 0);</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static String append8bit(String binary) &#123;</div><div class=\"line\">        switch (binary.length()) &#123;</div><div class=\"line\">            case 0:</div><div class=\"line\">                return &quot;00000000&quot;;</div><div class=\"line\">            case 1:</div><div class=\"line\">                return &quot;0000000&quot; + binary;</div><div class=\"line\">            case 2:</div><div class=\"line\">                return &quot;000000&quot; + binary;</div><div class=\"line\">            case 3:</div><div class=\"line\">                return &quot;00000&quot; + binary;</div><div class=\"line\">            case 4:</div><div class=\"line\">                return &quot;0000&quot; + binary;</div><div class=\"line\">            case 5:</div><div class=\"line\">                return &quot;000&quot; + binary;</div><div class=\"line\">            case 6:</div><div class=\"line\">                return &quot;00&quot; + binary;</div><div class=\"line\">            case 7:</div><div class=\"line\">                return &quot;0&quot; + binary;</div><div class=\"line\">            default:</div><div class=\"line\">                return binary;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static String ip2str(String ip) &#123;</div><div class=\"line\">        StringBuilder stringBuilder = new StringBuilder(32);</div><div class=\"line\">        String res = null;</div><div class=\"line\">        String[] parts = ip.split(&quot;\\\\.&quot;);</div><div class=\"line\"></div><div class=\"line\">        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[0]))));</div><div class=\"line\">        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[1]))));</div><div class=\"line\">        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[2]))));</div><div class=\"line\">        if (parts[3].contains(&quot;/&quot;)) &#123;</div><div class=\"line\">            String[] ip_mask = parts[3].split(&quot;/&quot;);</div><div class=\"line\">            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(ip_mask[0]))));</div><div class=\"line\">            res = stringBuilder.substring(0, Integer.valueOf(ip_mask[1]));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[3]))));</div><div class=\"line\">            res = stringBuilder.toString();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static boolean check(String address, Vector&lt;Rule&gt; rules) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; rules.size(); i++) &#123;</div><div class=\"line\">            if (address.startsWith(rules.get(i).address)) &#123;</div><div class=\"line\">                return rules.get(i).isAllowed;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        Scanner scanner = new Scanner(System.in);</div><div class=\"line\"></div><div class=\"line\">        int M, N;</div><div class=\"line\">        while (scanner.hasNext()) &#123;</div><div class=\"line\">            N = scanner.nextInt();</div><div class=\"line\">            M = scanner.nextInt();</div><div class=\"line\">            scanner.nextLine();</div><div class=\"line\">            Vector&lt;Rule&gt; rules = new Vector&lt;Rule&gt;(N);</div><div class=\"line\">            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                String ruleStr = scanner.nextLine();</div><div class=\"line\">                Rule rule = new Rule();</div><div class=\"line\">                if (ruleStr.startsWith(&quot;a&quot;)) &#123;</div><div class=\"line\">                    ruleStr = ruleStr.substring(6);</div><div class=\"line\">                    rule.isAllowed = true;</div><div class=\"line\">                    rule.address = ip2str(ruleStr);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    ruleStr = ruleStr.substring(5);</div><div class=\"line\">                    rule.isAllowed = false;</div><div class=\"line\">                    rule.address = ip2str(ruleStr);</div><div class=\"line\">                &#125;</div><div class=\"line\">                rules.add(rule);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; M; i++) &#123;</div><div class=\"line\">                String IP = ip2str(scanner.nextLine());</div><div class=\"line\">                if (check(IP, rules)) &#123;</div><div class=\"line\">                    System.out.println(&quot;YES&quot;);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    System.out.println(&quot;NO&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>It passed 40% data. And I think if I want to pass the total data, I should do something better, like combining the rules.</p>\n<p>I will check the better solution later.</p>\n","excerpt":"<blockquote>\n<p><strong>Description</strong><br>Little Hi runs a web server. Sometimes he has to deny access from a certain set of malicious IP addresses while his friends are still allow to access his server. To do this he writes N rules in the configuration file which look like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">allow 1.2.3.4/30</div><div class=\"line\">deny 1.1.1.1</div><div class=\"line\">allow 127.0.0.1</div><div class=\"line\">allow 123.234.12.23/3</div><div class=\"line\">deny 0.0.0.0/0</div></pre></td></tr></table></figure></p>\n<p>Each rule is in the form: allow | deny address or allow | deny address/mask.</p>\n<p>When there comes a request, the rules are checked in sequence until the first match is found. If no rule is matched the request will be allowed. Rule and request are matched if the request address is the same as the rule address or they share the same first mask digits when both written as 32bit binary number.</p>\n<p>For example IP 1.2.3.4 matches rule allow 1.2.3.4 because the addresses are the same. And IP 128.127.8.125 matches rule deny 128.127.4.100/20 because 10000000011111110000010001100100 (128.127.4.100 as binary number) shares the first 20 (mask) digits with 10000000011111110000100001111101 (128.127.8.125 as binary number).</p>\n<p>Now comes M access requests. Given their IP addresses, your task is to find out which ones are allowed and which ones are denied.</p>\n<p><strong>Input</strong></p>\n<ul>\n<li>Line 1: two integers N and M.</li>\n<li>Line 2-N+1: one rule on each line.</li>\n<li>Line N+2-N+M+1: one IP address on each line.</li>\n<li>All addresses are IPv4 addresses(0.0.0.0 - 255.255.255.255). 0 &lt;= mask &lt;= 32.</li>\n<li>For 40% of the data: 1 &lt;= N, M &lt;= 1000.</li>\n<li>For 100% of the data: 1 &lt;= N, M &lt;= 100000.</li>\n</ul>\n<p><strong>Output</strong></p>\n<p>For each request output YES or NO according to whether it is allowed.</p>","more":"<p><strong> Sample Input</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">5 5</div><div class=\"line\">allow 1.2.3.4/30</div><div class=\"line\">deny 1.1.1.1</div><div class=\"line\">allow 127.0.0.1</div><div class=\"line\">allow 123.234.12.23/3</div><div class=\"line\">deny 0.0.0.0/0</div><div class=\"line\">1.2.3.4</div><div class=\"line\">1.2.3.5</div><div class=\"line\">1.1.1.1</div><div class=\"line\">100.100.100.100</div><div class=\"line\">219.142.53.100</div></pre></td></tr></table></figure></p>\n<p><strong>Sample Output</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">YES</div><div class=\"line\">YES</div><div class=\"line\">NO</div><div class=\"line\">YES</div><div class=\"line\">NO</div></pre></td></tr></table></figure></p>\n</blockquote>\n<!--more-->\n<p>It is one of the Microsoft 2016 Campus Hiring Contest - April. It is fun and it is such a problem to test our basic programming skills.</p>\n<p>I just find that Java may be a better language to solve this problem. So I use Java to deal with this problem.</p>\n<p>Its complex and easy to get 40% data.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">import java.util.Scanner;</div><div class=\"line\">import java.util.Vector;</div><div class=\"line\"></div><div class=\"line\">public class P1289 &#123;</div><div class=\"line\"></div><div class=\"line\">    static class Rule &#123;</div><div class=\"line\">        public String  address;</div><div class=\"line\">        public boolean isAllowed;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public boolean equals(Object o) &#123;</div><div class=\"line\">            if (this == o) return true;</div><div class=\"line\">            if (o == null || getClass() != o.getClass()) return false;</div><div class=\"line\"></div><div class=\"line\">            Rule address1 = (Rule) o;</div><div class=\"line\"></div><div class=\"line\">            if (isAllowed != address1.isAllowed) return false;</div><div class=\"line\">            return address != null ? address.equals(address1.address) : address1.address == null;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        @Override</div><div class=\"line\">        public int hashCode() &#123;</div><div class=\"line\">            int result = address != null ? address.hashCode() : 0;</div><div class=\"line\">            result = 31 * result + (isAllowed ? 1 : 0);</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static String append8bit(String binary) &#123;</div><div class=\"line\">        switch (binary.length()) &#123;</div><div class=\"line\">            case 0:</div><div class=\"line\">                return &quot;00000000&quot;;</div><div class=\"line\">            case 1:</div><div class=\"line\">                return &quot;0000000&quot; + binary;</div><div class=\"line\">            case 2:</div><div class=\"line\">                return &quot;000000&quot; + binary;</div><div class=\"line\">            case 3:</div><div class=\"line\">                return &quot;00000&quot; + binary;</div><div class=\"line\">            case 4:</div><div class=\"line\">                return &quot;0000&quot; + binary;</div><div class=\"line\">            case 5:</div><div class=\"line\">                return &quot;000&quot; + binary;</div><div class=\"line\">            case 6:</div><div class=\"line\">                return &quot;00&quot; + binary;</div><div class=\"line\">            case 7:</div><div class=\"line\">                return &quot;0&quot; + binary;</div><div class=\"line\">            default:</div><div class=\"line\">                return binary;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static String ip2str(String ip) &#123;</div><div class=\"line\">        StringBuilder stringBuilder = new StringBuilder(32);</div><div class=\"line\">        String res = null;</div><div class=\"line\">        String[] parts = ip.split(&quot;\\\\.&quot;);</div><div class=\"line\"></div><div class=\"line\">        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[0]))));</div><div class=\"line\">        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[1]))));</div><div class=\"line\">        stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[2]))));</div><div class=\"line\">        if (parts[3].contains(&quot;/&quot;)) &#123;</div><div class=\"line\">            String[] ip_mask = parts[3].split(&quot;/&quot;);</div><div class=\"line\">            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(ip_mask[0]))));</div><div class=\"line\">            res = stringBuilder.substring(0, Integer.valueOf(ip_mask[1]));</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            stringBuilder.append(append8bit(Integer.toBinaryString(Integer.valueOf(parts[3]))));</div><div class=\"line\">            res = stringBuilder.toString();</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static boolean check(String address, Vector&lt;Rule&gt; rules) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; rules.size(); i++) &#123;</div><div class=\"line\">            if (address.startsWith(rules.get(i).address)) &#123;</div><div class=\"line\">                return rules.get(i).isAllowed;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        Scanner scanner = new Scanner(System.in);</div><div class=\"line\"></div><div class=\"line\">        int M, N;</div><div class=\"line\">        while (scanner.hasNext()) &#123;</div><div class=\"line\">            N = scanner.nextInt();</div><div class=\"line\">            M = scanner.nextInt();</div><div class=\"line\">            scanner.nextLine();</div><div class=\"line\">            Vector&lt;Rule&gt; rules = new Vector&lt;Rule&gt;(N);</div><div class=\"line\">            for (int i = 0; i &lt; N; i++) &#123;</div><div class=\"line\">                String ruleStr = scanner.nextLine();</div><div class=\"line\">                Rule rule = new Rule();</div><div class=\"line\">                if (ruleStr.startsWith(&quot;a&quot;)) &#123;</div><div class=\"line\">                    ruleStr = ruleStr.substring(6);</div><div class=\"line\">                    rule.isAllowed = true;</div><div class=\"line\">                    rule.address = ip2str(ruleStr);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    ruleStr = ruleStr.substring(5);</div><div class=\"line\">                    rule.isAllowed = false;</div><div class=\"line\">                    rule.address = ip2str(ruleStr);</div><div class=\"line\">                &#125;</div><div class=\"line\">                rules.add(rule);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; M; i++) &#123;</div><div class=\"line\">                String IP = ip2str(scanner.nextLine());</div><div class=\"line\">                if (check(IP, rules)) &#123;</div><div class=\"line\">                    System.out.println(&quot;YES&quot;);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    System.out.println(&quot;NO&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>It passed 40% data. And I think if I want to pass the total data, I should do something better, like combining the rules.</p>\n<p>I will check the better solution later.</p>"},{"title":"Base 7","date":"2017-02-11T05:33:27.000Z","_content":"\n> Given an integer, return its base 7 string representation.\n>\n> Example 1:\n>\n> + Input: 100\n> + Output: \"202\"\n>\n> Example 2:\n>\n> + Input: -7\n> + Output: \"-10\"\n>\n> Note: The input will be in range of [-1e7, 1e7].\n\n<!--more-->\n\nEasy one. My solution is:\n\n```\nclass Solution {\n    public:\n        string convertTo7(int num) {\n            string res = \"\";\n            if (num == 0) {\n                res += '0';\n            }\n\n            int flag = 0;\n            if (num < 0) {\n                num = -num;\n                flag = 1;\n            }\n            while (num != 0) {\n                res = (char)('0' + (num % 7)) + res;\n                num = num / 7;\n            }\n\n            if (flag) {\n                res = '-' + res;\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/Base7.md","raw":"---\ntitle: Base 7\ndate: 2017-02-11 13:33:27\ntags:\n    - Math\n---\n\n> Given an integer, return its base 7 string representation.\n>\n> Example 1:\n>\n> + Input: 100\n> + Output: \"202\"\n>\n> Example 2:\n>\n> + Input: -7\n> + Output: \"-10\"\n>\n> Note: The input will be in range of [-1e7, 1e7].\n\n<!--more-->\n\nEasy one. My solution is:\n\n```\nclass Solution {\n    public:\n        string convertTo7(int num) {\n            string res = \"\";\n            if (num == 0) {\n                res += '0';\n            }\n\n            int flag = 0;\n            if (num < 0) {\n                num = -num;\n                flag = 1;\n            }\n            while (num != 0) {\n                res = (char)('0' + (num % 7)) + res;\n                num = num / 7;\n            }\n\n            if (flag) {\n                res = '-' + res;\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"Base7","published":1,"updated":"2017-02-12T05:34:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatuc0006g5f4ypdcfx8c","content":"<blockquote>\n<p>Given an integer, return its base 7 string representation.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 100</li>\n<li>Output: 202</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: -7</li>\n<li>Output: -10</li>\n</ul>\n<p>Note: The input will be in range of [-1e7, 1e7].</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>Easy one. My solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string convertTo7(int num) &#123;</div><div class=\"line\">            string res = &quot;&quot;;</div><div class=\"line\">            if (num == 0) &#123;</div><div class=\"line\">                res += &apos;0&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int flag = 0;</div><div class=\"line\">            if (num &lt; 0) &#123;</div><div class=\"line\">                num = -num;</div><div class=\"line\">                flag = 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            while (num != 0) &#123;</div><div class=\"line\">                res = (char)(&apos;0&apos; + (num % 7)) + res;</div><div class=\"line\">                num = num / 7;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (flag) &#123;</div><div class=\"line\">                res = &apos;-&apos; + res;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an integer, return its base 7 string representation.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 100</li>\n<li>Output: 202</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: -7</li>\n<li>Output: -10</li>\n</ul>\n<p>Note: The input will be in range of [-1e7, 1e7].</p>\n</blockquote>","more":"<p>Easy one. My solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string convertTo7(int num) &#123;</div><div class=\"line\">            string res = &quot;&quot;;</div><div class=\"line\">            if (num == 0) &#123;</div><div class=\"line\">                res += &apos;0&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int flag = 0;</div><div class=\"line\">            if (num &lt; 0) &#123;</div><div class=\"line\">                num = -num;</div><div class=\"line\">                flag = 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            while (num != 0) &#123;</div><div class=\"line\">                res = (char)(&apos;0&apos; + (num % 7)) + res;</div><div class=\"line\">                num = num / 7;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (flag) &#123;</div><div class=\"line\">                res = &apos;-&apos; + res;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Battleships in a Board","date":"2017-01-05T05:46:25.000Z","_content":"\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","source":"_posts/BattleshipsinaBoard.md","raw":"---\ntitle: Battleships in a Board\ndate: 2017-01-05 13:46:25\ntags:\n    - Simulation\n---\n\n> Given an 2D board, count how many different battleships are in it. The battleships are represented with 'X's, empty slots are represented with '.'s. You may assume the following rules:\n>\n>  + You receive a valid board, made of only battleships or empty slots.\n>  + Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.\n>  + At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.\n>\n> Example:\n>\n> X..X\n> ...X\n> ...X\n>\n> In the above board there are 2 battleships.\n>\n> Invalid Example:\n>\n> ...X\n> XXXX\n> ...X\n>\n> This is an invalid board that you will not receive - as battleships will always have a cell separating between them.\n>\n> Follow up:\n> Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?\n\n<!-- more -->\n\nThis is Leetcode 419, and it's easy enough to figure out with simulation way as following:\n\n1. find the first X char, from up to down and left to right.\n2. if found, then search up and right, to check whether it is ok.\n3. use a global flag to mark if it's good for the result.\n\nThis method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.\n\nFor example, if we use a visited array to mark the visited cells. the solution will be like these:\n\n```\nbool checkShip(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (visited[idx][idy]) {\n        return false;\n    }\n\n    bool res = true;\n    // check the direction, down\n    int currentIdx = idx, currentIdy = idy;\n    while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n        if (board[currentIdx][currentIdy] == 'X') {\n            if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                res = false;\n                break;\n            }\n            if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                res = false;\n                break;\n            }\n        } else {\n            res = true;\n            break;\n        }\n        currentIdx++;\n    }\n    // check the direction, right\n    currentIdx = idx, currentIdy = idy;\n    if (!res) {\n        res = true;\n        while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n            if (board[currentIdx][currentIdy] == 'X') {\n                if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n                if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                    res = false;\n                    break;\n                }\n            } else {\n                res = true;\n                break;\n            }\n            currentIdy++;\n        }\n    }\n    _visit(board, visited, idx, idy);\n    return res;\n}\n\nvoid _visit(vector<vector<char> > &board, int **visited, int idx, int idy) {\n    if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n        return;\n    }\n    if (visited[idx][idy]) {\n        return;\n    }\n    if (board[idx][idy] == '.') {\n        return;\n    }\n    visited[idx][idy] = 1;\n    _visit(board, visited, idx + 1, idy);\n    _visit(board, visited, idx, idy + 1);\n    _visit(board, visited, idx - 1, idy);\n    _visit(board, visited, idx, idy - 1);\n}\n\nint countBattleships(vector<vector<char> >& board) {\n    int* visited[board.size()];\n    for (int i = 0; i < (int)board.size(); i++) {\n        visited[i] = new int[board[0].size()];\n        memset(visited[i], 0, sizeof(int) * board[0].size());\n    }\n    int res = 0;\n    for (int idx = 0; idx < (int)board.size(); idx++) {\n        for (int idy = 0; idy < (int)board[0].size(); idy++) {\n            if (board[idx][idy] == 'X' && checkShip(board, visited, idx, idy)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n```\n\nBut, if we can give up the visited array, just make sure the current cell's left or up have X char to mark it has been visited. It will make sense.\n\nSo, we should add these method to replace the former visited array:\n\n```\nbool isVisited(vector<vector<char> > &board, int idx, int idy) {\n    if (idx == 0 && idy == 0) {\n        return false;\n    } else if (idx == 0) {\n        return board[idx][idy - 1] == 'X';\n    } else if (idy == 0) {\n        return board[idx - 1][idy] == 'X';\n    } else {\n        return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n    }\n}\n```\nSo, the last AC code will like these:\n\n```\nclass Solution {\n    public:\n        bool isVisited(vector<vector<char> > &board, int idx, int idy) {\n            if (idx == 0 && idy == 0) {\n                return false;\n            } else if (idx == 0) {\n                return board[idx][idy - 1] == 'X';\n            } else if (idy == 0) {\n                return board[idx - 1][idy] == 'X';\n            } else {\n                return board[idx - 1][idy] == 'X' || board[idx][idy - 1] == 'X';\n            }\n        }\n\n        bool checkShip(vector<vector<char> > &board, int idx, int idy) {\n            if (isVisited(board, idx, idy)) {\n                return false;\n            }\n\n            bool res = true;\n            // check the direction, down\n            int currentIdx = idx, currentIdy = idy;\n            while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                if (board[currentIdx][currentIdy] == 'X') {\n                    if (currentIdy + 1 < (int)board[0].size() && board[currentIdx][currentIdy + 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                    if (currentIdy - 1 >= 0 && board[currentIdx][currentIdy - 1] == 'X') {\n                        res = false;\n                        break;\n                    }\n                } else {\n                    res = true;\n                    break;\n                }\n                currentIdx++;\n            }\n            // check the direction, right\n            currentIdx = idx, currentIdy = idy;\n            if (!res) {\n                res = true;\n                while (currentIdx < (int)board.size() && currentIdy < (int)board[0].size()) {\n                    if (board[currentIdx][currentIdy] == 'X') {\n                        if (currentIdx + 1 < (int)board.size() && board[currentIdx + 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                        if (currentIdx - 1 >= 0 && board[currentIdx - 1][currentIdy] == 'X') {\n                            res = false;\n                            break;\n                        }\n                    } else {\n                        res = true;\n                        break;\n                    }\n                    currentIdy++;\n                }\n            }\n            _visit(board, idx, idy);\n            return res;\n        }\n\n        void _visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idy < 0|| idx >= (int)board.size() || idy >= (int)board[0].size()) {\n                return;\n            }\n            if (isVisited(board, idx, idy)) {\n                return;\n            }\n            if (board[idx][idy] == '.') {\n                return;\n            }\n            // visited[idx][idy] = 1;\n            _visit(board, idx + 1, idy);\n            _visit(board, idx, idy + 1);\n            _visit(board, idx - 1, idy);\n            _visit(board, idx, idy - 1);\n        }\n\n        int countBattleships(vector<vector<char> >& board) {\n            int res = 0;\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'X' && checkShip(board, idx, idy)) {\n                        res++;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n","slug":"BattleshipsinaBoard","published":1,"updated":"2017-01-05T05:46:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatue0009g5f4oxqpjsgf","content":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with Xs, empty slots are represented with .s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>X<br>X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>X<br>XXXX<br>X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 419, and its easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if its good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cells left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an 2D board, count how many different battleships are in it. The battleships are represented with Xs, empty slots are represented with .s. You may assume the following rules:</p>\n<ul>\n<li>You receive a valid board, made of only battleships or empty slots.</li>\n<li>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.</li>\n<li>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</li>\n</ul>\n<p>Example:</p>\n<p>X..X<br>X<br>X</p>\n<p>In the above board there are 2 battleships.</p>\n<p>Invalid Example:</p>\n<p>X<br>XXXX<br>X</p>\n<p>This is an invalid board that you will not receive - as battleships will always have a cell separating between them.</p>\n<p>Follow up:<br>Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board?</p>\n</blockquote>","more":"<p>This is Leetcode 419, and its easy enough to figure out with simulation way as following:</p>\n<ol>\n<li>find the first X char, from up to down and left to right.</li>\n<li>if found, then search up and right, to check whether it is ok.</li>\n<li>use a global flag to mark if its good for the result.</li>\n</ol>\n<p>This method will use O(n*n) array to mark the visited position, if not it will modify the value of the board to make sure no cell will visit twice.</p>\n<p>For example, if we use a visited array to mark the visited cells. the solution will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool res = true;</div><div class=\"line\">    // check the direction, down</div><div class=\"line\">    int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">        if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">            if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            res = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentIdx++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // check the direction, right</div><div class=\"line\">    currentIdx = idx, currentIdy = idy;</div><div class=\"line\">    if (!res) &#123;</div><div class=\"line\">        res = true;</div><div class=\"line\">        while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">            if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    res = false;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentIdy++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    _visit(board, visited, idx, idy);</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int **visited, int idx, int idy) &#123;</div><div class=\"line\">    if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (visited[idx][idy]) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    visited[idx][idy] = 1;</div><div class=\"line\">    _visit(board, visited, idx + 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy + 1);</div><div class=\"line\">    _visit(board, visited, idx - 1, idy);</div><div class=\"line\">    _visit(board, visited, idx, idy - 1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">    int* visited[board.size()];</div><div class=\"line\">    for (int i = 0; i &lt; (int)board.size(); i++) &#123;</div><div class=\"line\">        visited[i] = new int[board[0].size()];</div><div class=\"line\">        memset(visited[i], 0, sizeof(int) * board[0].size());</div><div class=\"line\">    &#125;</div><div class=\"line\">    int res = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">        for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">            if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, visited, idx, idy)) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But, if we can give up the visited array, just make sure the current cells left or up have X char to mark it has been visited. It will make sense.</p>\n<p>So, we should add these method to replace the former visited array:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">    if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125; else if (idx == 0) &#123;</div><div class=\"line\">        return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125; else if (idy == 0) &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>So, the last AC code will like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isVisited(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx == 0 &amp;&amp; idy == 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else if (idx == 0) &#123;</div><div class=\"line\">                return board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125; else if (idy == 0) &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos;;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return board[idx - 1][idy] == &apos;X&apos; || board[idx][idy - 1] == &apos;X&apos;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkShip(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res = true;</div><div class=\"line\">            // check the direction, down</div><div class=\"line\">            int currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                    if (currentIdy + 1 &lt; (int)board[0].size() &amp;&amp; board[currentIdx][currentIdy + 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (currentIdy - 1 &gt;= 0 &amp;&amp; board[currentIdx][currentIdy - 1] == &apos;X&apos;) &#123;</div><div class=\"line\">                        res = false;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = true;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // check the direction, right</div><div class=\"line\">            currentIdx = idx, currentIdy = idy;</div><div class=\"line\">            if (!res) &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\">                while (currentIdx &lt; (int)board.size() &amp;&amp; currentIdy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[currentIdx][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                        if (currentIdx + 1 &lt; (int)board.size() &amp;&amp; board[currentIdx + 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentIdx - 1 &gt;= 0 &amp;&amp; board[currentIdx - 1][currentIdy] == &apos;X&apos;) &#123;</div><div class=\"line\">                            res = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    currentIdy++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(board, idx, idy);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idy &lt; 0|| idx &gt;= (int)board.size() || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (isVisited(board, idx, idy)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (board[idx][idy] == &apos;.&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // visited[idx][idy] = 1;</div><div class=\"line\">            _visit(board, idx + 1, idy);</div><div class=\"line\">            _visit(board, idx, idy + 1);</div><div class=\"line\">            _visit(board, idx - 1, idy);</div><div class=\"line\">            _visit(board, idx, idy - 1);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int countBattleships(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;X&apos; &amp;&amp; checkShip(board, idx, idy)) &#123;</div><div class=\"line\">                        res++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Beautiful Arrangement","date":"2017-02-24T07:47:20.000Z","_content":"\n\n> Suppose you have N integers from 1 to N.\n>\n> We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1  i  N) in this array:\n>\n> + The number at the ith position is divisible by i.\n> + i is divisible by the number at the ith position.\n>\n> Now given N, how many beautiful arrangements can you construct?\n>\n> Example 1:\n> + Input: 2\n> + Output: 2\n>\n> Explanation:\n>\n> + The first beautiful arrangement is [1, 2]:\n> + Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\n> + Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\n> + The second beautiful arrangement is [2, 1]:\n> + Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\n> + Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\n>\n> Note:\n> + N is a positive integer and will not exceed 15.\n\n<!--more-->\n\nThis is Leetcode No.526, First I will share my normal solution. As the tag says 'Backtracking', so I use the similiar method as show all the permutation of a array. Just add some condition before go further.\n\n```\nclass Solution {\n    public:\n        int res;\n        int countArrangement(int N) {\n            res = 0;\n            vector<int> nums(N + 1);\n            _generate(nums, 1);\n            return res;\n        }\n\n        void _generate(vector<int> nums, int currentLength) {\n            if (currentLength == (int)nums.size()) {\n                res++;\n            } else {\n                for (int i = 1; i < (int)nums.size(); i++) {\n                    if (nums[i] == 0 && (i % currentLength == 0 || currentLength % i == 0)) {\n                        nums[i] = 1;\n                        _generate(nums, currentLength + 1);\n                        nums[i] = 0;\n                    }\n                }\n            }\n        }\n};\n```\n\nIt gets AC. But there is a much fucker solution. Just show the result of all the 15 result. LOL.\n","source":"_posts/BeautifulArrangement.md","raw":"---\ntitle: Beautiful Arrangement\ndate: 2017-02-24 15:47:20\ntags:\n    - Backtracking\n---\n\n\n> Suppose you have N integers from 1 to N.\n>\n> We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1  i  N) in this array:\n>\n> + The number at the ith position is divisible by i.\n> + i is divisible by the number at the ith position.\n>\n> Now given N, how many beautiful arrangements can you construct?\n>\n> Example 1:\n> + Input: 2\n> + Output: 2\n>\n> Explanation:\n>\n> + The first beautiful arrangement is [1, 2]:\n> + Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).\n> + Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).\n> + The second beautiful arrangement is [2, 1]:\n> + Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).\n> + Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.\n>\n> Note:\n> + N is a positive integer and will not exceed 15.\n\n<!--more-->\n\nThis is Leetcode No.526, First I will share my normal solution. As the tag says 'Backtracking', so I use the similiar method as show all the permutation of a array. Just add some condition before go further.\n\n```\nclass Solution {\n    public:\n        int res;\n        int countArrangement(int N) {\n            res = 0;\n            vector<int> nums(N + 1);\n            _generate(nums, 1);\n            return res;\n        }\n\n        void _generate(vector<int> nums, int currentLength) {\n            if (currentLength == (int)nums.size()) {\n                res++;\n            } else {\n                for (int i = 1; i < (int)nums.size(); i++) {\n                    if (nums[i] == 0 && (i % currentLength == 0 || currentLength % i == 0)) {\n                        nums[i] = 1;\n                        _generate(nums, currentLength + 1);\n                        nums[i] = 0;\n                    }\n                }\n            }\n        }\n};\n```\n\nIt gets AC. But there is a much fucker solution. Just show the result of all the 15 result. LOL.\n","slug":"BeautifulArrangement","published":1,"updated":"2017-02-24T09:23:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatui000ag5f4vega6uko","content":"<blockquote>\n<p>Suppose you have N integers from 1 to N.</p>\n<p>We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1  i  N) in this array:</p>\n<ul>\n<li>The number at the ith position is divisible by i.</li>\n<li>i is divisible by the number at the ith position.</li>\n</ul>\n<p>Now given N, how many beautiful arrangements can you construct?</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 2</li>\n<li>Output: 2</li>\n</ul>\n<p>Explanation:</p>\n<ul>\n<li>The first beautiful arrangement is [1, 2]:</li>\n<li>Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).</li>\n<li>Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).</li>\n<li>The second beautiful arrangement is [2, 1]:</li>\n<li>Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).</li>\n<li>Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>N is a positive integer and will not exceed 15.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.526, First I will share my normal solution. As the tag says Backtracking, so I use the similiar method as show all the permutation of a array. Just add some condition before go further.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int countArrangement(int N) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            vector&lt;int&gt; nums(N + 1);</div><div class=\"line\">            _generate(nums, 1);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _generate(vector&lt;int&gt; nums, int currentLength) &#123;</div><div class=\"line\">            if (currentLength == (int)nums.size()) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                for (int i = 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                    if (nums[i] == 0 &amp;&amp; (i % currentLength == 0 || currentLength % i == 0)) &#123;</div><div class=\"line\">                        nums[i] = 1;</div><div class=\"line\">                        _generate(nums, currentLength + 1);</div><div class=\"line\">                        nums[i] = 0;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. But there is a much fucker solution. Just show the result of all the 15 result. LOL.</p>\n","excerpt":"<blockquote>\n<p>Suppose you have N integers from 1 to N.</p>\n<p>We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1  i  N) in this array:</p>\n<ul>\n<li>The number at the ith position is divisible by i.</li>\n<li>i is divisible by the number at the ith position.</li>\n</ul>\n<p>Now given N, how many beautiful arrangements can you construct?</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 2</li>\n<li>Output: 2</li>\n</ul>\n<p>Explanation:</p>\n<ul>\n<li>The first beautiful arrangement is [1, 2]:</li>\n<li>Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).</li>\n<li>Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).</li>\n<li>The second beautiful arrangement is [2, 1]:</li>\n<li>Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).</li>\n<li>Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>N is a positive integer and will not exceed 15.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.526, First I will share my normal solution. As the tag says Backtracking, so I use the similiar method as show all the permutation of a array. Just add some condition before go further.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int countArrangement(int N) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            vector&lt;int&gt; nums(N + 1);</div><div class=\"line\">            _generate(nums, 1);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _generate(vector&lt;int&gt; nums, int currentLength) &#123;</div><div class=\"line\">            if (currentLength == (int)nums.size()) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                for (int i = 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                    if (nums[i] == 0 &amp;&amp; (i % currentLength == 0 || currentLength % i == 0)) &#123;</div><div class=\"line\">                        nums[i] = 1;</div><div class=\"line\">                        _generate(nums, currentLength + 1);</div><div class=\"line\">                        nums[i] = 0;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. But there is a much fucker solution. Just show the result of all the 15 result. LOL.</p>"},{"title":"Coin Change","date":"2017-01-14T05:54:51.000Z","_content":"\n> You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n>\n> Example 1:\n> coins = [1, 2, 5], amount = 11\n> return 3 (11 = 5 + 5 + 1)\n>\n> Example 2:\n> coins = [2], amount = 3\n> return -1.\n>\n> Note: You may assume that you have an infinite number of each kind of coin.\n\n<!--more-->\n\nThis is Leetcode 322, and it's quite a DP problem, so I first find this solution:\n1. use a DP array to store all the result from 0 to amount\n2. foreach add the coins to match the amount. for instance, we can find such an example:\n```\n  --- 2\n1 --- 3\n  --- 6\n  --- 3\n2 --- 4\n  --- 7\n    ...\n```\n3. So, after all this match we can finally find the result.\n\nSo, I write such solution code:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n\n            vector<long> DP(amount + 1, INT_MAX);\n            map<long, set<long> > coinMap;\n            long level = 1;\n            set<long> zeroN;\n            zeroN.insert(0);\n            coinMap.insert(pair<long, set<long> >(0, zeroN));\n            DP[0] = 0;\n\n            while (DP[amount] == INT_MAX) {\n                coinMap.insert(pair<long, set<long> >(level, set<long>()));\n                for (int preCoin : coinMap[level - 1]) {\n                    for (int coin : coins) {\n                        if (preCoin + (long)coin <= (long)amount) {\n                            coinMap[level].insert(preCoin + coin);\n                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                if (coinMap[level].size() == 0) {\n                    return -1;\n                }\n                level++;\n            }\n            return DP[amount];\n        }\n};\n```\n\nBut, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            long start = 0;\n            long end = 0;\n\n            DP[0] = 0;\n\n            while (start <= amount) {\n                for (int pre = start; pre <= end; pre++) {\n                    for (int coin : coins) {\n                        if ((long)coin + (long)pre <= (long)amount) {\n                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                start = coins[0] + start;\n                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);\n            }\n\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nHowever it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            DP[0] = 0;\n            for (int pre = 1; pre <= amount; pre++) {\n                for (int current : coins) {\n                    if (pre >= current) {\n                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nThis solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.\n","source":"_posts/CoinChange.md","raw":"---\ntitle: Coin Change\ndate: 2017-01-14 13:54:51\ntags:\n    - Dynamic Programming\n---\n\n> You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n>\n> Example 1:\n> coins = [1, 2, 5], amount = 11\n> return 3 (11 = 5 + 5 + 1)\n>\n> Example 2:\n> coins = [2], amount = 3\n> return -1.\n>\n> Note: You may assume that you have an infinite number of each kind of coin.\n\n<!--more-->\n\nThis is Leetcode 322, and it's quite a DP problem, so I first find this solution:\n1. use a DP array to store all the result from 0 to amount\n2. foreach add the coins to match the amount. for instance, we can find such an example:\n```\n  --- 2\n1 --- 3\n  --- 6\n  --- 3\n2 --- 4\n  --- 7\n    ...\n```\n3. So, after all this match we can finally find the result.\n\nSo, I write such solution code:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n\n            vector<long> DP(amount + 1, INT_MAX);\n            map<long, set<long> > coinMap;\n            long level = 1;\n            set<long> zeroN;\n            zeroN.insert(0);\n            coinMap.insert(pair<long, set<long> >(0, zeroN));\n            DP[0] = 0;\n\n            while (DP[amount] == INT_MAX) {\n                coinMap.insert(pair<long, set<long> >(level, set<long>()));\n                for (int preCoin : coinMap[level - 1]) {\n                    for (int coin : coins) {\n                        if (preCoin + (long)coin <= (long)amount) {\n                            coinMap[level].insert(preCoin + coin);\n                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                if (coinMap[level].size() == 0) {\n                    return -1;\n                }\n                level++;\n            }\n            return DP[amount];\n        }\n};\n```\n\nBut, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            long start = 0;\n            long end = 0;\n\n            DP[0] = 0;\n\n            while (start <= amount) {\n                for (int pre = start; pre <= end; pre++) {\n                    for (int coin : coins) {\n                        if ((long)coin + (long)pre <= (long)amount) {\n                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                start = coins[0] + start;\n                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);\n            }\n\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nHowever it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:\n\n```\nclass Solution {\n    public:\n        int coinChange(vector<int>& coins, int amount) {\n            vector<long> DP(amount + 1, INT_MAX);\n\n            sort(coins.begin(), coins.end());\n            if (amount == 0) {\n                return 0;\n            }\n            if (coins[0] > amount) {\n                return -1;\n            }\n\n            DP[0] = 0;\n            for (int pre = 1; pre <= amount; pre++) {\n                for (int current : coins) {\n                    if (pre >= current) {\n                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);\n                    } else {\n                        break;\n                    }\n                }\n            }\n            return DP[amount] == INT_MAX ? -1 : DP[amount];\n        }\n};\n```\n\nThis solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.\n","slug":"CoinChange","published":1,"updated":"2017-01-14T12:09:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatuj000cg5f4fbr1gn6o","content":"<blockquote>\n<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>\n<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>\n<p>Note: You may assume that you have an infinite number of each kind of coin.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 322, and its quite a DP problem, so I first find this solution:</p>\n<ol>\n<li>use a DP array to store all the result from 0 to amount</li>\n<li><p>foreach add the coins to match the amount. for instance, we can find such an example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">  --- 2</div><div class=\"line\">1 --- 3</div><div class=\"line\">  --- 6</div><div class=\"line\">  --- 3</div><div class=\"line\">2 --- 4</div><div class=\"line\">  --- 7</div><div class=\"line\">    ...</div></pre></td></tr></table></figure>\n</li>\n<li><p>So, after all this match we can finally find the result.</p>\n</li>\n</ol>\n<p>So, I write such solution code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\">            map&lt;long, set&lt;long&gt; &gt; coinMap;</div><div class=\"line\">            long level = 1;</div><div class=\"line\">            set&lt;long&gt; zeroN;</div><div class=\"line\">            zeroN.insert(0);</div><div class=\"line\">            coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(0, zeroN));</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (DP[amount] == INT_MAX) &#123;</div><div class=\"line\">                coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(level, set&lt;long&gt;()));</div><div class=\"line\">                for (int preCoin : coinMap[level - 1]) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if (preCoin + (long)coin &lt;= (long)amount) &#123;</div><div class=\"line\">                            coinMap[level].insert(preCoin + coin);</div><div class=\"line\">                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (coinMap[level].size() == 0) &#123;</div><div class=\"line\">                    return -1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long start = 0;</div><div class=\"line\">            long end = 0;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (start &lt;= amount) &#123;</div><div class=\"line\">                for (int pre = start; pre &lt;= end; pre++) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if ((long)coin + (long)pre &lt;= (long)amount) &#123;</div><div class=\"line\">                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                start = coins[0] + start;</div><div class=\"line\">                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>However it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int pre = 1; pre &lt;= amount; pre++) &#123;</div><div class=\"line\">                for (int current : coins) &#123;</div><div class=\"line\">                    if (pre &gt;= current) &#123;</div><div class=\"line\">                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.</p>\n","excerpt":"<blockquote>\n<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<p>Example 1:<br>coins = [1, 2, 5], amount = 11<br>return 3 (11 = 5 + 5 + 1)</p>\n<p>Example 2:<br>coins = [2], amount = 3<br>return -1.</p>\n<p>Note: You may assume that you have an infinite number of each kind of coin.</p>\n</blockquote>","more":"<p>This is Leetcode 322, and its quite a DP problem, so I first find this solution:</p>\n<ol>\n<li>use a DP array to store all the result from 0 to amount</li>\n<li><p>foreach add the coins to match the amount. for instance, we can find such an example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">  --- 2</div><div class=\"line\">1 --- 3</div><div class=\"line\">  --- 6</div><div class=\"line\">  --- 3</div><div class=\"line\">2 --- 4</div><div class=\"line\">  --- 7</div><div class=\"line\">    ...</div></pre></td></tr></table></figure>\n</li>\n<li><p>So, after all this match we can finally find the result.</p>\n</li>\n</ol>\n<p>So, I write such solution code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\">            map&lt;long, set&lt;long&gt; &gt; coinMap;</div><div class=\"line\">            long level = 1;</div><div class=\"line\">            set&lt;long&gt; zeroN;</div><div class=\"line\">            zeroN.insert(0);</div><div class=\"line\">            coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(0, zeroN));</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (DP[amount] == INT_MAX) &#123;</div><div class=\"line\">                coinMap.insert(pair&lt;long, set&lt;long&gt; &gt;(level, set&lt;long&gt;()));</div><div class=\"line\">                for (int preCoin : coinMap[level - 1]) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if (preCoin + (long)coin &lt;= (long)amount) &#123;</div><div class=\"line\">                            coinMap[level].insert(preCoin + coin);</div><div class=\"line\">                            DP[preCoin + coin] = min(DP[preCoin] + 1, DP[coin + preCoin]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (coinMap[level].size() == 0) &#123;</div><div class=\"line\">                    return -1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, it gets TLE. So I want to find where I am wrong. I think I use too much unnecessary maps. So I simplfy my code:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long start = 0;</div><div class=\"line\">            long end = 0;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\"></div><div class=\"line\">            while (start &lt;= amount) &#123;</div><div class=\"line\">                for (int pre = start; pre &lt;= end; pre++) &#123;</div><div class=\"line\">                    for (int coin : coins) &#123;</div><div class=\"line\">                        if ((long)coin + (long)pre &lt;= (long)amount) &#123;</div><div class=\"line\">                            DP[coin + pre] = min(DP[pre] + 1, DP[coin + pre]);</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                start = coins[0] + start;</div><div class=\"line\">                end = min((long)coins[coins.size() - 1] + (long)end, (long)amount);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>However it still gets a TLE. Then I realize, how about just change the form of code, use the DP array as the standard:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(amount + 1, INT_MAX);</div><div class=\"line\"></div><div class=\"line\">            sort(coins.begin(), coins.end());</div><div class=\"line\">            if (amount == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (coins[0] &gt; amount) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int pre = 1; pre &lt;= amount; pre++) &#123;</div><div class=\"line\">                for (int current : coins) &#123;</div><div class=\"line\">                    if (pre &gt;= current) &#123;</div><div class=\"line\">                        DP[pre] = min(DP[pre - current] + 1, DP[pre]);</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[amount] == INT_MAX ? -1 : DP[amount];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This solution is as much as the above but its form changed, and its time complex is O(NM), and it gets AC.</p>"},{"title":"Can I Win","date":"2017-03-13T08:28:42.000Z","_content":"\n\n> In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.\n>\n> What if we change the game so that players cannot re-use integers?\n>\n> For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.\n>\n> Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.\n>\n> You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\n>\n> Example:\n> ```\nInput:\n    maxChoosableInteger = 10\n    desiredTotal = 11\n\nOutput:\n    false\n\nExplanation:\n    No matter which integer the first player choose, the first player will lose.\n    The first player can choose an integer from 1 up to 10.\n    If the first player choose 1, the second player can only choose integers from 2 up to 10.\n    The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n    Same with other integers chosen by the first player, the second player will always win.\n```\n\n<!--more-->\n\nThis is Leetcode No.464. At the beginning, I just want to show its all possible combination. The code is like following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool canIWin(int maxChoosableInteger, int desiredTotal) {\n            if (desiredTotal < 1) {\n                return true;\n            }\n            set<int> nums;\n            for (int i = 1; i <= maxChoosableInteger; i++) {\n                nums.insert(i);\n            }\n\n            return _check(nums, false, 0, desiredTotal);\n        }\n\n        bool _check(set<int> &nums, int isFirst, int current, int target) {\n            if (current >= target) {\n                return isFirst;\n            }\n\n            bool res;\n            if (isFirst) {\n                res = false;\n\n                for (auto i : nums) {\n                    set<int> t_nums(nums);\n                    t_nums.erase(i);\n                    res = res || _check(t_nums, !isFirst, current + i, target);\n                }\n            } else {\n                res = true;\n\n                for (auto i : nums) {\n                    set<int> t_nums(nums);\n                    t_nums.erase(i);\n                    res = res && _check(t_nums, !isFirst, current + i, target);\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIt is correct, However, it gets a TLE. So the problem is that the number of branches is too large. One solution is to find a way to reduce the branches.\n\nIn some case, the most time-cost step is the copying of the set. So I try to solve the problem first.\n\n\nThen, use memorized method to reduce the time cost. Then use BITSET instead of SET to reduce the space cost.\n\n```\nusing namespace std;\n\nclass Solution {\n    private:\n        vector<int> *winSet;\n        bool canIWinAux(int numSet, int total) {\n            int maxnum = maxNum(numSet);\n            if (maxnum >= total) return true;\n            if (winSet->at(numSet) != -1) return winSet->at(numSet);\n            for (int num = 1; num <= maxnum; num++) {\n                int mask = 1 << (num-1);\n                //\tskip used number\n                if (!(numSet&mask)) continue;\n                //\tskip if take num as first choice\n                if (canIWinAux((int)(numSet&(~mask)), total - num)) continue;\n                //\totherwise this num is the smart choice\n                winSet->at(numSet) = true;\n                return true;\n            }\n            //\thave tried every number in numSet and fail to win\n            winSet->at(numSet) = false;\n            return false;\n        }\n\n        //\treturn the maximum number avaliable in the numSet\n        int maxNum(int numSet) {\n            int firstBit = 0;\n            while (numSet) {\n                firstBit++;\n                numSet >>= 1;\n            }\n            return firstBit;\n        }\n\n\n    public:\n        bool canIWin(int maxChoosableInteger, int desiredTotal) {\n            if (desiredTotal>maxChoosableInteger*(maxChoosableInteger + 1) / 2) return false;\n            if (desiredTotal <= maxChoosableInteger) return true;\n            if (desiredTotal % (1 + maxChoosableInteger) == 0 && maxChoosableInteger % 2 == 0) return false;\n\n            //\tnumSet: the k-nd bit stands for number k; 1 is usable, 0 is used, -1 is unknown.\n            int numSet = (1 << (maxChoosableInteger))-1;\n            winSet = new vector<int>(1 << maxChoosableInteger, -1);\n            return canIWinAux(numSet, desiredTotal);\n        }\n};\n```\n\nThen it gets AC.\n","source":"_posts/CanIWin.md","raw":"---\ntitle: Can I Win\ndate: 2017-03-13 16:28:42\ntags:\n    - Minimax\n    - Dynamic Programming\n---\n\n\n> In the \"100 game,\" two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.\n>\n> What if we change the game so that players cannot re-use integers?\n>\n> For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total >= 100.\n>\n> Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.\n>\n> You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.\n>\n> Example:\n> ```\nInput:\n    maxChoosableInteger = 10\n    desiredTotal = 11\n\nOutput:\n    false\n\nExplanation:\n    No matter which integer the first player choose, the first player will lose.\n    The first player can choose an integer from 1 up to 10.\n    If the first player choose 1, the second player can only choose integers from 2 up to 10.\n    The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n    Same with other integers chosen by the first player, the second player will always win.\n```\n\n<!--more-->\n\nThis is Leetcode No.464. At the beginning, I just want to show its all possible combination. The code is like following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool canIWin(int maxChoosableInteger, int desiredTotal) {\n            if (desiredTotal < 1) {\n                return true;\n            }\n            set<int> nums;\n            for (int i = 1; i <= maxChoosableInteger; i++) {\n                nums.insert(i);\n            }\n\n            return _check(nums, false, 0, desiredTotal);\n        }\n\n        bool _check(set<int> &nums, int isFirst, int current, int target) {\n            if (current >= target) {\n                return isFirst;\n            }\n\n            bool res;\n            if (isFirst) {\n                res = false;\n\n                for (auto i : nums) {\n                    set<int> t_nums(nums);\n                    t_nums.erase(i);\n                    res = res || _check(t_nums, !isFirst, current + i, target);\n                }\n            } else {\n                res = true;\n\n                for (auto i : nums) {\n                    set<int> t_nums(nums);\n                    t_nums.erase(i);\n                    res = res && _check(t_nums, !isFirst, current + i, target);\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIt is correct, However, it gets a TLE. So the problem is that the number of branches is too large. One solution is to find a way to reduce the branches.\n\nIn some case, the most time-cost step is the copying of the set. So I try to solve the problem first.\n\n\nThen, use memorized method to reduce the time cost. Then use BITSET instead of SET to reduce the space cost.\n\n```\nusing namespace std;\n\nclass Solution {\n    private:\n        vector<int> *winSet;\n        bool canIWinAux(int numSet, int total) {\n            int maxnum = maxNum(numSet);\n            if (maxnum >= total) return true;\n            if (winSet->at(numSet) != -1) return winSet->at(numSet);\n            for (int num = 1; num <= maxnum; num++) {\n                int mask = 1 << (num-1);\n                //\tskip used number\n                if (!(numSet&mask)) continue;\n                //\tskip if take num as first choice\n                if (canIWinAux((int)(numSet&(~mask)), total - num)) continue;\n                //\totherwise this num is the smart choice\n                winSet->at(numSet) = true;\n                return true;\n            }\n            //\thave tried every number in numSet and fail to win\n            winSet->at(numSet) = false;\n            return false;\n        }\n\n        //\treturn the maximum number avaliable in the numSet\n        int maxNum(int numSet) {\n            int firstBit = 0;\n            while (numSet) {\n                firstBit++;\n                numSet >>= 1;\n            }\n            return firstBit;\n        }\n\n\n    public:\n        bool canIWin(int maxChoosableInteger, int desiredTotal) {\n            if (desiredTotal>maxChoosableInteger*(maxChoosableInteger + 1) / 2) return false;\n            if (desiredTotal <= maxChoosableInteger) return true;\n            if (desiredTotal % (1 + maxChoosableInteger) == 0 && maxChoosableInteger % 2 == 0) return false;\n\n            //\tnumSet: the k-nd bit stands for number k; 1 is usable, 0 is used, -1 is unknown.\n            int numSet = (1 << (maxChoosableInteger))-1;\n            winSet = new vector<int>(1 << maxChoosableInteger, -1);\n            return canIWinAux(numSet, desiredTotal);\n        }\n};\n```\n\nThen it gets AC.\n","slug":"CanIWin","published":1,"updated":"2017-03-14T11:08:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatuk000dg5f4qldcq2md","content":"<blockquote>\n<p>In the 100 game, two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>\n<p>What if we change the game so that players cannot re-use integers?</p>\n<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>\n<p>Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.</p>\n<p>You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.</p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">    maxChoosableInteger = 10</div><div class=\"line\">    desiredTotal = 11</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">    false</div><div class=\"line\"></div><div class=\"line\">Explanation:</div><div class=\"line\">    No matter which integer the first player choose, the first player will lose.</div><div class=\"line\">    The first player can choose an integer from 1 up to 10.</div><div class=\"line\">    If the first player choose 1, the second player can only choose integers from 2 up to 10.</div><div class=\"line\">    The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</div><div class=\"line\">    Same with other integers chosen by the first player, the second player will always win.</div></pre></td></tr></table></figure></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.464. At the beginning, I just want to show its all possible combination. The code is like following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canIWin(int maxChoosableInteger, int desiredTotal) &#123;</div><div class=\"line\">            if (desiredTotal &lt; 1) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            set&lt;int&gt; nums;</div><div class=\"line\">            for (int i = 1; i &lt;= maxChoosableInteger; i++) &#123;</div><div class=\"line\">                nums.insert(i);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return _check(nums, false, 0, desiredTotal);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _check(set&lt;int&gt; &amp;nums, int isFirst, int current, int target) &#123;</div><div class=\"line\">            if (current &gt;= target) &#123;</div><div class=\"line\">                return isFirst;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res;</div><div class=\"line\">            if (isFirst) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\"></div><div class=\"line\">                for (auto i : nums) &#123;</div><div class=\"line\">                    set&lt;int&gt; t_nums(nums);</div><div class=\"line\">                    t_nums.erase(i);</div><div class=\"line\">                    res = res || _check(t_nums, !isFirst, current + i, target);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\"></div><div class=\"line\">                for (auto i : nums) &#123;</div><div class=\"line\">                    set&lt;int&gt; t_nums(nums);</div><div class=\"line\">                    t_nums.erase(i);</div><div class=\"line\">                    res = res &amp;&amp; _check(t_nums, !isFirst, current + i, target);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, However, it gets a TLE. So the problem is that the number of branches is too large. One solution is to find a way to reduce the branches.</p>\n<p>In some case, the most time-cost step is the copying of the set. So I try to solve the problem first.</p>\n<p>Then, use memorized method to reduce the time cost. Then use BITSET instead of SET to reduce the space cost.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    private:</div><div class=\"line\">        vector&lt;int&gt; *winSet;</div><div class=\"line\">        bool canIWinAux(int numSet, int total) &#123;</div><div class=\"line\">            int maxnum = maxNum(numSet);</div><div class=\"line\">            if (maxnum &gt;= total) return true;</div><div class=\"line\">            if (winSet-&gt;at(numSet) != -1) return winSet-&gt;at(numSet);</div><div class=\"line\">            for (int num = 1; num &lt;= maxnum; num++) &#123;</div><div class=\"line\">                int mask = 1 &lt;&lt; (num-1);</div><div class=\"line\">                //\tskip used number</div><div class=\"line\">                if (!(numSet&amp;mask)) continue;</div><div class=\"line\">                //\tskip if take num as first choice</div><div class=\"line\">                if (canIWinAux((int)(numSet&amp;(~mask)), total - num)) continue;</div><div class=\"line\">                //\totherwise this num is the smart choice</div><div class=\"line\">                winSet-&gt;at(numSet) = true;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //\thave tried every number in numSet and fail to win</div><div class=\"line\">            winSet-&gt;at(numSet) = false;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //\treturn the maximum number avaliable in the numSet</div><div class=\"line\">        int maxNum(int numSet) &#123;</div><div class=\"line\">            int firstBit = 0;</div><div class=\"line\">            while (numSet) &#123;</div><div class=\"line\">                firstBit++;</div><div class=\"line\">                numSet &gt;&gt;= 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return firstBit;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    public:</div><div class=\"line\">        bool canIWin(int maxChoosableInteger, int desiredTotal) &#123;</div><div class=\"line\">            if (desiredTotal&gt;maxChoosableInteger*(maxChoosableInteger + 1) / 2) return false;</div><div class=\"line\">            if (desiredTotal &lt;= maxChoosableInteger) return true;</div><div class=\"line\">            if (desiredTotal % (1 + maxChoosableInteger) == 0 &amp;&amp; maxChoosableInteger % 2 == 0) return false;</div><div class=\"line\"></div><div class=\"line\">            //\tnumSet: the k-nd bit stands for number k; 1 is usable, 0 is used, -1 is unknown.</div><div class=\"line\">            int numSet = (1 &lt;&lt; (maxChoosableInteger))-1;</div><div class=\"line\">            winSet = new vector&lt;int&gt;(1 &lt;&lt; maxChoosableInteger, -1);</div><div class=\"line\">            return canIWinAux(numSet, desiredTotal);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Then it gets AC.</p>\n","excerpt":"<blockquote>\n<p>In the 100 game, two players take turns adding, to a running total, any integer from 1..10. The player who first causes the running total to reach or exceed 100 wins.</p>\n<p>What if we change the game so that players cannot re-use integers?</p>\n<p>For example, two players might take turns drawing from a common pool of numbers of 1..15 without replacement until they reach a total &gt;= 100.</p>\n<p>Given an integer maxChoosableInteger and another integer desiredTotal, determine if the first player to move can force a win, assuming both players play optimally.</p>\n<p>You can always assume that maxChoosableInteger will not be larger than 20 and desiredTotal will not be larger than 300.</p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">    maxChoosableInteger = 10</div><div class=\"line\">    desiredTotal = 11</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">    false</div><div class=\"line\"></div><div class=\"line\">Explanation:</div><div class=\"line\">    No matter which integer the first player choose, the first player will lose.</div><div class=\"line\">    The first player can choose an integer from 1 up to 10.</div><div class=\"line\">    If the first player choose 1, the second player can only choose integers from 2 up to 10.</div><div class=\"line\">    The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.</div><div class=\"line\">    Same with other integers chosen by the first player, the second player will always win.</div></pre></td></tr></table></figure></p>\n</blockquote>","more":"<p>This is Leetcode No.464. At the beginning, I just want to show its all possible combination. The code is like following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canIWin(int maxChoosableInteger, int desiredTotal) &#123;</div><div class=\"line\">            if (desiredTotal &lt; 1) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            set&lt;int&gt; nums;</div><div class=\"line\">            for (int i = 1; i &lt;= maxChoosableInteger; i++) &#123;</div><div class=\"line\">                nums.insert(i);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return _check(nums, false, 0, desiredTotal);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _check(set&lt;int&gt; &amp;nums, int isFirst, int current, int target) &#123;</div><div class=\"line\">            if (current &gt;= target) &#123;</div><div class=\"line\">                return isFirst;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool res;</div><div class=\"line\">            if (isFirst) &#123;</div><div class=\"line\">                res = false;</div><div class=\"line\"></div><div class=\"line\">                for (auto i : nums) &#123;</div><div class=\"line\">                    set&lt;int&gt; t_nums(nums);</div><div class=\"line\">                    t_nums.erase(i);</div><div class=\"line\">                    res = res || _check(t_nums, !isFirst, current + i, target);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = true;</div><div class=\"line\"></div><div class=\"line\">                for (auto i : nums) &#123;</div><div class=\"line\">                    set&lt;int&gt; t_nums(nums);</div><div class=\"line\">                    t_nums.erase(i);</div><div class=\"line\">                    res = res &amp;&amp; _check(t_nums, !isFirst, current + i, target);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, However, it gets a TLE. So the problem is that the number of branches is too large. One solution is to find a way to reduce the branches.</p>\n<p>In some case, the most time-cost step is the copying of the set. So I try to solve the problem first.</p>\n<p>Then, use memorized method to reduce the time cost. Then use BITSET instead of SET to reduce the space cost.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    private:</div><div class=\"line\">        vector&lt;int&gt; *winSet;</div><div class=\"line\">        bool canIWinAux(int numSet, int total) &#123;</div><div class=\"line\">            int maxnum = maxNum(numSet);</div><div class=\"line\">            if (maxnum &gt;= total) return true;</div><div class=\"line\">            if (winSet-&gt;at(numSet) != -1) return winSet-&gt;at(numSet);</div><div class=\"line\">            for (int num = 1; num &lt;= maxnum; num++) &#123;</div><div class=\"line\">                int mask = 1 &lt;&lt; (num-1);</div><div class=\"line\">                //\tskip used number</div><div class=\"line\">                if (!(numSet&amp;mask)) continue;</div><div class=\"line\">                //\tskip if take num as first choice</div><div class=\"line\">                if (canIWinAux((int)(numSet&amp;(~mask)), total - num)) continue;</div><div class=\"line\">                //\totherwise this num is the smart choice</div><div class=\"line\">                winSet-&gt;at(numSet) = true;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //\thave tried every number in numSet and fail to win</div><div class=\"line\">            winSet-&gt;at(numSet) = false;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //\treturn the maximum number avaliable in the numSet</div><div class=\"line\">        int maxNum(int numSet) &#123;</div><div class=\"line\">            int firstBit = 0;</div><div class=\"line\">            while (numSet) &#123;</div><div class=\"line\">                firstBit++;</div><div class=\"line\">                numSet &gt;&gt;= 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return firstBit;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    public:</div><div class=\"line\">        bool canIWin(int maxChoosableInteger, int desiredTotal) &#123;</div><div class=\"line\">            if (desiredTotal&gt;maxChoosableInteger*(maxChoosableInteger + 1) / 2) return false;</div><div class=\"line\">            if (desiredTotal &lt;= maxChoosableInteger) return true;</div><div class=\"line\">            if (desiredTotal % (1 + maxChoosableInteger) == 0 &amp;&amp; maxChoosableInteger % 2 == 0) return false;</div><div class=\"line\"></div><div class=\"line\">            //\tnumSet: the k-nd bit stands for number k; 1 is usable, 0 is used, -1 is unknown.</div><div class=\"line\">            int numSet = (1 &lt;&lt; (maxChoosableInteger))-1;</div><div class=\"line\">            winSet = new vector&lt;int&gt;(1 &lt;&lt; maxChoosableInteger, -1);</div><div class=\"line\">            return canIWinAux(numSet, desiredTotal);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Then it gets AC.</p>"},{"title":"Best Time to Buy and Sell Stock with Cooldown","date":"2017-02-06T07:44:45.000Z","_content":"\n> Say you have an array for which the ith element is the price of a given stock on day i.\n>\n> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n>\n> + You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n> + After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n>\n> Example:\n> + prices = [1, 2, 3, 0, 2]\n> + maxProfit = 3\n> + transactions = [buy, sell, cooldown, buy, sell]\n\n<!--more-->\n\nThis is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.\n\nFirst, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.\n\n+ When status = 0, you can only do go on.\n\n+ When status = 1, you can sell or hold.\n\n+ When status = 2, you can buy and go on.\n\nSo, quickly find the solution:\n\n```\nclass Solution {\n    public:\n        int res;\n        int maxProfit(vector<int>& prices) {\n            res = INT_MIN;\n\n            _calc(prices, 2, 0, 0, 0);\n\n            return res;\n        }\n\n        // status: 0 cooldown, 1 hold, 2 none\n        void _calc(vector<int> prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) {\n            if (currentProfit > res) {\n                res = currentProfit;\n            }\n            if (currentIdx >= (int)prices.size()) {\n                return;\n            }\n            if (currentStatus == 0) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n            }\n            if (currentStatus == 1) {\n                // sell if larger than hold\n                if (prices[currentIdx] > holdPrice) {\n                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);\n                }\n                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);\n            }\n            if (currentStatus == 2) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);\n            }\n        }\n};\n```\n\nIt is right, but it gets TLE. So, it should need a DP improvement.\n\nSo, we can use three status array to store the status of current to present our profit.\n\nAs, what I say above, we will have three status. So, we can define the DP representation:\n\n+ none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown\n+ hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none\n+ cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold\n\nSo, the initial status is:\n\n+ none[0] = 0;\n+ hold[0] = -prices[0];\n+ cooldown = 0;\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int maxProfit(vector<int>& prices){\n            if (prices.size() <= 1) return 0;\n            vector<int> none(prices.size(), 0);\n            vector<int> hold(prices.size(), 0);\n            vector<int> cooldown(prices.size(), 0);\n            hold[0] = -prices[0];\n            none[0] = 0;\n            cooldown[0] = INT_MIN;\n            for (int i = 1; i < (int)prices.size(); i++) {\n                none[i] = max(none[i - 1], cooldown[i - 1]);\n                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);\n                cooldown[i] = hold[i - 1] + prices[i];\n            }\n            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/BestTimetoBuyandSellStockwithCooldown.md","raw":"---\ntitle: Best Time to Buy and Sell Stock with Cooldown\ndate: 2017-02-06 15:44:45\ntags:\n    - Dynamic Programming\n---\n\n> Say you have an array for which the ith element is the price of a given stock on day i.\n>\n> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\n>\n> + You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\n> + After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n>\n> Example:\n> + prices = [1, 2, 3, 0, 2]\n> + maxProfit = 3\n> + transactions = [buy, sell, cooldown, buy, sell]\n\n<!--more-->\n\nThis is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.\n\nFirst, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.\n\n+ When status = 0, you can only do go on.\n\n+ When status = 1, you can sell or hold.\n\n+ When status = 2, you can buy and go on.\n\nSo, quickly find the solution:\n\n```\nclass Solution {\n    public:\n        int res;\n        int maxProfit(vector<int>& prices) {\n            res = INT_MIN;\n\n            _calc(prices, 2, 0, 0, 0);\n\n            return res;\n        }\n\n        // status: 0 cooldown, 1 hold, 2 none\n        void _calc(vector<int> prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) {\n            if (currentProfit > res) {\n                res = currentProfit;\n            }\n            if (currentIdx >= (int)prices.size()) {\n                return;\n            }\n            if (currentStatus == 0) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n            }\n            if (currentStatus == 1) {\n                // sell if larger than hold\n                if (prices[currentIdx] > holdPrice) {\n                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);\n                }\n                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);\n            }\n            if (currentStatus == 2) {\n                _calc(prices, 2, currentIdx + 1, currentProfit, 0);\n                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);\n            }\n        }\n};\n```\n\nIt is right, but it gets TLE. So, it should need a DP improvement.\n\nSo, we can use three status array to store the status of current to present our profit.\n\nAs, what I say above, we will have three status. So, we can define the DP representation:\n\n+ none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown\n+ hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none\n+ cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold\n\nSo, the initial status is:\n\n+ none[0] = 0;\n+ hold[0] = -prices[0];\n+ cooldown = 0;\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int maxProfit(vector<int>& prices){\n            if (prices.size() <= 1) return 0;\n            vector<int> none(prices.size(), 0);\n            vector<int> hold(prices.size(), 0);\n            vector<int> cooldown(prices.size(), 0);\n            hold[0] = -prices[0];\n            none[0] = 0;\n            cooldown[0] = INT_MIN;\n            for (int i = 1; i < (int)prices.size(); i++) {\n                none[i] = max(none[i - 1], cooldown[i - 1]);\n                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);\n                cooldown[i] = hold[i - 1] + prices[i];\n            }\n            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"BestTimetoBuyandSellStockwithCooldown","published":1,"updated":"2017-02-06T08:35:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatul000fg5f4kyw9sowc","content":"<blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n<ul>\n<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\n<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\n</ul>\n<p>Example:</p>\n<ul>\n<li>prices = [1, 2, 3, 0, 2]</li>\n<li>maxProfit = 3</li>\n<li>transactions = [buy, sell, cooldown, buy, sell]</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.</p>\n<p>First, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.</p>\n<ul>\n<li><p>When status = 0, you can only do go on.</p>\n</li>\n<li><p>When status = 1, you can sell or hold.</p>\n</li>\n<li><p>When status = 2, you can buy and go on.</p>\n</li>\n</ul>\n<p>So, quickly find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</div><div class=\"line\">            res = INT_MIN;</div><div class=\"line\"></div><div class=\"line\">            _calc(prices, 2, 0, 0, 0);</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // status: 0 cooldown, 1 hold, 2 none</div><div class=\"line\">        void _calc(vector&lt;int&gt; prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) &#123;</div><div class=\"line\">            if (currentProfit &gt; res) &#123;</div><div class=\"line\">                res = currentProfit;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdx &gt;= (int)prices.size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 0) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 1) &#123;</div><div class=\"line\">                // sell if larger than hold</div><div class=\"line\">                if (prices[currentIdx] &gt; holdPrice) &#123;</div><div class=\"line\">                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 2) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is right, but it gets TLE. So, it should need a DP improvement.</p>\n<p>So, we can use three status array to store the status of current to present our profit.</p>\n<p>As, what I say above, we will have three status. So, we can define the DP representation:</p>\n<ul>\n<li>none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown</li>\n<li>hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none</li>\n<li>cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold</li>\n</ul>\n<p>So, the initial status is:</p>\n<ul>\n<li>none[0] = 0;</li>\n<li>hold[0] = -prices[0];</li>\n<li>cooldown = 0;</li>\n</ul>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</div><div class=\"line\">            if (prices.size() &lt;= 1) return 0;</div><div class=\"line\">            vector&lt;int&gt; none(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; hold(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; cooldown(prices.size(), 0);</div><div class=\"line\">            hold[0] = -prices[0];</div><div class=\"line\">            none[0] = 0;</div><div class=\"line\">            cooldown[0] = INT_MIN;</div><div class=\"line\">            for (int i = 1; i &lt; (int)prices.size(); i++) &#123;</div><div class=\"line\">                none[i] = max(none[i - 1], cooldown[i - 1]);</div><div class=\"line\">                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);</div><div class=\"line\">                cooldown[i] = hold[i - 1] + prices[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>\n<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>\n<ul>\n<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>\n<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>\n</ul>\n<p>Example:</p>\n<ul>\n<li>prices = [1, 2, 3, 0, 2]</li>\n<li>maxProfit = 3</li>\n<li>transactions = [buy, sell, cooldown, buy, sell]</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.309, and it is a such a DP problem. The important thing is to find the relationship of the condition transition.</p>\n<p>First, you can define two status, No.1 is cooldown, No.2 is hold, No.2 is none.</p>\n<ul>\n<li><p>When status = 0, you can only do go on.</p>\n</li>\n<li><p>When status = 1, you can sell or hold.</p>\n</li>\n<li><p>When status = 2, you can buy and go on.</p>\n</li>\n</ul>\n<p>So, quickly find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</div><div class=\"line\">            res = INT_MIN;</div><div class=\"line\"></div><div class=\"line\">            _calc(prices, 2, 0, 0, 0);</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // status: 0 cooldown, 1 hold, 2 none</div><div class=\"line\">        void _calc(vector&lt;int&gt; prices, int currentStatus, int currentIdx, int currentProfit, int holdPrice) &#123;</div><div class=\"line\">            if (currentProfit &gt; res) &#123;</div><div class=\"line\">                res = currentProfit;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentIdx &gt;= (int)prices.size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 0) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 1) &#123;</div><div class=\"line\">                // sell if larger than hold</div><div class=\"line\">                if (prices[currentIdx] &gt; holdPrice) &#123;</div><div class=\"line\">                    _calc(prices, 0, currentIdx + 1, currentProfit + prices[currentIdx] - holdPrice, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, holdPrice);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (currentStatus == 2) &#123;</div><div class=\"line\">                _calc(prices, 2, currentIdx + 1, currentProfit, 0);</div><div class=\"line\">                _calc(prices, 1, currentIdx + 1, currentProfit, prices[currentIdx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is right, but it gets TLE. So, it should need a DP improvement.</p>\n<p>So, we can use three status array to store the status of current to present our profit.</p>\n<p>As, what I say above, we will have three status. So, we can define the DP representation:</p>\n<ul>\n<li>none[i] = max(none[i - 1], cooldown[i - 1]); // Stay at none, or rest from cooldown</li>\n<li>hold[i] = max(hold[i - 1], none[i - 1] - prices[i]); // Stay at hold, or buy from none</li>\n<li>cooldown[i] = hold[i - 1] + prices[i]; // Only one way from hold</li>\n</ul>\n<p>So, the initial status is:</p>\n<ul>\n<li>none[0] = 0;</li>\n<li>hold[0] = -prices[0];</li>\n<li>cooldown = 0;</li>\n</ul>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProfit(vector&lt;int&gt;&amp; prices)&#123;</div><div class=\"line\">            if (prices.size() &lt;= 1) return 0;</div><div class=\"line\">            vector&lt;int&gt; none(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; hold(prices.size(), 0);</div><div class=\"line\">            vector&lt;int&gt; cooldown(prices.size(), 0);</div><div class=\"line\">            hold[0] = -prices[0];</div><div class=\"line\">            none[0] = 0;</div><div class=\"line\">            cooldown[0] = INT_MIN;</div><div class=\"line\">            for (int i = 1; i &lt; (int)prices.size(); i++) &#123;</div><div class=\"line\">                none[i] = max(none[i - 1], cooldown[i - 1]);</div><div class=\"line\">                hold[i] = max(hold[i - 1], none[i - 1] - prices[i]);</div><div class=\"line\">                cooldown[i] = hold[i - 1] + prices[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return max(none[prices.size() - 1], cooldown[prices.size() - 1]);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Bulb Switcher","date":"2017-03-28T05:47:57.000Z","_content":"\n> There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n>\n> Example:\n>\n>```\nGiven n = 3.\n\nAt first, the three bulbs are [off, off, off].\nAfter first round, the three bulbs are [on, on, on].\nAfter second round, the three bulbs are [on, off, on].\nAfter third round, the three bulbs are [on, off, off].\n\nSo you should return 1, because there is only one bulb is on.\n```\n\n<!--more-->\n\nThis is Leetcode No.319. It is a Math problem in my opinion. So, I make it a math way to solve. Code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int bulbSwitch(int num) {\n            int res = 0;\n            for (int idx = 1; idx <= num; idx++) {\n                int flag = 0;\n                for (int del = 1; del <= idx / del; del++) {\n                    if (idx % del == 0) {\n                        flag = flag + (idx / del == del ? 1 : 2);\n                    }\n                }\n                if (flag % 2 == 1) {\n                    res++;\n                }\n            }\n            return res;\n        }\n};\n```\n\nHowever, It gets a TLE. This is a O(n) method. So, I think there is other way to solve the problem.\n\nSo, I check the discuss and find a better way to solve the problem a really O(n) solution.\n\nYou can find which kind of number is on. Those can be multiply by the same num.\n\nSo, the code becomes:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int bulbSwitch(int num) {\n            int res = 0;\n            for (int i = 1; i * i <= num; i++) {\n                res++;\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC. But I find a O(1) solution in the discuss.\n\nWe just need to know, the max idx which under the condition that `idx * idx <= num`\n\nSo, the idx is the result. The code can be much clearer.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int bulbSwitch(int n) {\n            return sqrt(n);\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/BulbSwitcher.md","raw":"---\ntitle: Bulb Switcher\ndate: 2017-03-28 13:47:57\ntags:\n    - Math\n    - Brainteaser\n---\n\n> There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.\n>\n> Example:\n>\n>```\nGiven n = 3.\n\nAt first, the three bulbs are [off, off, off].\nAfter first round, the three bulbs are [on, on, on].\nAfter second round, the three bulbs are [on, off, on].\nAfter third round, the three bulbs are [on, off, off].\n\nSo you should return 1, because there is only one bulb is on.\n```\n\n<!--more-->\n\nThis is Leetcode No.319. It is a Math problem in my opinion. So, I make it a math way to solve. Code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int bulbSwitch(int num) {\n            int res = 0;\n            for (int idx = 1; idx <= num; idx++) {\n                int flag = 0;\n                for (int del = 1; del <= idx / del; del++) {\n                    if (idx % del == 0) {\n                        flag = flag + (idx / del == del ? 1 : 2);\n                    }\n                }\n                if (flag % 2 == 1) {\n                    res++;\n                }\n            }\n            return res;\n        }\n};\n```\n\nHowever, It gets a TLE. This is a O(n) method. So, I think there is other way to solve the problem.\n\nSo, I check the discuss and find a better way to solve the problem a really O(n) solution.\n\nYou can find which kind of number is on. Those can be multiply by the same num.\n\nSo, the code becomes:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int bulbSwitch(int num) {\n            int res = 0;\n            for (int i = 1; i * i <= num; i++) {\n                res++;\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC. But I find a O(1) solution in the discuss.\n\nWe just need to know, the max idx which under the condition that `idx * idx <= num`\n\nSo, the idx is the result. The code can be much clearer.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int bulbSwitch(int n) {\n            return sqrt(n);\n        }\n};\n```\n\nIt gets AC.\n","slug":"BulbSwitcher","published":1,"updated":"2017-03-28T08:19:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatum000hg5f41nhmriun","content":"<blockquote>\n<p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if its off or turning off if its on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given n = 3.</div><div class=\"line\"></div><div class=\"line\">At first, the three bulbs are [off, off, off].</div><div class=\"line\">After first round, the three bulbs are [on, on, on].</div><div class=\"line\">After second round, the three bulbs are [on, off, on].</div><div class=\"line\">After third round, the three bulbs are [on, off, off].</div><div class=\"line\"></div><div class=\"line\">So you should return 1, because there is only one bulb is on.</div></pre></td></tr></table></figure>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.319. It is a Math problem in my opinion. So, I make it a math way to solve. Code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int bulbSwitch(int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 1; idx &lt;= num; idx++) &#123;</div><div class=\"line\">                int flag = 0;</div><div class=\"line\">                for (int del = 1; del &lt;= idx / del; del++) &#123;</div><div class=\"line\">                    if (idx % del == 0) &#123;</div><div class=\"line\">                        flag = flag + (idx / del == del ? 1 : 2);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (flag % 2 == 1) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, It gets a TLE. This is a O(n) method. So, I think there is other way to solve the problem.</p>\n<p>So, I check the discuss and find a better way to solve the problem a really O(n) solution.</p>\n<p>You can find which kind of number is on. Those can be multiply by the same num.</p>\n<p>So, the code becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int bulbSwitch(int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int i = 1; i * i &lt;= num; i++) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. But I find a O(1) solution in the discuss.</p>\n<p>We just need to know, the max idx which under the condition that <code>idx * idx &lt;= num</code></p>\n<p>So, the idx is the result. The code can be much clearer.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int bulbSwitch(int n) &#123;</div><div class=\"line\">            return sqrt(n);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if its off or turning off if its on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given n = 3.</div><div class=\"line\"></div><div class=\"line\">At first, the three bulbs are [off, off, off].</div><div class=\"line\">After first round, the three bulbs are [on, on, on].</div><div class=\"line\">After second round, the three bulbs are [on, off, on].</div><div class=\"line\">After third round, the three bulbs are [on, off, off].</div><div class=\"line\"></div><div class=\"line\">So you should return 1, because there is only one bulb is on.</div></pre></td></tr></table></figure>\n</blockquote>","more":"<p>This is Leetcode No.319. It is a Math problem in my opinion. So, I make it a math way to solve. Code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int bulbSwitch(int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 1; idx &lt;= num; idx++) &#123;</div><div class=\"line\">                int flag = 0;</div><div class=\"line\">                for (int del = 1; del &lt;= idx / del; del++) &#123;</div><div class=\"line\">                    if (idx % del == 0) &#123;</div><div class=\"line\">                        flag = flag + (idx / del == del ? 1 : 2);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (flag % 2 == 1) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, It gets a TLE. This is a O(n) method. So, I think there is other way to solve the problem.</p>\n<p>So, I check the discuss and find a better way to solve the problem a really O(n) solution.</p>\n<p>You can find which kind of number is on. Those can be multiply by the same num.</p>\n<p>So, the code becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int bulbSwitch(int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int i = 1; i * i &lt;= num; i++) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. But I find a O(1) solution in the discuss.</p>\n<p>We just need to know, the max idx which under the condition that <code>idx * idx &lt;= num</code></p>\n<p>So, the idx is the result. The code can be much clearer.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int bulbSwitch(int n) &#123;</div><div class=\"line\">            return sqrt(n);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Combination Sum IV","date":"2017-01-11T01:36:11.000Z","_content":"\n> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\n>\n> Example:\n>\n> nums = [1, 2, 3] , target = 4\n>\n> The possible combination ways are:\n> (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)\n>\n> Note that different sequences are counted as different combinations.\n>\n> Therefore the output is 7.\n>\n> Follow up:\n> What if negative numbers are allowed in the given array?\n> How does it change the problem?\n> What limitation we need to add to the question to allow negative number.\n\n<!--more-->\n\nThis is Leetcode 377, we can quickly find a DFS solution like these:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            sort(nums.begin(), nums.end());\n            res = 0;\n            DFS(nums, target, 0);\n            return res;\n        }\n\n        void DFS(vector<int> &nums, int target, int currentSum) {\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (currentSum + nums[i] > target) {\n                    return;\n                } else if (currentSum + nums[i] == target) {\n                    res++;\n                } else {\n                    DFS(nums, target, currentSum + nums[i]);\n                }\n            }\n        }\n};\n```\n\nIt will solve this problem but it's too slow to get AC. So, we can think in another way.\n\nPicture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            vector<int> res(target + 1, 0);\n            sort(nums.begin(), nums.end());\n            for (int i = 1; i <= target; i++) {\n                for (int num : nums) {\n                    if (num > i) {\n                        break;\n                    } else if (num == i) {\n                        res[num]++;\n                    } else {\n                        res[i] = res[i - num] + res[i];\n                    }\n                }\n            }\n            return res[target];\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/CombinationSumIV.md","raw":"---\ntitle: Combination Sum IV\ndate: 2017-01-11 09:36:11\ntags:\n    - Dynamic Programming\n---\n\n> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.\n>\n> Example:\n>\n> nums = [1, 2, 3] , target = 4\n>\n> The possible combination ways are:\n> (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)\n>\n> Note that different sequences are counted as different combinations.\n>\n> Therefore the output is 7.\n>\n> Follow up:\n> What if negative numbers are allowed in the given array?\n> How does it change the problem?\n> What limitation we need to add to the question to allow negative number.\n\n<!--more-->\n\nThis is Leetcode 377, we can quickly find a DFS solution like these:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            sort(nums.begin(), nums.end());\n            res = 0;\n            DFS(nums, target, 0);\n            return res;\n        }\n\n        void DFS(vector<int> &nums, int target, int currentSum) {\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (currentSum + nums[i] > target) {\n                    return;\n                } else if (currentSum + nums[i] == target) {\n                    res++;\n                } else {\n                    DFS(nums, target, currentSum + nums[i]);\n                }\n            }\n        }\n};\n```\n\nIt will solve this problem but it's too slow to get AC. So, we can think in another way.\n\nPicture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.\n\nSo, the solution is as following:\n\n```\nclass Solution {\n    public:\n        int res;\n        int combinationSum4(vector<int>& nums, int target) {\n            vector<int> res(target + 1, 0);\n            sort(nums.begin(), nums.end());\n            for (int i = 1; i <= target; i++) {\n                for (int num : nums) {\n                    if (num > i) {\n                        break;\n                    } else if (num == i) {\n                        res[num]++;\n                    } else {\n                        res[i] = res[i - num] + res[i];\n                    }\n                }\n            }\n            return res[target];\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"CombinationSumIV","published":1,"updated":"2017-01-13T03:09:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatuw000kg5f4nsiw2irk","content":"<blockquote>\n<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\n<p>Example:</p>\n<p>nums = [1, 2, 3] , target = 4</p>\n<p>The possible combination ways are:<br>(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)</p>\n<p>Note that different sequences are counted as different combinations.</p>\n<p>Therefore the output is 7.</p>\n<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative number.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 377, we can quickly find a DFS solution like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            res = 0;</div><div class=\"line\">            DFS(nums, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void DFS(vector&lt;int&gt; &amp;nums, int target, int currentSum) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (currentSum + nums[i] &gt; target) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125; else if (currentSum + nums[i] == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    DFS(nums, target, currentSum + nums[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It will solve this problem but its too slow to get AC. So, we can think in another way.</p>\n<p>Picture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.</p>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            vector&lt;int&gt; res(target + 1, 0);</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            for (int i = 1; i &lt;= target; i++) &#123;</div><div class=\"line\">                for (int num : nums) &#123;</div><div class=\"line\">                    if (num &gt; i) &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125; else if (num == i) &#123;</div><div class=\"line\">                        res[num]++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res[i] = res[i - num] + res[i];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res[target];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>\n<p>Example:</p>\n<p>nums = [1, 2, 3] , target = 4</p>\n<p>The possible combination ways are:<br>(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)</p>\n<p>Note that different sequences are counted as different combinations.</p>\n<p>Therefore the output is 7.</p>\n<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative number.</p>\n</blockquote>","more":"<p>This is Leetcode 377, we can quickly find a DFS solution like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            res = 0;</div><div class=\"line\">            DFS(nums, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void DFS(vector&lt;int&gt; &amp;nums, int target, int currentSum) &#123;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (currentSum + nums[i] &gt; target) &#123;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125; else if (currentSum + nums[i] == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    DFS(nums, target, currentSum + nums[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It will solve this problem but its too slow to get AC. So, we can think in another way.</p>\n<p>Picture this, we based on the sum. Make a DP array to store the value of the sum kinds of nums which sumed as the key.</p>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            vector&lt;int&gt; res(target + 1, 0);</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            for (int i = 1; i &lt;= target; i++) &#123;</div><div class=\"line\">                for (int num : nums) &#123;</div><div class=\"line\">                    if (num &gt; i) &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125; else if (num == i) &#123;</div><div class=\"line\">                        res[num]++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        res[i] = res[i - num] + res[i];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res[target];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Contiguous Array","date":"2017-02-21T08:17:35.000Z","_content":"\n> Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.\n>\n> Example 1:\n> + Input: [0,1]\n> + Output: 2\n> + Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\n>\n> Example 2:\n> + Input: [0,1,0]\n> + Output: 2\n> + Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n>\n> Note: The length of the given binary array will not exceed 50,000.\n\n<!--more-->\n\nThis is Leetcode No.525. We can quickly find a solution that:\n\n```\n    0 1 0 0 1\n0   1 1 2 3 3\n1   0 1 1 1 2\n```\n\nWe can use DP[idx][0-1] to represent the num of each index. However, we must to use DP[idx1][0-1] - DP[idx2][0-1] to find the exactly num between idx1 and idx2. So the time complex will be O(n^2).\n\nSo, we must to find a better solution to solve the problem.\n\nWe can use similar solution as the Best time to sell and buy stock.\n\nWhat if we have a sequence [0, 0, 0, 0, 1, 1]? the maximum length is 4, the count starting from 0, will equal -1, -2, -3, -4, -3, -2, and won't go back to 0 again. But wait, the longest subarray with equal number of 0 and 1 started and ended when count equals -2. We can plot the changes of count on a graph, as shown below. Point (0,0) indicates the initial value of count is 0, so we count the sequence starting from index 1. The longest subarray is from index 2 to 6.\n\n![https://leetcode.com/uploads/files/1487543036101-figure_1.png](https://leetcode.com/uploads/files/1487543036101-figure_1.png)\n\nSo, we make the time complex to O(n).\n\nHere comes the solution:\n\n```\nclass Solution {\n    public:\n        int findMaxLength(vector<int>& nums) {\n            int count = 0;\n            map<int, vector<int> > idxs;\n            vector<int> idxlist;\n            idxlist.push_back(0);\n            idxs.insert(pair<int, vector<int> >(0, idxlist));\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                if (nums[idx] == 0) {\n                    count--;\n                } else {\n                    count++;\n                }\n                if (idxs.find(count) == idxs.end()) {\n                    vector<int> idxList;\n                    idxList.push_back(idx + 1);\n                    idxs.insert(pair<int, vector<int> >(count, idxList));\n                } else {\n                    idxs.find(count)->second.push_back(idx + 1);\n                }\n            }\n\n            int res = 0;\n            for (auto p : idxs) {\n                if (p.second.size() > 1) {\n                    res = max(res, p.second[p.second.size() - 1] - p.second[0]);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/ContiguousArray.md","raw":"---\ntitle: Contiguous Array\ndate: 2017-02-21 16:17:35\ntags:\n    - Hash Table\n---\n\n> Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.\n>\n> Example 1:\n> + Input: [0,1]\n> + Output: 2\n> + Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.\n>\n> Example 2:\n> + Input: [0,1,0]\n> + Output: 2\n> + Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n>\n> Note: The length of the given binary array will not exceed 50,000.\n\n<!--more-->\n\nThis is Leetcode No.525. We can quickly find a solution that:\n\n```\n    0 1 0 0 1\n0   1 1 2 3 3\n1   0 1 1 1 2\n```\n\nWe can use DP[idx][0-1] to represent the num of each index. However, we must to use DP[idx1][0-1] - DP[idx2][0-1] to find the exactly num between idx1 and idx2. So the time complex will be O(n^2).\n\nSo, we must to find a better solution to solve the problem.\n\nWe can use similar solution as the Best time to sell and buy stock.\n\nWhat if we have a sequence [0, 0, 0, 0, 1, 1]? the maximum length is 4, the count starting from 0, will equal -1, -2, -3, -4, -3, -2, and won't go back to 0 again. But wait, the longest subarray with equal number of 0 and 1 started and ended when count equals -2. We can plot the changes of count on a graph, as shown below. Point (0,0) indicates the initial value of count is 0, so we count the sequence starting from index 1. The longest subarray is from index 2 to 6.\n\n![https://leetcode.com/uploads/files/1487543036101-figure_1.png](https://leetcode.com/uploads/files/1487543036101-figure_1.png)\n\nSo, we make the time complex to O(n).\n\nHere comes the solution:\n\n```\nclass Solution {\n    public:\n        int findMaxLength(vector<int>& nums) {\n            int count = 0;\n            map<int, vector<int> > idxs;\n            vector<int> idxlist;\n            idxlist.push_back(0);\n            idxs.insert(pair<int, vector<int> >(0, idxlist));\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                if (nums[idx] == 0) {\n                    count--;\n                } else {\n                    count++;\n                }\n                if (idxs.find(count) == idxs.end()) {\n                    vector<int> idxList;\n                    idxList.push_back(idx + 1);\n                    idxs.insert(pair<int, vector<int> >(count, idxList));\n                } else {\n                    idxs.find(count)->second.push_back(idx + 1);\n                }\n            }\n\n            int res = 0;\n            for (auto p : idxs) {\n                if (p.second.size() > 1) {\n                    res = max(res, p.second[p.second.size() - 1] - p.second[0]);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"ContiguousArray","published":1,"updated":"2017-02-21T08:53:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatuy000lg5f4nluq4ba4","content":"<blockquote>\n<p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [0,1]</li>\n<li>Output: 2</li>\n<li>Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [0,1,0]</li>\n<li>Output: 2</li>\n<li>Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</li>\n</ul>\n<p>Note: The length of the given binary array will not exceed 50,000.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.525. We can quickly find a solution that:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    0 1 0 0 1</div><div class=\"line\">0   1 1 2 3 3</div><div class=\"line\">1   0 1 1 1 2</div></pre></td></tr></table></figure>\n<p>We can use DP[idx][0-1] to represent the num of each index. However, we must to use DP[idx1][0-1] - DP[idx2][0-1] to find the exactly num between idx1 and idx2. So the time complex will be O(n^2).</p>\n<p>So, we must to find a better solution to solve the problem.</p>\n<p>We can use similar solution as the Best time to sell and buy stock.</p>\n<p>What if we have a sequence [0, 0, 0, 0, 1, 1]? the maximum length is 4, the count starting from 0, will equal -1, -2, -3, -4, -3, -2, and wont go back to 0 again. But wait, the longest subarray with equal number of 0 and 1 started and ended when count equals -2. We can plot the changes of count on a graph, as shown below. Point (0,0) indicates the initial value of count is 0, so we count the sequence starting from index 1. The longest subarray is from index 2 to 6.</p>\n<p><img src=\"https://leetcode.com/uploads/files/1487543036101-figure_1.png\" alt=\"https://leetcode.com/uploads/files/1487543036101-figure_1.png\"></p>\n<p>So, we make the time complex to O(n).</p>\n<p>Here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxLength(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int count = 0;</div><div class=\"line\">            map&lt;int, vector&lt;int&gt; &gt; idxs;</div><div class=\"line\">            vector&lt;int&gt; idxlist;</div><div class=\"line\">            idxlist.push_back(0);</div><div class=\"line\">            idxs.insert(pair&lt;int, vector&lt;int&gt; &gt;(0, idxlist));</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                if (nums[idx] == 0) &#123;</div><div class=\"line\">                    count--;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    count++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (idxs.find(count) == idxs.end()) &#123;</div><div class=\"line\">                    vector&lt;int&gt; idxList;</div><div class=\"line\">                    idxList.push_back(idx + 1);</div><div class=\"line\">                    idxs.insert(pair&lt;int, vector&lt;int&gt; &gt;(count, idxList));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    idxs.find(count)-&gt;second.push_back(idx + 1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto p : idxs) &#123;</div><div class=\"line\">                if (p.second.size() &gt; 1) &#123;</div><div class=\"line\">                    res = max(res, p.second[p.second.size() - 1] - p.second[0]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [0,1]</li>\n<li>Output: 2</li>\n<li>Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [0,1,0]</li>\n<li>Output: 2</li>\n<li>Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</li>\n</ul>\n<p>Note: The length of the given binary array will not exceed 50,000.</p>\n</blockquote>","more":"<p>This is Leetcode No.525. We can quickly find a solution that:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    0 1 0 0 1</div><div class=\"line\">0   1 1 2 3 3</div><div class=\"line\">1   0 1 1 1 2</div></pre></td></tr></table></figure>\n<p>We can use DP[idx][0-1] to represent the num of each index. However, we must to use DP[idx1][0-1] - DP[idx2][0-1] to find the exactly num between idx1 and idx2. So the time complex will be O(n^2).</p>\n<p>So, we must to find a better solution to solve the problem.</p>\n<p>We can use similar solution as the Best time to sell and buy stock.</p>\n<p>What if we have a sequence [0, 0, 0, 0, 1, 1]? the maximum length is 4, the count starting from 0, will equal -1, -2, -3, -4, -3, -2, and wont go back to 0 again. But wait, the longest subarray with equal number of 0 and 1 started and ended when count equals -2. We can plot the changes of count on a graph, as shown below. Point (0,0) indicates the initial value of count is 0, so we count the sequence starting from index 1. The longest subarray is from index 2 to 6.</p>\n<p><img src=\"https://leetcode.com/uploads/files/1487543036101-figure_1.png\" alt=\"https://leetcode.com/uploads/files/1487543036101-figure_1.png\"></p>\n<p>So, we make the time complex to O(n).</p>\n<p>Here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxLength(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int count = 0;</div><div class=\"line\">            map&lt;int, vector&lt;int&gt; &gt; idxs;</div><div class=\"line\">            vector&lt;int&gt; idxlist;</div><div class=\"line\">            idxlist.push_back(0);</div><div class=\"line\">            idxs.insert(pair&lt;int, vector&lt;int&gt; &gt;(0, idxlist));</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                if (nums[idx] == 0) &#123;</div><div class=\"line\">                    count--;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    count++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (idxs.find(count) == idxs.end()) &#123;</div><div class=\"line\">                    vector&lt;int&gt; idxList;</div><div class=\"line\">                    idxList.push_back(idx + 1);</div><div class=\"line\">                    idxs.insert(pair&lt;int, vector&lt;int&gt; &gt;(count, idxList));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    idxs.find(count)-&gt;second.push_back(idx + 1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto p : idxs) &#123;</div><div class=\"line\">                if (p.second.size() &gt; 1) &#123;</div><div class=\"line\">                    res = max(res, p.second[p.second.size() - 1] - p.second[0]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Contains Duplicate III","date":"2017-03-27T06:24:16.000Z","_content":"\n> Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\n\n<!--more-->\n\nThis is Leetcode No.220. It is a really fun problem. It seems like to find the number pair under these conditions. But you can transform this problem into a search problem.\n\nFor example, you can think like this: find the num1 and num2 in subarray from nums[i] to num[j] that their absolute difference between num1 and num2 is at most k.\n\nThis is my first submit code:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n            int res = false;\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                for (int del = 1; del <= k && idx + del < (int)nums.size(); del++) {\n                    if (abs(nums[idx] - nums[idx + del]) <= t) {\n                        return true;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt has a problem that if the nums is INT_MAX and with numbers less than 0, it will overflow. So, I use long long to avoid this case.\n\nThen the code becomes:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n            int res = false;\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                for (int del = 1; del <= k && idx + del < (int)nums.size(); del++) {\n                    if (abs((long long)nums[idx] - (long long)nums[idx + del]) <= t) {\n                        return true;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt pass the test cases with a TLE.\n\nSo, I use the Binary Search to improve its performance. But it's time complex is O(nlogn). And I find a better solution in the Discuss.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n            set<int> window; // set is ordered automatically\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\n                // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\n                auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t\n                // x - nums[i] <= t ==> |x - nums[i]| <= t\n                if (pos != window.end() && *pos - nums[i] <= t) return true;\n                window.insert(nums[i]);\n            }\n            return false;\n        }\n};\n```\n\nAnd its time complex is O(N), excellent job he does. It absolutely get AC.\n","source":"_posts/ContainsDuplicateIII.md","raw":"---\ntitle: Contains Duplicate III\ndate: 2017-03-27 14:24:16\ntags:\n    - Binary Search Tree\n---\n\n> Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.\n\n<!--more-->\n\nThis is Leetcode No.220. It is a really fun problem. It seems like to find the number pair under these conditions. But you can transform this problem into a search problem.\n\nFor example, you can think like this: find the num1 and num2 in subarray from nums[i] to num[j] that their absolute difference between num1 and num2 is at most k.\n\nThis is my first submit code:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n            int res = false;\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                for (int del = 1; del <= k && idx + del < (int)nums.size(); del++) {\n                    if (abs(nums[idx] - nums[idx + del]) <= t) {\n                        return true;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt has a problem that if the nums is INT_MAX and with numbers less than 0, it will overflow. So, I use long long to avoid this case.\n\nThen the code becomes:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n            int res = false;\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                for (int del = 1; del <= k && idx + del < (int)nums.size(); del++) {\n                    if (abs((long long)nums[idx] - (long long)nums[idx + del]) <= t) {\n                        return true;\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt pass the test cases with a TLE.\n\nSo, I use the Binary Search to improve its performance. But it's time complex is O(nlogn). And I find a better solution in the Discuss.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n            set<int> window; // set is ordered automatically\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\n                // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\n                auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t\n                // x - nums[i] <= t ==> |x - nums[i]| <= t\n                if (pos != window.end() && *pos - nums[i] <= t) return true;\n                window.insert(nums[i]);\n            }\n            return false;\n        }\n};\n```\n\nAnd its time complex is O(N), excellent job he does. It absolutely get AC.\n","slug":"ContainsDuplicateIII","published":1,"updated":"2017-03-27T07:39:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatuz000mg5f4cnashw5x","content":"<blockquote>\n<p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.220. It is a really fun problem. It seems like to find the number pair under these conditions. But you can transform this problem into a search problem.</p>\n<p>For example, you can think like this: find the num1 and num2 in subarray from nums[i] to num[j] that their absolute difference between num1 and num2 is at most k.</p>\n<p>This is my first submit code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</div><div class=\"line\">            int res = false;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                for (int del = 1; del &lt;= k &amp;&amp; idx + del &lt; (int)nums.size(); del++) &#123;</div><div class=\"line\">                    if (abs(nums[idx] - nums[idx + del]) &lt;= t) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It has a problem that if the nums is INT_MAX and with numbers less than 0, it will overflow. So, I use long long to avoid this case.</p>\n<p>Then the code becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</div><div class=\"line\">            int res = false;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                for (int del = 1; del &lt;= k &amp;&amp; idx + del &lt; (int)nums.size(); del++) &#123;</div><div class=\"line\">                    if (abs((long long)nums[idx] - (long long)nums[idx + del]) &lt;= t) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It pass the test cases with a TLE.</p>\n<p>So, I use the Binary Search to improve its performance. But its time complex is O(nlogn). And I find a better solution in the Discuss.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</div><div class=\"line\">            set&lt;int&gt; window; // set is ordered automatically</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (i &gt; k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k</div><div class=\"line\">                // |x - nums[i]| &lt;= t  ==&gt; -t &lt;= x - nums[i] &lt;= t;</div><div class=\"line\">                auto pos = window.lower_bound(nums[i] - t); // x-nums[i] &gt;= -t ==&gt; x &gt;= nums[i]-t</div><div class=\"line\">                // x - nums[i] &lt;= t ==&gt; |x - nums[i]| &lt;= t</div><div class=\"line\">                if (pos != window.end() &amp;&amp; *pos - nums[i] &lt;= t) return true;</div><div class=\"line\">                window.insert(nums[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And its time complex is O(N), excellent job he does. It absolutely get AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>\n</blockquote>","more":"<p>This is Leetcode No.220. It is a really fun problem. It seems like to find the number pair under these conditions. But you can transform this problem into a search problem.</p>\n<p>For example, you can think like this: find the num1 and num2 in subarray from nums[i] to num[j] that their absolute difference between num1 and num2 is at most k.</p>\n<p>This is my first submit code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</div><div class=\"line\">            int res = false;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                for (int del = 1; del &lt;= k &amp;&amp; idx + del &lt; (int)nums.size(); del++) &#123;</div><div class=\"line\">                    if (abs(nums[idx] - nums[idx + del]) &lt;= t) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It has a problem that if the nums is INT_MAX and with numbers less than 0, it will overflow. So, I use long long to avoid this case.</p>\n<p>Then the code becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</div><div class=\"line\">            int res = false;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                for (int del = 1; del &lt;= k &amp;&amp; idx + del &lt; (int)nums.size(); del++) &#123;</div><div class=\"line\">                    if (abs((long long)nums[idx] - (long long)nums[idx + del]) &lt;= t) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It pass the test cases with a TLE.</p>\n<p>So, I use the Binary Search to improve its performance. But its time complex is O(nlogn). And I find a better solution in the Discuss.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;</div><div class=\"line\">            set&lt;int&gt; window; // set is ordered automatically</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (i &gt; k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k</div><div class=\"line\">                // |x - nums[i]| &lt;= t  ==&gt; -t &lt;= x - nums[i] &lt;= t;</div><div class=\"line\">                auto pos = window.lower_bound(nums[i] - t); // x-nums[i] &gt;= -t ==&gt; x &gt;= nums[i]-t</div><div class=\"line\">                // x - nums[i] &lt;= t ==&gt; |x - nums[i]| &lt;= t</div><div class=\"line\">                if (pos != window.end() &amp;&amp; *pos - nums[i] &lt;= t) return true;</div><div class=\"line\">                window.insert(nums[i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And its time complex is O(N), excellent job he does. It absolutely get AC.</p>"},{"title":"Container With Most Water","date":"2017-02-26T09:52:03.000Z","_content":"\n> Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai).\n>\n> n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).\n>\n> Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n>\n> Note: You may not slant the container and n is at least 2.\n\n<!--more-->\n\nThis is Leetcode No.11. Because I should prepare for the incoming interview of the USTC.\n\nSo, I gave up the Leetcode contest.\n\nAt first, I thought this problem is to figure out how many water can this sticks can container.\n\nHowever, this problem is to figure out what is the max value of `min(heights[leftIdx], heights[rightIdx]) * (rightIdx - leftIdx)`.\n\nSo the solution is simple.\n\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int maxArea(vector<int>& heights) {\n            int leftIdx = 0, rightIdx = heights.size() - 1, height = max(heights[leftIdx], heights[rightIdx]), res = INT_MIN;\n            while (leftIdx < rightIdx) {\n                height = min(heights[leftIdx], heights[rightIdx]);\n                res = max(height * (rightIdx - leftIdx), res);\n                while (leftIdx < rightIdx && heights[leftIdx] <= height) {\n                    leftIdx++;\n                }\n                while (leftIdx < rightIdx && heights[rightIdx] <= height) {\n                    rightIdx--;\n                }\n            }\n            return res;\n        }\n};\n```\n\nBecause if the new leftIdx and the new rightIdx are not larger than the older, their result will never larger than before.\n\nIt gets AC.\n","source":"_posts/ContainerWithMostWater.md","raw":"---\ntitle: Container With Most Water\ndate: 2017-02-26 17:52:03\ntags:\n    - Array\n    - Two Pointers\n---\n\n> Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai).\n>\n> n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).\n>\n> Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n>\n> Note: You may not slant the container and n is at least 2.\n\n<!--more-->\n\nThis is Leetcode No.11. Because I should prepare for the incoming interview of the USTC.\n\nSo, I gave up the Leetcode contest.\n\nAt first, I thought this problem is to figure out how many water can this sticks can container.\n\nHowever, this problem is to figure out what is the max value of `min(heights[leftIdx], heights[rightIdx]) * (rightIdx - leftIdx)`.\n\nSo the solution is simple.\n\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int maxArea(vector<int>& heights) {\n            int leftIdx = 0, rightIdx = heights.size() - 1, height = max(heights[leftIdx], heights[rightIdx]), res = INT_MIN;\n            while (leftIdx < rightIdx) {\n                height = min(heights[leftIdx], heights[rightIdx]);\n                res = max(height * (rightIdx - leftIdx), res);\n                while (leftIdx < rightIdx && heights[leftIdx] <= height) {\n                    leftIdx++;\n                }\n                while (leftIdx < rightIdx && heights[rightIdx] <= height) {\n                    rightIdx--;\n                }\n            }\n            return res;\n        }\n};\n```\n\nBecause if the new leftIdx and the new rightIdx are not larger than the older, their result will never larger than before.\n\nIt gets AC.\n","slug":"ContainerWithMostWater","published":1,"updated":"2017-02-26T11:30:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatv1000pg5f4tn48mfjw","content":"<blockquote>\n<p>Given n non-negative integers a1, a2, , an, where each represents a point at coordinate (i, ai).</p>\n<p>n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).</p>\n<p>Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and n is at least 2.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.11. Because I should prepare for the incoming interview of the USTC.</p>\n<p>So, I gave up the Leetcode contest.</p>\n<p>At first, I thought this problem is to figure out how many water can this sticks can container.</p>\n<p>However, this problem is to figure out what is the max value of <code>min(heights[leftIdx], heights[rightIdx]) * (rightIdx - leftIdx)</code>.</p>\n<p>So the solution is simple.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxArea(vector&lt;int&gt;&amp; heights) &#123;</div><div class=\"line\">            int leftIdx = 0, rightIdx = heights.size() - 1, height = max(heights[leftIdx], heights[rightIdx]), res = INT_MIN;</div><div class=\"line\">            while (leftIdx &lt; rightIdx) &#123;</div><div class=\"line\">                height = min(heights[leftIdx], heights[rightIdx]);</div><div class=\"line\">                res = max(height * (rightIdx - leftIdx), res);</div><div class=\"line\">                while (leftIdx &lt; rightIdx &amp;&amp; heights[leftIdx] &lt;= height) &#123;</div><div class=\"line\">                    leftIdx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                while (leftIdx &lt; rightIdx &amp;&amp; heights[rightIdx] &lt;= height) &#123;</div><div class=\"line\">                    rightIdx--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Because if the new leftIdx and the new rightIdx are not larger than the older, their result will never larger than before.</p>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given n non-negative integers a1, a2, , an, where each represents a point at coordinate (i, ai).</p>\n<p>n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).</p>\n<p>Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>\n<p>Note: You may not slant the container and n is at least 2.</p>\n</blockquote>","more":"<p>This is Leetcode No.11. Because I should prepare for the incoming interview of the USTC.</p>\n<p>So, I gave up the Leetcode contest.</p>\n<p>At first, I thought this problem is to figure out how many water can this sticks can container.</p>\n<p>However, this problem is to figure out what is the max value of <code>min(heights[leftIdx], heights[rightIdx]) * (rightIdx - leftIdx)</code>.</p>\n<p>So the solution is simple.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxArea(vector&lt;int&gt;&amp; heights) &#123;</div><div class=\"line\">            int leftIdx = 0, rightIdx = heights.size() - 1, height = max(heights[leftIdx], heights[rightIdx]), res = INT_MIN;</div><div class=\"line\">            while (leftIdx &lt; rightIdx) &#123;</div><div class=\"line\">                height = min(heights[leftIdx], heights[rightIdx]);</div><div class=\"line\">                res = max(height * (rightIdx - leftIdx), res);</div><div class=\"line\">                while (leftIdx &lt; rightIdx &amp;&amp; heights[leftIdx] &lt;= height) &#123;</div><div class=\"line\">                    leftIdx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                while (leftIdx &lt; rightIdx &amp;&amp; heights[rightIdx] &lt;= height) &#123;</div><div class=\"line\">                    rightIdx--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Because if the new leftIdx and the new rightIdx are not larger than the older, their result will never larger than before.</p>\n<p>It gets AC.</p>"},{"title":"Detect Capital","date":"2017-02-25T03:26:08.000Z","_content":"\n> Given a word, you need to judge whether the usage of capitals in it is right or not.\n>\n> We define the usage of capitals in a word to be right when one of the following cases holds:\n>\n> + All letters in this word are capitals, like \"USA\".\n> + All letters in this word are not capitals, like \"leetcode\".\n> + Only the first letter in this word is capital if it has more than one letter, like \"Google\".\n>\n> Otherwise, we define that this word doesn't use capitals in a right way.\n>\n> Example 1:\n> + Input: \"USA\"\n> + Output: True\n>\n> Example 2:\n> + Input: \"FlaG\"\n> + Output: False\n>\n> Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.\n\n<!--more-->\n\nThis is leetcode No.520. It is an easy one. Just follow the steps mentioned above.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool detectCapitalUse(string word) {\n            int capitalIndex = -1;\n            for (int idx = 0; idx < (int)word.length(); idx++) {\n                if (word[idx] <= 'Z' && word[idx] >= 'A') {\n                    if (capitalIndex + 1 == idx) {\n                        capitalIndex = capitalIndex + 1;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            return capitalIndex <= 0 || capitalIndex == (int)word.length() - 1;\n        }\n};\n```\n\nWe can do such a clean solution. It gets AC.\n","source":"_posts/DetectCapital.md","raw":"---\ntitle: Detect Capital\ndate: 2017-02-25 11:26:08\ntags:\n    - String\n---\n\n> Given a word, you need to judge whether the usage of capitals in it is right or not.\n>\n> We define the usage of capitals in a word to be right when one of the following cases holds:\n>\n> + All letters in this word are capitals, like \"USA\".\n> + All letters in this word are not capitals, like \"leetcode\".\n> + Only the first letter in this word is capital if it has more than one letter, like \"Google\".\n>\n> Otherwise, we define that this word doesn't use capitals in a right way.\n>\n> Example 1:\n> + Input: \"USA\"\n> + Output: True\n>\n> Example 2:\n> + Input: \"FlaG\"\n> + Output: False\n>\n> Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.\n\n<!--more-->\n\nThis is leetcode No.520. It is an easy one. Just follow the steps mentioned above.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        bool detectCapitalUse(string word) {\n            int capitalIndex = -1;\n            for (int idx = 0; idx < (int)word.length(); idx++) {\n                if (word[idx] <= 'Z' && word[idx] >= 'A') {\n                    if (capitalIndex + 1 == idx) {\n                        capitalIndex = capitalIndex + 1;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            return capitalIndex <= 0 || capitalIndex == (int)word.length() - 1;\n        }\n};\n```\n\nWe can do such a clean solution. It gets AC.\n","slug":"DetectCapital","published":1,"updated":"2017-02-25T04:15:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatv3000rg5f4dgjhyqdi","content":"<blockquote>\n<p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p>\n<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>\n<ul>\n<li>All letters in this word are capitals, like USA.</li>\n<li>All letters in this word are not capitals, like leetcode.</li>\n<li>Only the first letter in this word is capital if it has more than one letter, like Google.</li>\n</ul>\n<p>Otherwise, we define that this word doesnt use capitals in a right way.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: USA</li>\n<li>Output: True</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: FlaG</li>\n<li>Output: False</li>\n</ul>\n<p>Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is leetcode No.520. It is an easy one. Just follow the steps mentioned above.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool detectCapitalUse(string word) &#123;</div><div class=\"line\">            int capitalIndex = -1;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)word.length(); idx++) &#123;</div><div class=\"line\">                if (word[idx] &lt;= &apos;Z&apos; &amp;&amp; word[idx] &gt;= &apos;A&apos;) &#123;</div><div class=\"line\">                    if (capitalIndex + 1 == idx) &#123;</div><div class=\"line\">                        capitalIndex = capitalIndex + 1;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        return false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return capitalIndex &lt;= 0 || capitalIndex == (int)word.length() - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>We can do such a clean solution. It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a word, you need to judge whether the usage of capitals in it is right or not.</p>\n<p>We define the usage of capitals in a word to be right when one of the following cases holds:</p>\n<ul>\n<li>All letters in this word are capitals, like USA.</li>\n<li>All letters in this word are not capitals, like leetcode.</li>\n<li>Only the first letter in this word is capital if it has more than one letter, like Google.</li>\n</ul>\n<p>Otherwise, we define that this word doesnt use capitals in a right way.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: USA</li>\n<li>Output: True</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: FlaG</li>\n<li>Output: False</li>\n</ul>\n<p>Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters.</p>\n</blockquote>","more":"<p>This is leetcode No.520. It is an easy one. Just follow the steps mentioned above.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool detectCapitalUse(string word) &#123;</div><div class=\"line\">            int capitalIndex = -1;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)word.length(); idx++) &#123;</div><div class=\"line\">                if (word[idx] &lt;= &apos;Z&apos; &amp;&amp; word[idx] &gt;= &apos;A&apos;) &#123;</div><div class=\"line\">                    if (capitalIndex + 1 == idx) &#123;</div><div class=\"line\">                        capitalIndex = capitalIndex + 1;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        return false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return capitalIndex &lt;= 0 || capitalIndex == (int)word.length() - 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>We can do such a clean solution. It gets AC.</p>"},{"title":"Diameter of Binary Tree","date":"2017-03-20T12:21:21.000Z","_content":"\n> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n>\n> Example:\n> Given a binary tree\n>```\n    1\n   / \\\n  2   3\n / \\ \n4   5\n```\n> Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n>\n> Note: The length of path between two nodes is represented by the number of edges between them.\n\n<!--more-->\n\nDuring the three days when I was in Hefei to take part in the enter-interview of USTC. So I don't have much time to complete my promise about the daily practise.\n\nNow, I will continue to keep my promise. To be a man of my word is my life purpose.\n\nNow, this is Leetcode No.543. It is an easy one, and you can quickly finish the problem with the pre-order visit and a Path helper function.\n\nHere is my code:\n\n```\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\n    public:\n        int res;\n        int diameterOfBinaryTree(TreeNode* root) {\n            res = 0;\n            _preOrder(root);\n            return res;\n        }\n\n        void _preOrder(TreeNode *node) {\n            if (node == NULL) {\n                return;\n            }\n            res = max(res, getPathLength(node->left) + getPathLength(node->right));\n            _preOrder(node->left);\n            _preOrder(node->right);\n        }\n\n        int getPathLength(TreeNode* root) {\n            if (root == NULL) {\n                return 0;\n            } else {\n                return max(getPathLength(root->left), getPathLength(root->right)) + 1;\n            }\n        }\n\n};\n\n```\n\nSimple and clean, and easy to understand. It gets AC.\n","source":"_posts/DiameterofBinaryTree.md","raw":"---\ntitle: Diameter of Binary Tree\ndate: 2017-03-20 20:21:21\ntags:\n    - Tree\n---\n\n> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n>\n> Example:\n> Given a binary tree\n>```\n    1\n   / \\\n  2   3\n / \\ \n4   5\n```\n> Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n>\n> Note: The length of path between two nodes is represented by the number of edges between them.\n\n<!--more-->\n\nDuring the three days when I was in Hefei to take part in the enter-interview of USTC. So I don't have much time to complete my promise about the daily practise.\n\nNow, I will continue to keep my promise. To be a man of my word is my life purpose.\n\nNow, this is Leetcode No.543. It is an easy one, and you can quickly finish the problem with the pre-order visit and a Path helper function.\n\nHere is my code:\n\n```\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\n    public:\n        int res;\n        int diameterOfBinaryTree(TreeNode* root) {\n            res = 0;\n            _preOrder(root);\n            return res;\n        }\n\n        void _preOrder(TreeNode *node) {\n            if (node == NULL) {\n                return;\n            }\n            res = max(res, getPathLength(node->left) + getPathLength(node->right));\n            _preOrder(node->left);\n            _preOrder(node->right);\n        }\n\n        int getPathLength(TreeNode* root) {\n            if (root == NULL) {\n                return 0;\n            } else {\n                return max(getPathLength(root->left), getPathLength(root->right)) + 1;\n            }\n        }\n\n};\n\n```\n\nSimple and clean, and easy to understand. It gets AC.\n","slug":"DiameterofBinaryTree","published":1,"updated":"2017-03-20T12:45:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatv4000ug5f4kb5o56ru","content":"<blockquote>\n<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>\n<p>Example:<br>Given a binary tree<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    1</div><div class=\"line\">   / \\</div><div class=\"line\">  2   3</div><div class=\"line\"> / \\ </div><div class=\"line\">4   5</div></pre></td></tr></table></figure></p>\n<p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>\n<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>During the three days when I was in Hefei to take part in the enter-interview of USTC. So I dont have much time to complete my promise about the daily practise.</p>\n<p>Now, I will continue to keep my promise. To be a man of my word is my life purpose.</p>\n<p>Now, this is Leetcode No.543. It is an easy one, and you can quickly finish the problem with the pre-order visit and a Path helper function.</p>\n<p>Here is my code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">struct TreeNode &#123;</div><div class=\"line\">    int val;</div><div class=\"line\">    TreeNode *left;</div><div class=\"line\">    TreeNode *right;</div><div class=\"line\">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int diameterOfBinaryTree(TreeNode* root) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            _preOrder(root);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode *node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            res = max(res, getPathLength(node-&gt;left) + getPathLength(node-&gt;right));</div><div class=\"line\">            _preOrder(node-&gt;left);</div><div class=\"line\">            _preOrder(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int getPathLength(TreeNode* root) &#123;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return max(getPathLength(root-&gt;left), getPathLength(root-&gt;right)) + 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Simple and clean, and easy to understand. It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>\n<p>Example:<br>Given a binary tree<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    1</div><div class=\"line\">   / \\</div><div class=\"line\">  2   3</div><div class=\"line\"> / \\ </div><div class=\"line\">4   5</div></pre></td></tr></table></figure></p>\n<p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p>\n<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>\n</blockquote>","more":"<p>During the three days when I was in Hefei to take part in the enter-interview of USTC. So I dont have much time to complete my promise about the daily practise.</p>\n<p>Now, I will continue to keep my promise. To be a man of my word is my life purpose.</p>\n<p>Now, this is Leetcode No.543. It is an easy one, and you can quickly finish the problem with the pre-order visit and a Path helper function.</p>\n<p>Here is my code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">struct TreeNode &#123;</div><div class=\"line\">    int val;</div><div class=\"line\">    TreeNode *left;</div><div class=\"line\">    TreeNode *right;</div><div class=\"line\">    TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        int diameterOfBinaryTree(TreeNode* root) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            _preOrder(root);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode *node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            res = max(res, getPathLength(node-&gt;left) + getPathLength(node-&gt;right));</div><div class=\"line\">            _preOrder(node-&gt;left);</div><div class=\"line\">            _preOrder(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int getPathLength(TreeNode* root) &#123;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return max(getPathLength(root-&gt;left), getPathLength(root-&gt;right)) + 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Simple and clean, and easy to understand. It gets AC.</p>"},{"title":"Decode String","date":"2017-01-27T15:11:47.000Z","_content":"\n> Given an encoded string, return it's decoded string.\n>\n> The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n>\n> You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n>\n> Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n>\n> Examples:\n>\n> + s = \"3[a]2[bc]\", return \"aaabcbc\".\n> + s = \"3[a2[c]]\", return \"accaccacc\".\n> + s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n\n<!--more-->\n\nThis is Leetcode 394, and it's a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find [here - https://mikecoder.cn/post/164](https://mikecoder.cn/post/164).\n\nBut, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.\n\nSo, I will use two stacks to store the value:\n\n```\nclass Solution {\n    public:\n        string decodeString(string str) {\n            stack<string> chars;\n            stack<int> nums;\n            string res;\n            int num = 0;\n            for(char c: str) {\n                if(isdigit(c)) {\n                    num = num*10 + (c - '0');\n                } else if(isalpha(c)) {\n                    res.push_back(c);\n                } else if(c == '[') {\n                    chars.push(res);\n                    nums.push(num);\n                    res = \"\";\n                    num = 0;\n                } else if(c == ']') {\n                    string tmp = res;\n                    for(int i = 0; i < nums.top()-1; ++i) {\n                        res += tmp;\n                    }\n                    res = chars.top() + res;\n                    chars.pop(); nums.pop();\n                }\n            }\n            return res;\n        }\n};\n```\n\nHere is the solution and it gets AC.\n","source":"_posts/DecodeString.md","raw":"---\ntitle: Decode String\ndate: 2017-01-27 23:11:47\ntags:\n    - Stack\n    - Depth-first Search\n---\n\n> Given an encoded string, return it's decoded string.\n>\n> The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n>\n> You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n>\n> Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n>\n> Examples:\n>\n> + s = \"3[a]2[bc]\", return \"aaabcbc\".\n> + s = \"3[a2[c]]\", return \"accaccacc\".\n> + s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n\n<!--more-->\n\nThis is Leetcode 394, and it's a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find [here - https://mikecoder.cn/post/164](https://mikecoder.cn/post/164).\n\nBut, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.\n\nSo, I will use two stacks to store the value:\n\n```\nclass Solution {\n    public:\n        string decodeString(string str) {\n            stack<string> chars;\n            stack<int> nums;\n            string res;\n            int num = 0;\n            for(char c: str) {\n                if(isdigit(c)) {\n                    num = num*10 + (c - '0');\n                } else if(isalpha(c)) {\n                    res.push_back(c);\n                } else if(c == '[') {\n                    chars.push(res);\n                    nums.push(num);\n                    res = \"\";\n                    num = 0;\n                } else if(c == ']') {\n                    string tmp = res;\n                    for(int i = 0; i < nums.top()-1; ++i) {\n                        res += tmp;\n                    }\n                    res = chars.top() + res;\n                    chars.pop(); nums.pop();\n                }\n            }\n            return res;\n        }\n};\n```\n\nHere is the solution and it gets AC.\n","slug":"DecodeString","published":1,"updated":"2017-01-27T14:05:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatv5000vg5f4onfoauik","content":"<blockquote>\n<p>Given an encoded string, return its decoded string.</p>\n<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there wont be input like 3a or 2[4].</p>\n<p>Examples:</p>\n<ul>\n<li>s = 3[a]2[bc], return aaabcbc.</li>\n<li>s = 3[a2[c]], return accaccacc.</li>\n<li>s = 2[abc]3[cd]ef, return abcabccdcdcdef.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 394, and its a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find <a href=\"https://mikecoder.cn/post/164\" target=\"_blank\" rel=\"external\">here - https://mikecoder.cn/post/164</a>.</p>\n<p>But, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.</p>\n<p>So, I will use two stacks to store the value:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string decodeString(string str) &#123;</div><div class=\"line\">            stack&lt;string&gt; chars;</div><div class=\"line\">            stack&lt;int&gt; nums;</div><div class=\"line\">            string res;</div><div class=\"line\">            int num = 0;</div><div class=\"line\">            for(char c: str) &#123;</div><div class=\"line\">                if(isdigit(c)) &#123;</div><div class=\"line\">                    num = num*10 + (c - &apos;0&apos;);</div><div class=\"line\">                &#125; else if(isalpha(c)) &#123;</div><div class=\"line\">                    res.push_back(c);</div><div class=\"line\">                &#125; else if(c == &apos;[&apos;) &#123;</div><div class=\"line\">                    chars.push(res);</div><div class=\"line\">                    nums.push(num);</div><div class=\"line\">                    res = &quot;&quot;;</div><div class=\"line\">                    num = 0;</div><div class=\"line\">                &#125; else if(c == &apos;]&apos;) &#123;</div><div class=\"line\">                    string tmp = res;</div><div class=\"line\">                    for(int i = 0; i &lt; nums.top()-1; ++i) &#123;</div><div class=\"line\">                        res += tmp;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res = chars.top() + res;</div><div class=\"line\">                    chars.pop(); nums.pop();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here is the solution and it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an encoded string, return its decoded string.</p>\n<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>\n<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>\n<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there wont be input like 3a or 2[4].</p>\n<p>Examples:</p>\n<ul>\n<li>s = 3[a]2[bc], return aaabcbc.</li>\n<li>s = 3[a2[c]], return accaccacc.</li>\n<li>s = 2[abc]3[cd]ef, return abcabccdcdcdef.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 394, and its a problem with much fun. I have two solutions here. The first one is like what I use to write my own url rule parser. You can find <a href=\"https://mikecoder.cn/post/164\">here - https://mikecoder.cn/post/164</a>.</p>\n<p>But, its time complex is O(n^2). So, I should find a better solution. For example I can decode and read the string at the same time not just to find the pattern.</p>\n<p>So, I will use two stacks to store the value:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string decodeString(string str) &#123;</div><div class=\"line\">            stack&lt;string&gt; chars;</div><div class=\"line\">            stack&lt;int&gt; nums;</div><div class=\"line\">            string res;</div><div class=\"line\">            int num = 0;</div><div class=\"line\">            for(char c: str) &#123;</div><div class=\"line\">                if(isdigit(c)) &#123;</div><div class=\"line\">                    num = num*10 + (c - &apos;0&apos;);</div><div class=\"line\">                &#125; else if(isalpha(c)) &#123;</div><div class=\"line\">                    res.push_back(c);</div><div class=\"line\">                &#125; else if(c == &apos;[&apos;) &#123;</div><div class=\"line\">                    chars.push(res);</div><div class=\"line\">                    nums.push(num);</div><div class=\"line\">                    res = &quot;&quot;;</div><div class=\"line\">                    num = 0;</div><div class=\"line\">                &#125; else if(c == &apos;]&apos;) &#123;</div><div class=\"line\">                    string tmp = res;</div><div class=\"line\">                    for(int i = 0; i &lt; nums.top()-1; ++i) &#123;</div><div class=\"line\">                        res += tmp;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    res = chars.top() + res;</div><div class=\"line\">                    chars.pop(); nums.pop();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here is the solution and it gets AC.</p>"},{"title":"Continuous Subarray Sum","date":"2017-03-08T02:29:23.000Z","_content":"\n\n> Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.\n>\n> Example 1:\n>```\nInput: [23, 2, 4, 6, 7],  k=6\nOutput: True\nExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n```\n> Example 2:\n>```\nInput: [23, 2, 6, 4, 7],  k=6\nOutput: True\nExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n```\n> Note:\n>\n> + The length of the array won't exceed 10,000.\n> + You may assume the sum of all the numbers is in the range of a signed 32-bit integer.\n\n<!--more-->\n\nThis is Leetcode No.523, and I get a mistake when I write this code. I don't figure out the case when K = 0.\n\nMy code will get a divided by zero error. And I just use a no-smart solution:\n\n```\nclass Solution {\n    public:\n        bool checkSubarraySum(vector<int>& nums, int k) {\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                int sum = nums[idx];\n                for (int idy = idx + 1; idy < (int)nums.size(); idy++) {\n                    sum = sum + nums[idy];\n                    if (sum == 0) {\n                        return true;\n                    }\n                    if (k != 0 && sum % k == 0) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n};\n```\n\nI just to count the sum of every combination. So the time complex is O(n^2).Though it gets AC but it is not a good solution.\n\nWhen I search in the discuss. I find some better solution:\n\n```\npublic boolean checkSubarraySum(int[] nums, int k) {\n\tint n = nums.length;\n\tint[] sums = new int[n+1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tsums[i] = sums[i-1] + nums[i-1];\n\t\tfor (int j = 0; j < i-1; j++) {\n\t\t\tint dif = sums[i]-sums[j];\n\t\t\tif (dif == 0 && k == 0) return true;\n\t\t\telse if (k == 0) continue;\n\t\t\telse if ((sums[i]-sums[j]) % k == 0) return true;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\nIts time complex is O(n), which is much better than mine.\n","source":"_posts/ContinuousSubarraySum.md","raw":"---\ntitle: Continuous Subarray Sum\ndate: 2017-03-08 10:29:23\ntags:\n    - Dynamic Programming\n    - Math\n---\n\n\n> Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.\n>\n> Example 1:\n>```\nInput: [23, 2, 4, 6, 7],  k=6\nOutput: True\nExplanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.\n```\n> Example 2:\n>```\nInput: [23, 2, 6, 4, 7],  k=6\nOutput: True\nExplanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.\n```\n> Note:\n>\n> + The length of the array won't exceed 10,000.\n> + You may assume the sum of all the numbers is in the range of a signed 32-bit integer.\n\n<!--more-->\n\nThis is Leetcode No.523, and I get a mistake when I write this code. I don't figure out the case when K = 0.\n\nMy code will get a divided by zero error. And I just use a no-smart solution:\n\n```\nclass Solution {\n    public:\n        bool checkSubarraySum(vector<int>& nums, int k) {\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                int sum = nums[idx];\n                for (int idy = idx + 1; idy < (int)nums.size(); idy++) {\n                    sum = sum + nums[idy];\n                    if (sum == 0) {\n                        return true;\n                    }\n                    if (k != 0 && sum % k == 0) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n};\n```\n\nI just to count the sum of every combination. So the time complex is O(n^2).Though it gets AC but it is not a good solution.\n\nWhen I search in the discuss. I find some better solution:\n\n```\npublic boolean checkSubarraySum(int[] nums, int k) {\n\tint n = nums.length;\n\tint[] sums = new int[n+1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tsums[i] = sums[i-1] + nums[i-1];\n\t\tfor (int j = 0; j < i-1; j++) {\n\t\t\tint dif = sums[i]-sums[j];\n\t\t\tif (dif == 0 && k == 0) return true;\n\t\t\telse if (k == 0) continue;\n\t\t\telse if ((sums[i]-sums[j]) % k == 0) return true;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\nIts time complex is O(n), which is much better than mine.\n","slug":"ContinuousSubarraySum","published":1,"updated":"2017-03-08T05:16:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatv7000xg5f4zm3tu3ii","content":"<blockquote>\n<p>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [23, 2, 4, 6, 7],  k=6</div><div class=\"line\">Output: True</div><div class=\"line\">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [23, 2, 6, 4, 7],  k=6</div><div class=\"line\">Output: True</div><div class=\"line\">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The length of the array wont exceed 10,000.</li>\n<li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.523, and I get a mistake when I write this code. I dont figure out the case when K = 0.</p>\n<p>My code will get a divided by zero error. And I just use a no-smart solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                int sum = nums[idx];</div><div class=\"line\">                for (int idy = idx + 1; idy &lt; (int)nums.size(); idy++) &#123;</div><div class=\"line\">                    sum = sum + nums[idy];</div><div class=\"line\">                    if (sum == 0) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (k != 0 &amp;&amp; sum % k == 0) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>I just to count the sum of every combination. So the time complex is O(n^2).Though it gets AC but it is not a good solution.</p>\n<p>When I search in the discuss. I find some better solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean checkSubarraySum(int[] nums, int k) &#123;</div><div class=\"line\">\tint n = nums.length;</div><div class=\"line\">\tint[] sums = new int[n+1];</div><div class=\"line\">\tfor (int i = 1; i &lt;= n; i++) &#123;</div><div class=\"line\">\t\tsums[i] = sums[i-1] + nums[i-1];</div><div class=\"line\">\t\tfor (int j = 0; j &lt; i-1; j++) &#123;</div><div class=\"line\">\t\t\tint dif = sums[i]-sums[j];</div><div class=\"line\">\t\t\tif (dif == 0 &amp;&amp; k == 0) return true;</div><div class=\"line\">\t\t\telse if (k == 0) continue;</div><div class=\"line\">\t\t\telse if ((sums[i]-sums[j]) % k == 0) return true;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), which is much better than mine.</p>\n","excerpt":"<blockquote>\n<p>Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [23, 2, 4, 6, 7],  k=6</div><div class=\"line\">Output: True</div><div class=\"line\">Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [23, 2, 6, 4, 7],  k=6</div><div class=\"line\">Output: True</div><div class=\"line\">Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The length of the array wont exceed 10,000.</li>\n<li>You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.523, and I get a mistake when I write this code. I dont figure out the case when K = 0.</p>\n<p>My code will get a divided by zero error. And I just use a no-smart solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                int sum = nums[idx];</div><div class=\"line\">                for (int idy = idx + 1; idy &lt; (int)nums.size(); idy++) &#123;</div><div class=\"line\">                    sum = sum + nums[idy];</div><div class=\"line\">                    if (sum == 0) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (k != 0 &amp;&amp; sum % k == 0) &#123;</div><div class=\"line\">                        return true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>I just to count the sum of every combination. So the time complex is O(n^2).Though it gets AC but it is not a good solution.</p>\n<p>When I search in the discuss. I find some better solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean checkSubarraySum(int[] nums, int k) &#123;</div><div class=\"line\">\tint n = nums.length;</div><div class=\"line\">\tint[] sums = new int[n+1];</div><div class=\"line\">\tfor (int i = 1; i &lt;= n; i++) &#123;</div><div class=\"line\">\t\tsums[i] = sums[i-1] + nums[i-1];</div><div class=\"line\">\t\tfor (int j = 0; j &lt; i-1; j++) &#123;</div><div class=\"line\">\t\t\tint dif = sums[i]-sums[j];</div><div class=\"line\">\t\t\tif (dif == 0 &amp;&amp; k == 0) return true;</div><div class=\"line\">\t\t\telse if (k == 0) continue;</div><div class=\"line\">\t\t\telse if ((sums[i]-sums[j]) % k == 0) return true;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), which is much better than mine.</p>"},{"title":"Count Numbers with Unique Digits","date":"2017-03-24T01:25:48.000Z","_content":"\n> Given a non-negative integer n, count all numbers with unique digits, x, where 0  x < 10n.\n>\n> Example:\n> Given n = 2, return 91. (The answer should be the total numbers in the range of 0  x < 100, excluding [11,22,33,44,55,66,77,88,99])\n>\n> Hint:\n>\n> + A direct way is to use the backtracking approach.\n> + Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n.\n> + This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.\n> + Let f(k) = count of numbers with unique digits with length equals k.\n> + f(1) = 10, ..., f(k) = 9 * 9 * 8 * ... (9 - k + 2) [The first factor is 9 because a number cannot start with 0].\n\n<!--more-->\n\nThis is Leetcode No.357. It is a common DP problem using backtracking.\n\nMy solution is following.\n\n```\nclass solution {\n    public:\n        int permutation(int n, int r)\n        {\n            if(r == 0)\n            {\n                return 1;\n            }else{\n                return n * permutation(n - 1, r - 1);\n            }\n        }\n        int countnumberswithuniquedigits(int n) {\n            int sum = 1;\n            if(n > 0)\n            {\n            int end = (n > 10)? 10 : n;\n            for(int i = 0; i < end; i++)\n            {\n                sum += 9 * permutation(9, i);\n            }\n            }\n            return sum;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/CountNumberswithUniqueDigits.md","raw":"---\ntitle: Count Numbers with Unique Digits\ndate: 2017-03-24 09:25:48\ntags:\n    - Math\n    - Backtracking\n    - Dynamic Programming\n---\n\n> Given a non-negative integer n, count all numbers with unique digits, x, where 0  x < 10n.\n>\n> Example:\n> Given n = 2, return 91. (The answer should be the total numbers in the range of 0  x < 100, excluding [11,22,33,44,55,66,77,88,99])\n>\n> Hint:\n>\n> + A direct way is to use the backtracking approach.\n> + Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n.\n> + This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.\n> + Let f(k) = count of numbers with unique digits with length equals k.\n> + f(1) = 10, ..., f(k) = 9 * 9 * 8 * ... (9 - k + 2) [The first factor is 9 because a number cannot start with 0].\n\n<!--more-->\n\nThis is Leetcode No.357. It is a common DP problem using backtracking.\n\nMy solution is following.\n\n```\nclass solution {\n    public:\n        int permutation(int n, int r)\n        {\n            if(r == 0)\n            {\n                return 1;\n            }else{\n                return n * permutation(n - 1, r - 1);\n            }\n        }\n        int countnumberswithuniquedigits(int n) {\n            int sum = 1;\n            if(n > 0)\n            {\n            int end = (n > 10)? 10 : n;\n            for(int i = 0; i < end; i++)\n            {\n                sum += 9 * permutation(9, i);\n            }\n            }\n            return sum;\n        }\n};\n```\n\nIt gets AC.\n","slug":"CountNumberswithUniqueDigits","published":1,"updated":"2017-03-27T06:22:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatv8000zg5f403vixdt0","content":"<blockquote>\n<p>Given a non-negative integer n, count all numbers with unique digits, x, where 0  x &lt; 10n.</p>\n<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0  x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>\n<p>Hint:</p>\n<ul>\n<li>A direct way is to use the backtracking approach.</li>\n<li>Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n.</li>\n<li>This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.</li>\n<li>Let f(k) = count of numbers with unique digits with length equals k.</li>\n<li>f(1) = 10, , f(k) = 9 <em> 9 </em> 8 *  (9 - k + 2) [The first factor is 9 because a number cannot start with 0].</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.357. It is a common DP problem using backtracking.</p>\n<p>My solution is following.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int permutation(int n, int r)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if(r == 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                return 1;</div><div class=\"line\">            &#125;else&#123;</div><div class=\"line\">                return n * permutation(n - 1, r - 1);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int countnumberswithuniquedigits(int n) &#123;</div><div class=\"line\">            int sum = 1;</div><div class=\"line\">            if(n &gt; 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">            int end = (n &gt; 10)? 10 : n;</div><div class=\"line\">            for(int i = 0; i &lt; end; i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                sum += 9 * permutation(9, i);</div><div class=\"line\">            &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return sum;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a non-negative integer n, count all numbers with unique digits, x, where 0  x &lt; 10n.</p>\n<p>Example:<br>Given n = 2, return 91. (The answer should be the total numbers in the range of 0  x &lt; 100, excluding [11,22,33,44,55,66,77,88,99])</p>\n<p>Hint:</p>\n<ul>\n<li>A direct way is to use the backtracking approach.</li>\n<li>Backtracking should contains three states which are (the current number, number of steps to get that number and a bitmask which represent which number is marked as visited so far in the current number). Start with state (0,0,0) and count all valid number till we reach number of steps equals to 10n.</li>\n<li>This problem can also be solved using a dynamic programming approach and some knowledge of combinatorics.</li>\n<li>Let f(k) = count of numbers with unique digits with length equals k.</li>\n<li>f(1) = 10, , f(k) = 9 <em> 9 </em> 8 *  (9 - k + 2) [The first factor is 9 because a number cannot start with 0].</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.357. It is a common DP problem using backtracking.</p>\n<p>My solution is following.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int permutation(int n, int r)</div><div class=\"line\">        &#123;</div><div class=\"line\">            if(r == 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">                return 1;</div><div class=\"line\">            &#125;else&#123;</div><div class=\"line\">                return n * permutation(n - 1, r - 1);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int countnumberswithuniquedigits(int n) &#123;</div><div class=\"line\">            int sum = 1;</div><div class=\"line\">            if(n &gt; 0)</div><div class=\"line\">            &#123;</div><div class=\"line\">            int end = (n &gt; 10)? 10 : n;</div><div class=\"line\">            for(int i = 0; i &lt; end; i++)</div><div class=\"line\">            &#123;</div><div class=\"line\">                sum += 9 * permutation(9, i);</div><div class=\"line\">            &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return sum;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Diagonal Traverse","date":"2017-02-10T01:50:41.000Z","_content":"\n> Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n>\n> Example:\n> + Input:\n> ```\n[\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ],\n    [ 7, 8, 9 ]\n]\n```\n> + Output:  [1,2,4,7,5,3,6,8,9]\n>\n> Note:\n> + The total number of elements of the given matrix will not exceed 10,000.\n\n<!--more-->\n\nIt is Leetcode 498, and it is not such a problem which needs too much think.\n\nSo, here comes the result:\n\n```\nclass Solution {\n    public:\n        vector<int> findDiagonalOrder(vector<vector<int> >& matrix) {\n            vector<int> res;\n            if (matrix.size() == 0 || matrix[0].size() == 0) {\n                return res;\n            }\n\n            int X = matrix.size();\n            int Y = matrix[0].size();\n\n            for (int level = 0; level < X + Y - 1; level++) {\n                std::cout << level << std::endl;\n                if (level % 2 == 0) {\n                    for (int idy = 0; idy <= min(level, Y); idy++) {\n                        if (level - idy < X && level - idy >= 0 && idy < Y) {\n                            std::cout << level - idy << ':' << idy << std::endl;\n                            res.push_back(matrix[level - idy][idy]);\n                        }\n                    }\n                } else {\n                    for (int idx = 0; idx <= min(level, X); idx++) {\n                        if (level - idx < Y && level - idx >= 0 && idx < X) {\n                            std::cout << idx << ':' << level - idx << std::endl;\n                            res.push_back(matrix[idx][level - idx]);\n                        }\n                    }\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/DiagonalTraverse.md","raw":"---\ntitle: Diagonal Traverse\ndate: 2017-02-10 09:50:41\ntags:\n    - Array\n---\n\n> Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n>\n> Example:\n> + Input:\n> ```\n[\n    [ 1, 2, 3 ],\n    [ 4, 5, 6 ],\n    [ 7, 8, 9 ]\n]\n```\n> + Output:  [1,2,4,7,5,3,6,8,9]\n>\n> Note:\n> + The total number of elements of the given matrix will not exceed 10,000.\n\n<!--more-->\n\nIt is Leetcode 498, and it is not such a problem which needs too much think.\n\nSo, here comes the result:\n\n```\nclass Solution {\n    public:\n        vector<int> findDiagonalOrder(vector<vector<int> >& matrix) {\n            vector<int> res;\n            if (matrix.size() == 0 || matrix[0].size() == 0) {\n                return res;\n            }\n\n            int X = matrix.size();\n            int Y = matrix[0].size();\n\n            for (int level = 0; level < X + Y - 1; level++) {\n                std::cout << level << std::endl;\n                if (level % 2 == 0) {\n                    for (int idy = 0; idy <= min(level, Y); idy++) {\n                        if (level - idy < X && level - idy >= 0 && idy < Y) {\n                            std::cout << level - idy << ':' << idy << std::endl;\n                            res.push_back(matrix[level - idy][idy]);\n                        }\n                    }\n                } else {\n                    for (int idx = 0; idx <= min(level, X); idx++) {\n                        if (level - idx < Y && level - idx >= 0 && idx < X) {\n                            std::cout << idx << ':' << level - idx << std::endl;\n                            res.push_back(matrix[idx][level - idx]);\n                        }\n                    }\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"DiagonalTraverse","published":1,"updated":"2017-02-14T07:02:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatva0012g5f400bq9772","content":"<blockquote>\n<p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p>\n<p>Example:</p>\n<ul>\n<li><p>Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [ 1, 2, 3 ],</div><div class=\"line\">    [ 4, 5, 6 ],</div><div class=\"line\">    [ 7, 8, 9 ]</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n<li><p>Output:  [1,2,4,7,5,3,6,8,9]</p>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The total number of elements of the given matrix will not exceed 10,000.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is Leetcode 498, and it is not such a problem which needs too much think.</p>\n<p>So, here comes the result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</div><div class=\"line\">                return res;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int X = matrix.size();</div><div class=\"line\">            int Y = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            for (int level = 0; level &lt; X + Y - 1; level++) &#123;</div><div class=\"line\">                std::cout &lt;&lt; level &lt;&lt; std::endl;</div><div class=\"line\">                if (level % 2 == 0) &#123;</div><div class=\"line\">                    for (int idy = 0; idy &lt;= min(level, Y); idy++) &#123;</div><div class=\"line\">                        if (level - idy &lt; X &amp;&amp; level - idy &gt;= 0 &amp;&amp; idy &lt; Y) &#123;</div><div class=\"line\">                            std::cout &lt;&lt; level - idy &lt;&lt; &apos;:&apos; &lt;&lt; idy &lt;&lt; std::endl;</div><div class=\"line\">                            res.push_back(matrix[level - idy][idy]);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    for (int idx = 0; idx &lt;= min(level, X); idx++) &#123;</div><div class=\"line\">                        if (level - idx &lt; Y &amp;&amp; level - idx &gt;= 0 &amp;&amp; idx &lt; X) &#123;</div><div class=\"line\">                            std::cout &lt;&lt; idx &lt;&lt; &apos;:&apos; &lt;&lt; level - idx &lt;&lt; std::endl;</div><div class=\"line\">                            res.push_back(matrix[idx][level - idx]);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.</p>\n<p>Example:</p>\n<ul>\n<li><p>Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [ 1, 2, 3 ],</div><div class=\"line\">    [ 4, 5, 6 ],</div><div class=\"line\">    [ 7, 8, 9 ]</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n</li>\n<li><p>Output:  [1,2,4,7,5,3,6,8,9]</p>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The total number of elements of the given matrix will not exceed 10,000.</li>\n</ul>\n</blockquote>","more":"<p>It is Leetcode 498, and it is not such a problem which needs too much think.</p>\n<p>So, here comes the result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</div><div class=\"line\">                return res;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int X = matrix.size();</div><div class=\"line\">            int Y = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            for (int level = 0; level &lt; X + Y - 1; level++) &#123;</div><div class=\"line\">                std::cout &lt;&lt; level &lt;&lt; std::endl;</div><div class=\"line\">                if (level % 2 == 0) &#123;</div><div class=\"line\">                    for (int idy = 0; idy &lt;= min(level, Y); idy++) &#123;</div><div class=\"line\">                        if (level - idy &lt; X &amp;&amp; level - idy &gt;= 0 &amp;&amp; idy &lt; Y) &#123;</div><div class=\"line\">                            std::cout &lt;&lt; level - idy &lt;&lt; &apos;:&apos; &lt;&lt; idy &lt;&lt; std::endl;</div><div class=\"line\">                            res.push_back(matrix[level - idy][idy]);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    for (int idx = 0; idx &lt;= min(level, X); idx++) &#123;</div><div class=\"line\">                        if (level - idx &lt; Y &amp;&amp; level - idx &gt;= 0 &amp;&amp; idx &lt; X) &#123;</div><div class=\"line\">                            std::cout &lt;&lt; idx &lt;&lt; &apos;:&apos; &lt;&lt; level - idx &lt;&lt; std::endl;</div><div class=\"line\">                            res.push_back(matrix[idx][level - idx]);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Find Mode in Binary Search Tree","date":"2017-02-01T15:59:43.000Z","_content":"\n> Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\n>\n> Assume a BST is defined as follows:\n>\n> + The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n> + The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n> + Both the left and right subtrees must also be binary search trees.\n>\n> For example:\n> + Given BST [1,null,2,2],\n> + return [2].\n>\n> Note: If a tree has more than one mode, you can return them in any order.\n>\n> Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n<!--more-->\n\nThis is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.\n\nSo, here comes the answer:\n\n```\nclass Solution {\n    public:\n        map<int, int> nodes;\n\n        vector<int> findMode(TreeNode* root) {\n            nodes.clear();\n\n            _preOrder(root);\n\n            int times = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > times) {\n                    times = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == times) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        void _preOrder(TreeNode* node) {\n            if (node == NULL) {\n                return;\n            }\n            _visit(node);\n            _preOrder(node->left);\n            _preOrder(node->right);\n        }\n\n        void _visit(TreeNode* node) {\n            if (nodes.find(node->val) == nodes.end()) {\n                nodes.insert(pair<int, int>(node->val, 1));\n            } else {\n                nodes.find(node->val)->second++;\n            }\n        }\n};\n```\n\n**Follow up:**\n\nIt's easy to improve the code. Because we can use the BST feature, we can know the current node's value how many times.\n\nNot now for the result.\n\n\n","source":"_posts/FindModeinBinarySearchTree.md","raw":"---\ntitle: Find Mode in Binary Search Tree\ndate: 2017-02-01 23:59:43\ntags:\n    - Tree\n---\n\n> Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\n>\n> Assume a BST is defined as follows:\n>\n> + The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n> + The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n> + Both the left and right subtrees must also be binary search trees.\n>\n> For example:\n> + Given BST [1,null,2,2],\n> + return [2].\n>\n> Note: If a tree has more than one mode, you can return them in any order.\n>\n> Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).\n\n<!--more-->\n\nThis is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.\n\nSo, here comes the answer:\n\n```\nclass Solution {\n    public:\n        map<int, int> nodes;\n\n        vector<int> findMode(TreeNode* root) {\n            nodes.clear();\n\n            _preOrder(root);\n\n            int times = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > times) {\n                    times = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == times) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        void _preOrder(TreeNode* node) {\n            if (node == NULL) {\n                return;\n            }\n            _visit(node);\n            _preOrder(node->left);\n            _preOrder(node->right);\n        }\n\n        void _visit(TreeNode* node) {\n            if (nodes.find(node->val) == nodes.end()) {\n                nodes.insert(pair<int, int>(node->val, 1));\n            } else {\n                nodes.find(node->val)->second++;\n            }\n        }\n};\n```\n\n**Follow up:**\n\nIt's easy to improve the code. Because we can use the BST feature, we can know the current node's value how many times.\n\nNot now for the result.\n\n\n","slug":"FindModeinBinarySearchTree","published":1,"updated":"2017-02-01T16:15:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvb0014g5f4hnsnd0oo","content":"<blockquote>\n<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>\n<p>Assume a BST is defined as follows:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys less than or equal to the nodes key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than or equal to the nodes key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<p>For example:</p>\n<ul>\n<li>Given BST [1,null,2,2],</li>\n<li>return [2].</li>\n</ul>\n<p>Note: If a tree has more than one mode, you can return them in any order.</p>\n<p>Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.</p>\n<p>So, here comes the answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        map&lt;int, int&gt; nodes;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; findMode(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\"></div><div class=\"line\">            _preOrder(root);</div><div class=\"line\"></div><div class=\"line\">            int times = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; times) &#123;</div><div class=\"line\">                    times = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == times) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode* node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(node);</div><div class=\"line\">            _preOrder(node-&gt;left);</div><div class=\"line\">            _preOrder(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode* node) &#123;</div><div class=\"line\">            if (nodes.find(node-&gt;val) == nodes.end()) &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(node-&gt;val, 1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.find(node-&gt;val)-&gt;second++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>Follow up:</strong></p>\n<p>Its easy to improve the code. Because we can use the BST feature, we can know the current nodes value how many times.</p>\n<p>Not now for the result.</p>\n","excerpt":"<blockquote>\n<p>Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.</p>\n<p>Assume a BST is defined as follows:</p>\n<ul>\n<li>The left subtree of a node contains only nodes with keys less than or equal to the nodes key.</li>\n<li>The right subtree of a node contains only nodes with keys greater than or equal to the nodes key.</li>\n<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n<p>For example:</p>\n<ul>\n<li>Given BST [1,null,2,2],</li>\n<li>return [2].</li>\n</ul>\n<p>Note: If a tree has more than one mode, you can return them in any order.</p>\n<p>Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).</p>\n</blockquote>","more":"<p>This is Leetcode 501. And it is a easy one. You can just use pre-order visit the tree and store the value and its appearances. Return the max times.</p>\n<p>So, here comes the answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        map&lt;int, int&gt; nodes;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; findMode(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\"></div><div class=\"line\">            _preOrder(root);</div><div class=\"line\"></div><div class=\"line\">            int times = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; times) &#123;</div><div class=\"line\">                    times = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == times) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode* node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(node);</div><div class=\"line\">            _preOrder(node-&gt;left);</div><div class=\"line\">            _preOrder(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode* node) &#123;</div><div class=\"line\">            if (nodes.find(node-&gt;val) == nodes.end()) &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(node-&gt;val, 1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.find(node-&gt;val)-&gt;second++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p><strong>Follow up:</strong></p>\n<p>Its easy to improve the code. Because we can use the BST feature, we can know the current nodes value how many times.</p>\n<p>Not now for the result.</p>"},{"title":"Evaluate Reverse Polish Notation","date":"2017-03-26T15:31:45.000Z","_content":"\n> Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n>\n> Valid operators are +, -, *, /. Each operand may be an integer or another expression.\n>\n> Some examples:\n>```\n[\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\n[\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6\n```\n<!--more-->\n\nThis is Leetcode No.150. It is a common problem which using stacks.\n\nWe just need to put every number into a stack and poll them out when we meet other signal for instance: '+', '-' .etc.\n\nSo, my solution is as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int evalRPN(vector<string>& tokens) {\n            if (tokens.size() == 0) {\n                return 0;\n            } else if (tokens.size() == 1) {\n                return atoi(tokens[0].c_str());\n            }\n\n            stack<int> nums;\n            int result = 0;\n\n            for (auto token : tokens) {\n                if (token == \"-\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre - post;\n                    nums.push(result);\n                } else if (token == \"+\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre + post;\n                    nums.push(result);\n                } else if (token == \"*\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre * post;\n                    nums.push(result);\n                } else if (token == \"/\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre / post;\n                    nums.push(result);\n                } else {\n                    int num = atoi(token.c_str());\n                    nums.push(num);\n                }\n            }\n\n            return result;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/EvaluateReversePolishNotation.md","raw":"---\ntitle: Evaluate Reverse Polish Notation\ndate: 2017-03-26 23:31:45\ntags:\n    - Stack\n---\n\n> Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n>\n> Valid operators are +, -, *, /. Each operand may be an integer or another expression.\n>\n> Some examples:\n>```\n[\"2\", \"1\", \"+\", \"3\", \"*\"] -> ((2 + 1) * 3) -> 9\n[\"4\", \"13\", \"5\", \"/\", \"+\"] -> (4 + (13 / 5)) -> 6\n```\n<!--more-->\n\nThis is Leetcode No.150. It is a common problem which using stacks.\n\nWe just need to put every number into a stack and poll them out when we meet other signal for instance: '+', '-' .etc.\n\nSo, my solution is as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int evalRPN(vector<string>& tokens) {\n            if (tokens.size() == 0) {\n                return 0;\n            } else if (tokens.size() == 1) {\n                return atoi(tokens[0].c_str());\n            }\n\n            stack<int> nums;\n            int result = 0;\n\n            for (auto token : tokens) {\n                if (token == \"-\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre - post;\n                    nums.push(result);\n                } else if (token == \"+\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre + post;\n                    nums.push(result);\n                } else if (token == \"*\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre * post;\n                    nums.push(result);\n                } else if (token == \"/\") {\n                    int post = nums.top();\n                    nums.pop();\n                    int pre = nums.top();\n                    nums.pop();\n                    result = pre / post;\n                    nums.push(result);\n                } else {\n                    int num = atoi(token.c_str());\n                    nums.push(num);\n                }\n            }\n\n            return result;\n        }\n};\n```\n\nIt gets AC.\n","slug":"EvaluateReversePolishNotation","published":1,"updated":"2017-03-26T15:54:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvc0017g5f4rt7fprr0","content":"<blockquote>\n<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>\n<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>\n<p>Some examples:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9</div><div class=\"line\">[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6</div></pre></td></tr></table></figure></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.150. It is a common problem which using stacks.</p>\n<p>We just need to put every number into a stack and poll them out when we meet other signal for instance: +, - .etc.</p>\n<p>So, my solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</div><div class=\"line\">            if (tokens.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if (tokens.size() == 1) &#123;</div><div class=\"line\">                return atoi(tokens[0].c_str());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            stack&lt;int&gt; nums;</div><div class=\"line\">            int result = 0;</div><div class=\"line\"></div><div class=\"line\">            for (auto token : tokens) &#123;</div><div class=\"line\">                if (token == &quot;-&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre - post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else if (token == &quot;+&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre + post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else if (token == &quot;*&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre * post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else if (token == &quot;/&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre / post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    int num = atoi(token.c_str());</div><div class=\"line\">                    nums.push(num);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>\n<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>\n<p>Some examples:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9</div><div class=\"line\">[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6</div></pre></td></tr></table></figure></p>\n</blockquote>","more":"<p>This is Leetcode No.150. It is a common problem which using stacks.</p>\n<p>We just need to put every number into a stack and poll them out when we meet other signal for instance: +, - .etc.</p>\n<p>So, my solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</div><div class=\"line\">            if (tokens.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if (tokens.size() == 1) &#123;</div><div class=\"line\">                return atoi(tokens[0].c_str());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            stack&lt;int&gt; nums;</div><div class=\"line\">            int result = 0;</div><div class=\"line\"></div><div class=\"line\">            for (auto token : tokens) &#123;</div><div class=\"line\">                if (token == &quot;-&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre - post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else if (token == &quot;+&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre + post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else if (token == &quot;*&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre * post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else if (token == &quot;/&quot;) &#123;</div><div class=\"line\">                    int post = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    int pre = nums.top();</div><div class=\"line\">                    nums.pop();</div><div class=\"line\">                    result = pre / post;</div><div class=\"line\">                    nums.push(result);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    int num = atoi(token.c_str());</div><div class=\"line\">                    nums.push(num);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Encode and Decode Tiny URL","date":"2017-03-04T12:30:08.000Z","_content":"\n> TinyURL is a URL shortening service where you enter a URL such as `https://leetcode.com/problems/design-tinyurl` and it returns a short URL such as `http://tinyurl.com/4e9iAk`.\n>\n> Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n>\n> Note: Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\n\n<!--more-->\n\nThis is Leetcode No.535. This is a open-mind problem. You can just use the following code to AC:\n\n```\nclass Solution {\n    public:\n        string encode(string longUrl) {\n            return longUrl;\n        }\n\n        string decode(string shortUrl) {\n            return shortUrl;\n        }\n};\n```\n\nHowever, this is not a good solution. You can remember the Hamming code. But here we don't use the function.\n\nSo, I use this code to AC. But it is still not a good solution. I will write a blog to discuss this problem.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        map<string, string> urls;\n\n        string hash(string url) {\n            long long hash  = 0;\n            for (int i = 0; i < (int)url.length(); i++) {\n                hash = hash * 10 + url[i];\n            }\n            return to_string(hash);\n        }\n\n        string encode(string longUrl) {\n            string key = hash(longUrl);\n            urls.insert(pair<string, string>(key, longUrl));\n            return key;\n        }\n\n        string decode(string shortUrl) {\n            return urls.find(shortUrl)->second;\n        }\n};\n\n```\n\nHere I just use a hash function to make sure every url returns a different hash code.\n","source":"_posts/EncodeandDecodeTinyURL.md","raw":"---\ntitle: Encode and Decode Tiny URL\ndate: 2017-03-04 20:30:08\ntags:\n    - String\n---\n\n> TinyURL is a URL shortening service where you enter a URL such as `https://leetcode.com/problems/design-tinyurl` and it returns a short URL such as `http://tinyurl.com/4e9iAk`.\n>\n> Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n>\n> Note: Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\n\n<!--more-->\n\nThis is Leetcode No.535. This is a open-mind problem. You can just use the following code to AC:\n\n```\nclass Solution {\n    public:\n        string encode(string longUrl) {\n            return longUrl;\n        }\n\n        string decode(string shortUrl) {\n            return shortUrl;\n        }\n};\n```\n\nHowever, this is not a good solution. You can remember the Hamming code. But here we don't use the function.\n\nSo, I use this code to AC. But it is still not a good solution. I will write a blog to discuss this problem.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        map<string, string> urls;\n\n        string hash(string url) {\n            long long hash  = 0;\n            for (int i = 0; i < (int)url.length(); i++) {\n                hash = hash * 10 + url[i];\n            }\n            return to_string(hash);\n        }\n\n        string encode(string longUrl) {\n            string key = hash(longUrl);\n            urls.insert(pair<string, string>(key, longUrl));\n            return key;\n        }\n\n        string decode(string shortUrl) {\n            return urls.find(shortUrl)->second;\n        }\n};\n\n```\n\nHere I just use a hash function to make sure every url returns a different hash code.\n","slug":"EncodeandDecodeTinyURL","published":1,"updated":"2017-03-04T13:00:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvd0019g5f4zvysltfm","content":"<blockquote>\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.</p>\n<p>Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\n<p>Note: Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.535. This is a open-mind problem. You can just use the following code to AC:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string encode(string longUrl) &#123;</div><div class=\"line\">            return longUrl;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        string decode(string shortUrl) &#123;</div><div class=\"line\">            return shortUrl;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, this is not a good solution. You can remember the Hamming code. But here we dont use the function.</p>\n<p>So, I use this code to AC. But it is still not a good solution. I will write a blog to discuss this problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        map&lt;string, string&gt; urls;</div><div class=\"line\"></div><div class=\"line\">        string hash(string url) &#123;</div><div class=\"line\">            long long hash  = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)url.length(); i++) &#123;</div><div class=\"line\">                hash = hash * 10 + url[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return to_string(hash);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        string encode(string longUrl) &#123;</div><div class=\"line\">            string key = hash(longUrl);</div><div class=\"line\">            urls.insert(pair&lt;string, string&gt;(key, longUrl));</div><div class=\"line\">            return key;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        string decode(string shortUrl) &#123;</div><div class=\"line\">            return urls.find(shortUrl)-&gt;second;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here I just use a hash function to make sure every url returns a different hash code.</p>\n","excerpt":"<blockquote>\n<p>TinyURL is a URL shortening service where you enter a URL such as <code>https://leetcode.com/problems/design-tinyurl</code> and it returns a short URL such as <code>http://tinyurl.com/4e9iAk</code>.</p>\n<p>Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</p>\n<p>Note: Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.</p>\n</blockquote>","more":"<p>This is Leetcode No.535. This is a open-mind problem. You can just use the following code to AC:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string encode(string longUrl) &#123;</div><div class=\"line\">            return longUrl;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        string decode(string shortUrl) &#123;</div><div class=\"line\">            return shortUrl;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, this is not a good solution. You can remember the Hamming code. But here we dont use the function.</p>\n<p>So, I use this code to AC. But it is still not a good solution. I will write a blog to discuss this problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        map&lt;string, string&gt; urls;</div><div class=\"line\"></div><div class=\"line\">        string hash(string url) &#123;</div><div class=\"line\">            long long hash  = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)url.length(); i++) &#123;</div><div class=\"line\">                hash = hash * 10 + url[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return to_string(hash);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        string encode(string longUrl) &#123;</div><div class=\"line\">            string key = hash(longUrl);</div><div class=\"line\">            urls.insert(pair&lt;string, string&gt;(key, longUrl));</div><div class=\"line\">            return key;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        string decode(string shortUrl) &#123;</div><div class=\"line\">            return urls.find(shortUrl)-&gt;second;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here I just use a hash function to make sure every url returns a different hash code.</p>"},{"title":"Find Largest Element in Each Row","date":"2017-02-12T04:27:38.000Z","_content":"\n> You need to find the largest value in each row of a binary tree.\n>\n> Example:\n>\n> Input:\n>```\n    1\n   / \\\n  3   2\n / \\   \\ \n5   3   9\n```\n> Output: [1, 3, 9]\n\n<!--more-->\n\nIt is one of Leetcode Weekly Contest 19, and also No.515. This is an easy problem.\n\nWhat we need to do is to level-order visit and find the largest value for each level.\n\nSo, here is my solution:\n\n```\nclass Solution {\n    public:\n        vector<int> findValueMostElement(TreeNode* root) {\n            vector<int> res;\n            if (root == NULL) {\n                return res;\n            }\n            map<int, int> levelValues;\n            int level = 0;\n            list<TreeNode> level1, level2;\n            level1.push_back(*root);\n\n            while (level1.size() > 0 || level2.size() > 0) {\n                if (level % 2 == 0) {\n                    while (level1.size() > 0) {\n                        TreeNode currentNode = level1.front();\n                        if (currentNode.left != NULL) {\n                            level2.push_back(*currentNode.left);\n                        }\n                        if (currentNode.right != NULL) {\n                            level2.push_back(*currentNode.right);\n                        }\n                        if (levelValues.find(level) != levelValues.end()) {\n                            if (currentNode.val > levelValues.find(level)->second) {\n                                levelValues.find(level)->second = currentNode.val;\n                            }\n                        } else {\n                            levelValues.insert(pair<int, int>(level, currentNode.val));\n                        }\n                        level1.pop_front();\n                    }\n                    level++;\n                } else {\n                    while (level2.size() > 0) {\n                        TreeNode currentNode = level2.front();\n                        if (currentNode.left != NULL) {\n                            level1.push_back(*currentNode.left);\n                        }\n                        if (currentNode.right != NULL) {\n                            level1.push_back(*currentNode.right);\n                        }\n                        if (levelValues.find(level) != levelValues.end()) {\n                            if (currentNode.val > levelValues.find(level)->second) {\n                                levelValues.find(level)->second = currentNode.val;\n                            }\n                        } else {\n                            levelValues.insert(pair<int, int>(level, currentNode.val));\n                        }\n                        level2.pop_front();\n                    }\n                    level++;\n                }\n            }\n\n            for (auto i : levelValues) {\n                res.push_back(i.second);\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/FindLargestElementinEachRow.md","raw":"---\ntitle: Find Largest Element in Each Row\ndate: 2017-02-12 12:27:38\ntags:\n    - Tree\n    - Hash Table\n---\n\n> You need to find the largest value in each row of a binary tree.\n>\n> Example:\n>\n> Input:\n>```\n    1\n   / \\\n  3   2\n / \\   \\ \n5   3   9\n```\n> Output: [1, 3, 9]\n\n<!--more-->\n\nIt is one of Leetcode Weekly Contest 19, and also No.515. This is an easy problem.\n\nWhat we need to do is to level-order visit and find the largest value for each level.\n\nSo, here is my solution:\n\n```\nclass Solution {\n    public:\n        vector<int> findValueMostElement(TreeNode* root) {\n            vector<int> res;\n            if (root == NULL) {\n                return res;\n            }\n            map<int, int> levelValues;\n            int level = 0;\n            list<TreeNode> level1, level2;\n            level1.push_back(*root);\n\n            while (level1.size() > 0 || level2.size() > 0) {\n                if (level % 2 == 0) {\n                    while (level1.size() > 0) {\n                        TreeNode currentNode = level1.front();\n                        if (currentNode.left != NULL) {\n                            level2.push_back(*currentNode.left);\n                        }\n                        if (currentNode.right != NULL) {\n                            level2.push_back(*currentNode.right);\n                        }\n                        if (levelValues.find(level) != levelValues.end()) {\n                            if (currentNode.val > levelValues.find(level)->second) {\n                                levelValues.find(level)->second = currentNode.val;\n                            }\n                        } else {\n                            levelValues.insert(pair<int, int>(level, currentNode.val));\n                        }\n                        level1.pop_front();\n                    }\n                    level++;\n                } else {\n                    while (level2.size() > 0) {\n                        TreeNode currentNode = level2.front();\n                        if (currentNode.left != NULL) {\n                            level1.push_back(*currentNode.left);\n                        }\n                        if (currentNode.right != NULL) {\n                            level1.push_back(*currentNode.right);\n                        }\n                        if (levelValues.find(level) != levelValues.end()) {\n                            if (currentNode.val > levelValues.find(level)->second) {\n                                levelValues.find(level)->second = currentNode.val;\n                            }\n                        } else {\n                            levelValues.insert(pair<int, int>(level, currentNode.val));\n                        }\n                        level2.pop_front();\n                    }\n                    level++;\n                }\n            }\n\n            for (auto i : levelValues) {\n                res.push_back(i.second);\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"FindLargestElementinEachRow","published":1,"updated":"2017-02-15T06:48:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvf001bg5f4m26ligf3","content":"<blockquote>\n<p>You need to find the largest value in each row of a binary tree.</p>\n<p>Example:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    1</div><div class=\"line\">   / \\</div><div class=\"line\">  3   2</div><div class=\"line\"> / \\   \\ </div><div class=\"line\">5   3   9</div></pre></td></tr></table></figure></p>\n<p>Output: [1, 3, 9]</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is one of Leetcode Weekly Contest 19, and also No.515. This is an easy problem.</p>\n<p>What we need to do is to level-order visit and find the largest value for each level.</p>\n<p>So, here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findValueMostElement(TreeNode* root) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return res;</div><div class=\"line\">            &#125;</div><div class=\"line\">            map&lt;int, int&gt; levelValues;</div><div class=\"line\">            int level = 0;</div><div class=\"line\">            list&lt;TreeNode&gt; level1, level2;</div><div class=\"line\">            level1.push_back(*root);</div><div class=\"line\"></div><div class=\"line\">            while (level1.size() &gt; 0 || level2.size() &gt; 0) &#123;</div><div class=\"line\">                if (level % 2 == 0) &#123;</div><div class=\"line\">                    while (level1.size() &gt; 0) &#123;</div><div class=\"line\">                        TreeNode currentNode = level1.front();</div><div class=\"line\">                        if (currentNode.left != NULL) &#123;</div><div class=\"line\">                            level2.push_back(*currentNode.left);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentNode.right != NULL) &#123;</div><div class=\"line\">                            level2.push_back(*currentNode.right);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (levelValues.find(level) != levelValues.end()) &#123;</div><div class=\"line\">                            if (currentNode.val &gt; levelValues.find(level)-&gt;second) &#123;</div><div class=\"line\">                                levelValues.find(level)-&gt;second = currentNode.val;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            levelValues.insert(pair&lt;int, int&gt;(level, currentNode.val));</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        level1.pop_front();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    level++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    while (level2.size() &gt; 0) &#123;</div><div class=\"line\">                        TreeNode currentNode = level2.front();</div><div class=\"line\">                        if (currentNode.left != NULL) &#123;</div><div class=\"line\">                            level1.push_back(*currentNode.left);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentNode.right != NULL) &#123;</div><div class=\"line\">                            level1.push_back(*currentNode.right);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (levelValues.find(level) != levelValues.end()) &#123;</div><div class=\"line\">                            if (currentNode.val &gt; levelValues.find(level)-&gt;second) &#123;</div><div class=\"line\">                                levelValues.find(level)-&gt;second = currentNode.val;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            levelValues.insert(pair&lt;int, int&gt;(level, currentNode.val));</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        level2.pop_front();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    level++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (auto i : levelValues) &#123;</div><div class=\"line\">                res.push_back(i.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>You need to find the largest value in each row of a binary tree.</p>\n<p>Example:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    1</div><div class=\"line\">   / \\</div><div class=\"line\">  3   2</div><div class=\"line\"> / \\   \\ </div><div class=\"line\">5   3   9</div></pre></td></tr></table></figure></p>\n<p>Output: [1, 3, 9]</p>\n</blockquote>","more":"<p>It is one of Leetcode Weekly Contest 19, and also No.515. This is an easy problem.</p>\n<p>What we need to do is to level-order visit and find the largest value for each level.</p>\n<p>So, here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findValueMostElement(TreeNode* root) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return res;</div><div class=\"line\">            &#125;</div><div class=\"line\">            map&lt;int, int&gt; levelValues;</div><div class=\"line\">            int level = 0;</div><div class=\"line\">            list&lt;TreeNode&gt; level1, level2;</div><div class=\"line\">            level1.push_back(*root);</div><div class=\"line\"></div><div class=\"line\">            while (level1.size() &gt; 0 || level2.size() &gt; 0) &#123;</div><div class=\"line\">                if (level % 2 == 0) &#123;</div><div class=\"line\">                    while (level1.size() &gt; 0) &#123;</div><div class=\"line\">                        TreeNode currentNode = level1.front();</div><div class=\"line\">                        if (currentNode.left != NULL) &#123;</div><div class=\"line\">                            level2.push_back(*currentNode.left);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentNode.right != NULL) &#123;</div><div class=\"line\">                            level2.push_back(*currentNode.right);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (levelValues.find(level) != levelValues.end()) &#123;</div><div class=\"line\">                            if (currentNode.val &gt; levelValues.find(level)-&gt;second) &#123;</div><div class=\"line\">                                levelValues.find(level)-&gt;second = currentNode.val;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            levelValues.insert(pair&lt;int, int&gt;(level, currentNode.val));</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        level1.pop_front();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    level++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    while (level2.size() &gt; 0) &#123;</div><div class=\"line\">                        TreeNode currentNode = level2.front();</div><div class=\"line\">                        if (currentNode.left != NULL) &#123;</div><div class=\"line\">                            level1.push_back(*currentNode.left);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (currentNode.right != NULL) &#123;</div><div class=\"line\">                            level1.push_back(*currentNode.right);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (levelValues.find(level) != levelValues.end()) &#123;</div><div class=\"line\">                            if (currentNode.val &gt; levelValues.find(level)-&gt;second) &#123;</div><div class=\"line\">                                levelValues.find(level)-&gt;second = currentNode.val;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125; else &#123;</div><div class=\"line\">                            levelValues.insert(pair&lt;int, int&gt;(level, currentNode.val));</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        level2.pop_front();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    level++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (auto i : levelValues) &#123;</div><div class=\"line\">                res.push_back(i.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Find Left Most Element","date":"2017-02-12T04:12:49.000Z","_content":"\n> Given a binary tree, find the leftmost value in the last row of the tree.\n>\n> Example 1:\n>\n> Input:\n> ```\n  2\n / \\\n1   3\n```\n> Output: 1\n>\n> Example 2:\n>\n> Input:\n> ```\n    1\n   / \\\n  2   3\n /   / \\\n4   5   6\n   /\n  7\n```\n> Output: 7\n>\n> Note: You may assume the tree (i.e., the given root node) is not NULL.\n\n<!--more-->\n\nThis is one of the Leetcode Weekly contest 19, and also No.513. It is easy, you can use the preorder visit and find the max level one.\n\n```\nclass Solution {\n    public:\n        int maxLevel, res;\n        int findLeftMostNode(TreeNode* root) {\n            res = root->val;\n            maxLevel = 0;\n            _preOrder(root, 0);\n            return res;\n        }\n\n        void _preOrder(TreeNode* node, int level) {\n            if (node == NULL) {\n                return;\n            }\n            _preOrder(node->left, level + 1);\n            if (level > maxLevel) {\n                maxLevel = level;\n                res = node->val;\n            }\n            _preOrder(node->right, level + 1);\n\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/FindLeftMostElement.md","raw":"---\ntitle: Find Left Most Element\ndate: 2017-02-12 12:12:49\ntags:\n    - Tree\n---\n\n> Given a binary tree, find the leftmost value in the last row of the tree.\n>\n> Example 1:\n>\n> Input:\n> ```\n  2\n / \\\n1   3\n```\n> Output: 1\n>\n> Example 2:\n>\n> Input:\n> ```\n    1\n   / \\\n  2   3\n /   / \\\n4   5   6\n   /\n  7\n```\n> Output: 7\n>\n> Note: You may assume the tree (i.e., the given root node) is not NULL.\n\n<!--more-->\n\nThis is one of the Leetcode Weekly contest 19, and also No.513. It is easy, you can use the preorder visit and find the max level one.\n\n```\nclass Solution {\n    public:\n        int maxLevel, res;\n        int findLeftMostNode(TreeNode* root) {\n            res = root->val;\n            maxLevel = 0;\n            _preOrder(root, 0);\n            return res;\n        }\n\n        void _preOrder(TreeNode* node, int level) {\n            if (node == NULL) {\n                return;\n            }\n            _preOrder(node->left, level + 1);\n            if (level > maxLevel) {\n                maxLevel = level;\n                res = node->val;\n            }\n            _preOrder(node->right, level + 1);\n\n        }\n};\n```\n\nIt gets AC.\n","slug":"FindLeftMostElement","published":1,"updated":"2017-02-14T07:03:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvg001eg5f4do3gmbo1","content":"<blockquote>\n<p>Given a binary tree, find the leftmost value in the last row of the tree.</p>\n<p>Example 1:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  2</div><div class=\"line\"> / \\</div><div class=\"line\">1   3</div></pre></td></tr></table></figure></p>\n<p>Output: 1</p>\n<p>Example 2:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    1</div><div class=\"line\">   / \\</div><div class=\"line\">  2   3</div><div class=\"line\"> /   / \\</div><div class=\"line\">4   5   6</div><div class=\"line\">   /</div><div class=\"line\">  7</div></pre></td></tr></table></figure></p>\n<p>Output: 7</p>\n<p>Note: You may assume the tree (i.e., the given root node) is not NULL.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is one of the Leetcode Weekly contest 19, and also No.513. It is easy, you can use the preorder visit and find the max level one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxLevel, res;</div><div class=\"line\">        int findLeftMostNode(TreeNode* root) &#123;</div><div class=\"line\">            res = root-&gt;val;</div><div class=\"line\">            maxLevel = 0;</div><div class=\"line\">            _preOrder(root, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode* node, int level) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _preOrder(node-&gt;left, level + 1);</div><div class=\"line\">            if (level &gt; maxLevel) &#123;</div><div class=\"line\">                maxLevel = level;</div><div class=\"line\">                res = node-&gt;val;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _preOrder(node-&gt;right, level + 1);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary tree, find the leftmost value in the last row of the tree.</p>\n<p>Example 1:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  2</div><div class=\"line\"> / \\</div><div class=\"line\">1   3</div></pre></td></tr></table></figure></p>\n<p>Output: 1</p>\n<p>Example 2:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    1</div><div class=\"line\">   / \\</div><div class=\"line\">  2   3</div><div class=\"line\"> /   / \\</div><div class=\"line\">4   5   6</div><div class=\"line\">   /</div><div class=\"line\">  7</div></pre></td></tr></table></figure></p>\n<p>Output: 7</p>\n<p>Note: You may assume the tree (i.e., the given root node) is not NULL.</p>\n</blockquote>","more":"<p>This is one of the Leetcode Weekly contest 19, and also No.513. It is easy, you can use the preorder visit and find the max level one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxLevel, res;</div><div class=\"line\">        int findLeftMostNode(TreeNode* root) &#123;</div><div class=\"line\">            res = root-&gt;val;</div><div class=\"line\">            maxLevel = 0;</div><div class=\"line\">            _preOrder(root, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _preOrder(TreeNode* node, int level) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _preOrder(node-&gt;left, level + 1);</div><div class=\"line\">            if (level &gt; maxLevel) &#123;</div><div class=\"line\">                maxLevel = level;</div><div class=\"line\">                res = node-&gt;val;</div><div class=\"line\">            &#125;</div><div class=\"line\">            _preOrder(node-&gt;right, level + 1);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Group Anagrams","date":"2017-01-10T06:07:57.000Z","_content":"\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Return:\n> ```\n[\n    [\"ate\", \"eat\",\"tea\"],\n    [\"nat\",\"tan\"],\n    [\"bat\"]\n]\n```\n> Note: All inputs will be in lower-case.\n\n<!--more-->\n\nThis is Leetcode 49, what a easy problem. We can quickly figure out two method:\n\nThe first one is:\n> 1. choose one string as the standard one.\n> 2. for each to check if this one has the same chars as the standard.\n> 3. if same, than, mark it has been used, and store it to the result.\n\nThe time complex of this method is O(n^2*m), m is dependent on the length of the string. It's is not a fast method, but it uses the least memory.\n\nThe second one is to use the map or hash map to help.\n> 1. for each to count its structure. for example, tae can be descriped as '1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z'\n> 2. then make the key to the map and check each word which has the same structure.\n\nThe time copolex of this method is O(n*m).\n\nSo, I use the second one to write the result code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<string> > groupAnagrams(vector<string>& strs) {\n            vector<string> keys;\n            map<string, vector<string> > retMap;\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int chars[26] = {0};\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    chars[strs[i][j] - 'a']++;\n                }\n                string currentKey = \"\";\n                for (int j = 0; j < 26; j++) {\n                    currentKey = currentKey + (char)('0' + chars[j]);\n                    currentKey = currentKey + (char)('a' + j);\n                }\n\n                if (retMap.find(currentKey) != retMap.end()) {\n                    retMap[currentKey].push_back(strs[i]);\n                } else {\n                    vector<string> currentValue;\n                    currentValue.push_back(strs[i]);\n                    retMap.insert(pair<string, vector<string> >(currentKey, currentValue));\n                }\n            }\n\n            vector<vector<string> > res;\n            for (pair<string, vector<string> > values: retMap) {\n                res.push_back(values.second);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/GroupAnagrams.md","raw":"---\ntitle: Group Anagrams\ndate: 2017-01-10 14:07:57\ntags:\n    - Hash Table\n    - String\n---\n\n> Given an array of strings, group anagrams together.\n>\n> For example, given: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\n> Return:\n> ```\n[\n    [\"ate\", \"eat\",\"tea\"],\n    [\"nat\",\"tan\"],\n    [\"bat\"]\n]\n```\n> Note: All inputs will be in lower-case.\n\n<!--more-->\n\nThis is Leetcode 49, what a easy problem. We can quickly figure out two method:\n\nThe first one is:\n> 1. choose one string as the standard one.\n> 2. for each to check if this one has the same chars as the standard.\n> 3. if same, than, mark it has been used, and store it to the result.\n\nThe time complex of this method is O(n^2*m), m is dependent on the length of the string. It's is not a fast method, but it uses the least memory.\n\nThe second one is to use the map or hash map to help.\n> 1. for each to count its structure. for example, tae can be descriped as '1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z'\n> 2. then make the key to the map and check each word which has the same structure.\n\nThe time copolex of this method is O(n*m).\n\nSo, I use the second one to write the result code as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<vector<string> > groupAnagrams(vector<string>& strs) {\n            vector<string> keys;\n            map<string, vector<string> > retMap;\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int chars[26] = {0};\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    chars[strs[i][j] - 'a']++;\n                }\n                string currentKey = \"\";\n                for (int j = 0; j < 26; j++) {\n                    currentKey = currentKey + (char)('0' + chars[j]);\n                    currentKey = currentKey + (char)('a' + j);\n                }\n\n                if (retMap.find(currentKey) != retMap.end()) {\n                    retMap[currentKey].push_back(strs[i]);\n                } else {\n                    vector<string> currentValue;\n                    currentValue.push_back(strs[i]);\n                    retMap.insert(pair<string, vector<string> >(currentKey, currentValue));\n                }\n            }\n\n            vector<vector<string> > res;\n            for (pair<string, vector<string> > values: retMap) {\n                res.push_back(values.second);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"GroupAnagrams","published":1,"updated":"2017-02-14T07:04:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvi001gg5f4ljq8tu1b","content":"<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [eat, tea, tan, ate, nat, bat],<br>Return:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class=\"line\">    [&quot;nat&quot;,&quot;tan&quot;],</div><div class=\"line\">    [&quot;bat&quot;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Note: All inputs will be in lower-case.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 49, what a easy problem. We can quickly figure out two method:</p>\n<p>The first one is:</p>\n<blockquote>\n<ol>\n<li>choose one string as the standard one.</li>\n<li>for each to check if this one has the same chars as the standard.</li>\n<li>if same, than, mark it has been used, and store it to the result.</li>\n</ol>\n</blockquote>\n<p>The time complex of this method is O(n^2*m), m is dependent on the length of the string. Its is not a fast method, but it uses the least memory.</p>\n<p>The second one is to use the map or hash map to help.</p>\n<blockquote>\n<ol>\n<li>for each to count its structure. for example, tae can be descriped as 1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z</li>\n<li>then make the key to the map and check each word which has the same structure.</li>\n</ol>\n</blockquote>\n<p>The time copolex of this method is O(n*m).</p>\n<p>So, I use the second one to write the result code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;string&gt; &gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class=\"line\">            vector&lt;string&gt; keys;</div><div class=\"line\">            map&lt;string, vector&lt;string&gt; &gt; retMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int chars[26] = &#123;0&#125;;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    chars[strs[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                string currentKey = &quot;&quot;;</div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;0&apos; + chars[j]);</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;a&apos; + j);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (retMap.find(currentKey) != retMap.end()) &#123;</div><div class=\"line\">                    retMap[currentKey].push_back(strs[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    vector&lt;string&gt; currentValue;</div><div class=\"line\">                    currentValue.push_back(strs[i]);</div><div class=\"line\">                    retMap.insert(pair&lt;string, vector&lt;string&gt; &gt;(currentKey, currentValue));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;string&gt; &gt; res;</div><div class=\"line\">            for (pair&lt;string, vector&lt;string&gt; &gt; values: retMap) &#123;</div><div class=\"line\">                res.push_back(values.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of strings, group anagrams together.</p>\n<p>For example, given: [eat, tea, tan, ate, nat, bat],<br>Return:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],</div><div class=\"line\">    [&quot;nat&quot;,&quot;tan&quot;],</div><div class=\"line\">    [&quot;bat&quot;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Note: All inputs will be in lower-case.</p>\n</blockquote>","more":"<p>This is Leetcode 49, what a easy problem. We can quickly figure out two method:</p>\n<p>The first one is:</p>\n<blockquote>\n<ol>\n<li>choose one string as the standard one.</li>\n<li>for each to check if this one has the same chars as the standard.</li>\n<li>if same, than, mark it has been used, and store it to the result.</li>\n</ol>\n</blockquote>\n<p>The time complex of this method is O(n^2*m), m is dependent on the length of the string. Its is not a fast method, but it uses the least memory.</p>\n<p>The second one is to use the map or hash map to help.</p>\n<blockquote>\n<ol>\n<li>for each to count its structure. for example, tae can be descriped as 1a0b0c0d1e0f0g0h0i0j0k0l0m0n0o0p0q0r0s1t0u0v0w0x0y0z</li>\n<li>then make the key to the map and check each word which has the same structure.</li>\n</ol>\n</blockquote>\n<p>The time copolex of this method is O(n*m).</p>\n<p>So, I use the second one to write the result code as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;vector&lt;string&gt; &gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</div><div class=\"line\">            vector&lt;string&gt; keys;</div><div class=\"line\">            map&lt;string, vector&lt;string&gt; &gt; retMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int chars[26] = &#123;0&#125;;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    chars[strs[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\">                string currentKey = &quot;&quot;;</div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;0&apos; + chars[j]);</div><div class=\"line\">                    currentKey = currentKey + (char)(&apos;a&apos; + j);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (retMap.find(currentKey) != retMap.end()) &#123;</div><div class=\"line\">                    retMap[currentKey].push_back(strs[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    vector&lt;string&gt; currentValue;</div><div class=\"line\">                    currentValue.push_back(strs[i]);</div><div class=\"line\">                    retMap.insert(pair&lt;string, vector&lt;string&gt; &gt;(currentKey, currentValue));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;string&gt; &gt; res;</div><div class=\"line\">            for (pair&lt;string, vector&lt;string&gt; &gt; values: retMap) &#123;</div><div class=\"line\">                res.push_back(values.second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Heaters","date":"2017-01-04T05:46:25.000Z","_content":"\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","source":"_posts/Heaters.md","raw":"---\ntitle: Heaters\ndate: 2017-01-04 13:46:25\ntags:\n    - Binary Search\n---\n\n> Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.\n>\n> So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.\n>\n> Note:\n>\n> + Numbers of houses and heaters you are given are non-negative and will not exceed 25000.\n> + Positions of houses and heaters you are given are non-negative and will not exceed 10^9.\n> + As long as a house is in the heaters' warm radius range, it can be warmed.\n> + All the heaters follow your radius standard and the warm radius will the same.\n>\n> Example 1:\n>\n> Input: [1,2,3],[2]\n> Output: 1\n> Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.\n>\n> Example 2:\n>\n> Input: [1,2,3,4],[1,4]\n> Output: 1\n> Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.\n\n<!-- more -->\n\nThis is Leetcode 475. As it's descripted, we can quickly find a solution. Picture this:\n\n\n```\n          h1   h2        h3\n           |    |         |\n......................................\n```\n\nIf we find the min value of the radius between every two heaters, and find the max one, which will be the result.\n\nAnd it's time complex is O(n*m), n is the num of the houses and m is the num of heaters.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int idx;\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n\n        int res = INT_MIN;\n        idx = 0;\n        for (int i = 0; i < (int)heaters.size(); i++) {\n            if (i == 0) {\n                res = max(res, findMinRadius(houses, -1, heaters[i]));\n            } else if (i == (int)heaters.size()) {\n                res = max(res, findMinRadius(houses, heaters[i - 1], -1));\n            } else {\n                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));\n            }\n            std::cout << res << std::endl;\n        }\n        return res;\n    }\n\n    int findMinRadius(vector<int> houses, int heater1, int heater2) {\n        if (heater1 == -1) { // means the first one\n            while (houses[idx] <= heater2) { idx++; }\n            return heater2 - houses[0];\n        } else if (heater2 == -1) { // means the last one\n            while (idx < (int)houses.size()) { idx++; }\n            return houses[idx - 1] - heater1;\n        } else {\n            int minRadius = INT_MAX;\n            for (int i = idx; houses[i] < heater2; i++) {\n                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);\n                // if there are (2n-1) houses, we need to use the mid one\n                // if there are (2n) houses, we should use the the mid two\n                // here is hard to decide which to use as the standard\n            }\n            return minRadius;\n        }\n    }\n};\n```\n\nHowever, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.\n\n+ For each house, find its position between those heaters (thus we need the heaters array to be sorted).\n+ Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.\n+ Get MAX value among distances in step 2. It's the answer.\n\nSo, here comes the solution:\n\n```\nclass Solution {\n    public:\n        int findRadius(vector<int>& houses, vector<int>& heaters) {\n            int house_size = houses.size();\n            if (house_size == 0) return 0;\n            sort(heaters.begin(), heaters.end());\n\n            int res = 0;\n            for (auto& c : houses) {\n\n                int idx = Bsearch(heaters, c);\n\n                if (idx == 0) {\n                    res = max(res, heaters[idx] - c);\n                } else if (idx >= (int)heaters.size()) {\n                    res = max(res, c - heaters.back());\n                } else {\n                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));\n                }\n            }\n            return res;\n        }\n\n        int Bsearch(vector<int>& nums, int val) {\n\n            int l = 0, r = nums.size() - 1;\n            while (l <= r) {\n                int mid = l + ((r - l) >> 1);\n                if (nums[mid] == val)\n                    return mid;\n                else if (nums[mid] < val)\n                    l = mid + 1;\n                else\n                    r = mid - 1;\n            }\n            return l;\n        }\n};\n```\n\nAnd it's AC.\n","slug":"Heaters","published":1,"updated":"2017-01-04T05:27:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvl001jg5f42aq89azv","content":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 475. As its descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And its time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. Its the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And its AC.</p>\n","excerpt":"<blockquote>\n<p>Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.</p>\n<p>So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</p>\n<p>Note:</p>\n<ul>\n<li>Numbers of houses and heaters you are given are non-negative and will not exceed 25000.</li>\n<li>Positions of houses and heaters you are given are non-negative and will not exceed 10^9.</li>\n<li>As long as a house is in the heaters warm radius range, it can be warmed.</li>\n<li>All the heaters follow your radius standard and the warm radius will the same.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1,2,3],[2]<br>Output: 1<br>Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.</p>\n<p>Example 2:</p>\n<p>Input: [1,2,3,4],[1,4]<br>Output: 1<br>Explanation: The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.</p>\n</blockquote>","more":"<p>This is Leetcode 475. As its descripted, we can quickly find a solution. Picture this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">          h1   h2        h3</div><div class=\"line\">           |    |         |</div><div class=\"line\">......................................</div></pre></td></tr></table></figure>\n<p>If we find the min value of the radius between every two heaters, and find the max one, which will be the result.</p>\n<p>And its time complex is O(n*m), n is the num of the houses and m is the num of heaters.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int idx;</div><div class=\"line\">    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">        sort(houses.begin(), houses.end());</div><div class=\"line\">        sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MIN;</div><div class=\"line\">        idx = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)heaters.size(); i++) &#123;</div><div class=\"line\">            if (i == 0) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, -1, heaters[i]));</div><div class=\"line\">            &#125; else if (i == (int)heaters.size()) &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], -1));</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                res = max(res, findMinRadius(houses, heaters[i - 1], heaters[i]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            std::cout &lt;&lt; res &lt;&lt; std::endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int findMinRadius(vector&lt;int&gt; houses, int heater1, int heater2) &#123;</div><div class=\"line\">        if (heater1 == -1) &#123; // means the first one</div><div class=\"line\">            while (houses[idx] &lt;= heater2) &#123; idx++; &#125;</div><div class=\"line\">            return heater2 - houses[0];</div><div class=\"line\">        &#125; else if (heater2 == -1) &#123; // means the last one</div><div class=\"line\">            while (idx &lt; (int)houses.size()) &#123; idx++; &#125;</div><div class=\"line\">            return houses[idx - 1] - heater1;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            int minRadius = INT_MAX;</div><div class=\"line\">            for (int i = idx; houses[i] &lt; heater2; i++) &#123;</div><div class=\"line\">                // minRadius = min(max(houses[i] - heater1, heater2 - houses[i]), minRadius);</div><div class=\"line\">                // if there are (2n-1) houses, we need to use the mid one</div><div class=\"line\">                // if there are (2n) houses, we should use the the mid two</div><div class=\"line\">                // here is hard to decide which to use as the standard</div><div class=\"line\">            &#125;</div><div class=\"line\">            return minRadius;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However, there is a better way to figure this problem out. The idea is to leverage decent binarySearch function.</p>\n<ul>\n<li>For each house, find its position between those heaters (thus we need the heaters array to be sorted).</li>\n<li>Calculate the distances between this house and left heater and right heater, get a MIN value of those two values. Corner cases are there is no left or right heater.</li>\n<li>Get MAX value among distances in step 2. Its the answer.</li>\n</ul>\n<p>So, here comes the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) &#123;</div><div class=\"line\">            int house_size = houses.size();</div><div class=\"line\">            if (house_size == 0) return 0;</div><div class=\"line\">            sort(heaters.begin(), heaters.end());</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (auto&amp; c : houses) &#123;</div><div class=\"line\"></div><div class=\"line\">                int idx = Bsearch(heaters, c);</div><div class=\"line\"></div><div class=\"line\">                if (idx == 0) &#123;</div><div class=\"line\">                    res = max(res, heaters[idx] - c);</div><div class=\"line\">                &#125; else if (idx &gt;= (int)heaters.size()) &#123;</div><div class=\"line\">                    res = max(res, c - heaters.back());</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = max(res, min(heaters[idx] - c, c - heaters[idx - 1]));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int Bsearch(vector&lt;int&gt;&amp; nums, int val) &#123;</div><div class=\"line\"></div><div class=\"line\">            int l = 0, r = nums.size() - 1;</div><div class=\"line\">            while (l &lt;= r) &#123;</div><div class=\"line\">                int mid = l + ((r - l) &gt;&gt; 1);</div><div class=\"line\">                if (nums[mid] == val)</div><div class=\"line\">                    return mid;</div><div class=\"line\">                else if (nums[mid] &lt; val)</div><div class=\"line\">                    l = mid + 1;</div><div class=\"line\">                else</div><div class=\"line\">                    r = mid - 1;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return l;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And its AC.</p>"},{"title":"House Robber III","date":"2017-01-21T12:45:21.000Z","_content":"\n> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n>\n> Determine the maximum amount of money the thief can rob tonight without alerting the police.\n>\n> Example 1:\n> ```\n  3\n / \\\n2   3\n \\   \\ \n  3   1\n```\n> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n>\n> Example 2:\n> ```\n    3\n   / \\\n  4   5\n / \\   \\ \n1   3   1\n```\n> Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n<!--more-->\n\nThis is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.\n\nTo some Node, I can tell it's max value when it's robbed or not robbed:\n\n```\nif (isRobCurrent) {\n    return current->val + _rob(current->left, false) + _rob(current->right, false);\n} else {\n    return max(\n            max(_rob(current->left, false) + _rob(current->right, false),\n                _rob(current->left, false) + _rob(current->right, true)),\n            max(_rob(current->left, true) + _rob(current->right, false),\n                _rob(current->left, true) + _rob(current->right, true))\n            );\n}\n```\n\nObviously, it gets a TLE. So, I think about using a hashmap to store the value of the node's value. Because I find see some node has been counted for more than one time.\n\nSo, here is the better solution:\n\n```\nclass Solution {\n    public:\n        int rob(TreeNode* root) {\n            vector<int> res = robSub(root);\n            return max(res[0], res[1]);\n        }\n\n        vector<int> robSub(TreeNode* root) {\n            if (root == NULL) {\n                return vector<int>(2,0);\n            }\n\n            vector<int> left = robSub(root->left);\n            vector<int> right = robSub(root->right);\n\n            vector<int> res(2,0);\n            res[0] = max(left[0], left[1]) + max(right[0], right[1]);\n            res[1] = root->val + left[0] + right[0];\n\n            return res;\n        }\n};\n```\n\nAnd it's get AC.\n","source":"_posts/HouseRobberIII.md","raw":"---\ntitle: House Robber III\ndate: 2017-01-21 20:45:21\ntags:\n    - Depth-first Search\n    - Tree\n---\n\n> The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root.\" Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place forms a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.\n>\n> Determine the maximum amount of money the thief can rob tonight without alerting the police.\n>\n> Example 1:\n> ```\n  3\n / \\\n2   3\n \\   \\ \n  3   1\n```\n> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n>\n> Example 2:\n> ```\n    3\n   / \\\n  4   5\n / \\   \\ \n1   3   1\n```\n> Maximum amount of money the thief can rob = 4 + 5 = 9.\n\n<!--more-->\n\nThis is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.\n\nTo some Node, I can tell it's max value when it's robbed or not robbed:\n\n```\nif (isRobCurrent) {\n    return current->val + _rob(current->left, false) + _rob(current->right, false);\n} else {\n    return max(\n            max(_rob(current->left, false) + _rob(current->right, false),\n                _rob(current->left, false) + _rob(current->right, true)),\n            max(_rob(current->left, true) + _rob(current->right, false),\n                _rob(current->left, true) + _rob(current->right, true))\n            );\n}\n```\n\nObviously, it gets a TLE. So, I think about using a hashmap to store the value of the node's value. Because I find see some node has been counted for more than one time.\n\nSo, here is the better solution:\n\n```\nclass Solution {\n    public:\n        int rob(TreeNode* root) {\n            vector<int> res = robSub(root);\n            return max(res[0], res[1]);\n        }\n\n        vector<int> robSub(TreeNode* root) {\n            if (root == NULL) {\n                return vector<int>(2,0);\n            }\n\n            vector<int> left = robSub(root->left);\n            vector<int> right = robSub(root->right);\n\n            vector<int> res(2,0);\n            res[0] = max(left[0], left[1]) + max(right[0], right[1]);\n            res[1] = root->val + left[0] + right[0];\n\n            return res;\n        }\n};\n```\n\nAnd it's get AC.\n","slug":"HouseRobberIII","published":1,"updated":"2017-02-14T07:05:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvo001lg5f4fl660weq","content":"<blockquote>\n<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place forms a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  3</div><div class=\"line\"> / \\</div><div class=\"line\">2   3</div><div class=\"line\"> \\   \\ </div><div class=\"line\">  3   1</div></pre></td></tr></table></figure></p>\n<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    3</div><div class=\"line\">   / \\</div><div class=\"line\">  4   5</div><div class=\"line\"> / \\   \\ </div><div class=\"line\">1   3   1</div></pre></td></tr></table></figure></p>\n<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.</p>\n<p>To some Node, I can tell its max value when its robbed or not robbed:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (isRobCurrent) &#123;</div><div class=\"line\">    return current-&gt;val + _rob(current-&gt;left, false) + _rob(current-&gt;right, false);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    return max(</div><div class=\"line\">            max(_rob(current-&gt;left, false) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, false) + _rob(current-&gt;right, true)),</div><div class=\"line\">            max(_rob(current-&gt;left, true) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, true) + _rob(current-&gt;right, true))</div><div class=\"line\">            );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Obviously, it gets a TLE. So, I think about using a hashmap to store the value of the nodes value. Because I find see some node has been counted for more than one time.</p>\n<p>So, here is the better solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int rob(TreeNode* root) &#123;</div><div class=\"line\">            vector&lt;int&gt; res = robSub(root);</div><div class=\"line\">            return max(res[0], res[1]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; robSub(TreeNode* root) &#123;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return vector&lt;int&gt;(2,0);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; left = robSub(root-&gt;left);</div><div class=\"line\">            vector&lt;int&gt; right = robSub(root-&gt;right);</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res(2,0);</div><div class=\"line\">            res[0] = max(left[0], left[1]) + max(right[0], right[1]);</div><div class=\"line\">            res[1] = root-&gt;val + left[0] + right[0];</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And its get AC.</p>\n","excerpt":"<blockquote>\n<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place forms a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  3</div><div class=\"line\"> / \\</div><div class=\"line\">2   3</div><div class=\"line\"> \\   \\ </div><div class=\"line\">  3   1</div></pre></td></tr></table></figure></p>\n<p>Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    3</div><div class=\"line\">   / \\</div><div class=\"line\">  4   5</div><div class=\"line\"> / \\   \\ </div><div class=\"line\">1   3   1</div></pre></td></tr></table></figure></p>\n<p>Maximum amount of money the thief can rob = 4 + 5 = 9.</p>\n</blockquote>","more":"<p>This is Leetcode 337, I think this is a kind of DP problem or recursive solution problem. I get the recursive relationship.</p>\n<p>To some Node, I can tell its max value when its robbed or not robbed:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (isRobCurrent) &#123;</div><div class=\"line\">    return current-&gt;val + _rob(current-&gt;left, false) + _rob(current-&gt;right, false);</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    return max(</div><div class=\"line\">            max(_rob(current-&gt;left, false) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, false) + _rob(current-&gt;right, true)),</div><div class=\"line\">            max(_rob(current-&gt;left, true) + _rob(current-&gt;right, false),</div><div class=\"line\">                _rob(current-&gt;left, true) + _rob(current-&gt;right, true))</div><div class=\"line\">            );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Obviously, it gets a TLE. So, I think about using a hashmap to store the value of the nodes value. Because I find see some node has been counted for more than one time.</p>\n<p>So, here is the better solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int rob(TreeNode* root) &#123;</div><div class=\"line\">            vector&lt;int&gt; res = robSub(root);</div><div class=\"line\">            return max(res[0], res[1]);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        vector&lt;int&gt; robSub(TreeNode* root) &#123;</div><div class=\"line\">            if (root == NULL) &#123;</div><div class=\"line\">                return vector&lt;int&gt;(2,0);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; left = robSub(root-&gt;left);</div><div class=\"line\">            vector&lt;int&gt; right = robSub(root-&gt;right);</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res(2,0);</div><div class=\"line\">            res[0] = max(left[0], left[1]) + max(right[0], right[1]);</div><div class=\"line\">            res[1] = root-&gt;val + left[0] + right[0];</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And its get AC.</p>"},{"title":"Find the Duplicate Number","date":"2017-02-08T01:35:17.000Z","_content":"\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> Note:\n>  + You must not modify the array (assume the array is read only).\n>  + You must use only constant, O(1) extra space.\n>  + Your runtime complexity should be less than O(n2).\n>  + There is only one duplicate number in the array, but it could be repeated more than once.\n\n<!--more-->\n\nThis is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.\n\nIf you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.\n\nHowever, you can not modify, so you need to find another solution.\n\nI don't know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.\n\nAnd if I can use the O(n2) time complexity, I can use the two loops solution.\n\nIf the duplicate number can only be repeated once. U can make this problem into a Math problem.\n\nSo, I come up with such a solution:\n\n```\nclass Solution {\n    public:\n        int findDuplicate(vector<int>& nums) {\n            if (nums.size() <= 1) {\n                return -1;\n            }\n\n            int n = nums.size();\n            int slow = n;\n            int fast = n;\n            do {\n                slow = nums[slow - 1];\n                fast = nums[nums[fast - 1] - 1];\n            } while (slow != fast);\n            slow = n;\n            while (slow != fast) {\n                slow = nums[slow - 1];\n                fast = nums[fast - 1];\n            }\n            return slow;\n        }\n};\n```\n\nFor the explaination:\n\nsuppose the array is\n\n + index: 0 1 2 3 4 5\n + value: 2 5 1 1 4 3\n\nfirst subtract 1 from each element in the array, so it is much easy to understand.\nuse the value as pointer. the array becomes:\n \n + index: 0 1 2 3 4 5\n + value: 1 4 0 0 3 2\n\nenter image description here\n\n![description](http://cyukang.com/images/cycle3.png)\n\nSecond if the array is\n\n + index: 0 1 2 3 4 5\n + value: 0 1 2 4 2 3\n\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\n\nNow the problem is the same as find the cycle in linkedlist!\n","source":"_posts/FindtheDuplicateNumber.md","raw":"---\ntitle: Find the Duplicate Number\ndate: 2017-02-08 09:35:17\ntags:\n    - Binary Search\n    - Array\n    - Two Pointers\n---\n\n> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n>\n> Note:\n>  + You must not modify the array (assume the array is read only).\n>  + You must use only constant, O(1) extra space.\n>  + Your runtime complexity should be less than O(n2).\n>  + There is only one duplicate number in the array, but it could be repeated more than once.\n\n<!--more-->\n\nThis is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.\n\nIf you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.\n\nHowever, you can not modify, so you need to find another solution.\n\nI don't know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.\n\nAnd if I can use the O(n2) time complexity, I can use the two loops solution.\n\nIf the duplicate number can only be repeated once. U can make this problem into a Math problem.\n\nSo, I come up with such a solution:\n\n```\nclass Solution {\n    public:\n        int findDuplicate(vector<int>& nums) {\n            if (nums.size() <= 1) {\n                return -1;\n            }\n\n            int n = nums.size();\n            int slow = n;\n            int fast = n;\n            do {\n                slow = nums[slow - 1];\n                fast = nums[nums[fast - 1] - 1];\n            } while (slow != fast);\n            slow = n;\n            while (slow != fast) {\n                slow = nums[slow - 1];\n                fast = nums[fast - 1];\n            }\n            return slow;\n        }\n};\n```\n\nFor the explaination:\n\nsuppose the array is\n\n + index: 0 1 2 3 4 5\n + value: 2 5 1 1 4 3\n\nfirst subtract 1 from each element in the array, so it is much easy to understand.\nuse the value as pointer. the array becomes:\n \n + index: 0 1 2 3 4 5\n + value: 1 4 0 0 3 2\n\nenter image description here\n\n![description](http://cyukang.com/images/cycle3.png)\n\nSecond if the array is\n\n + index: 0 1 2 3 4 5\n + value: 0 1 2 4 2 3\n\nwe must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.\n\nNow the problem is the same as find the cycle in linkedlist!\n","slug":"FindtheDuplicateNumber","published":1,"updated":"2017-02-08T04:50:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvq001og5f43p5f6jyu","content":"<blockquote>\n<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\n<p>Note:</p>\n<ul>\n<li>You must not modify the array (assume the array is read only).</li>\n<li>You must use only constant, O(1) extra space.</li>\n<li>Your runtime complexity should be less than O(n2).</li>\n<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.</p>\n<p>If you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.</p>\n<p>However, you can not modify, so you need to find another solution.</p>\n<p>I dont know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.</p>\n<p>And if I can use the O(n2) time complexity, I can use the two loops solution.</p>\n<p>If the duplicate number can only be repeated once. U can make this problem into a Math problem.</p>\n<p>So, I come up with such a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt;= 1) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int n = nums.size();</div><div class=\"line\">            int slow = n;</div><div class=\"line\">            int fast = n;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[nums[fast - 1] - 1];</div><div class=\"line\">            &#125; while (slow != fast);</div><div class=\"line\">            slow = n;</div><div class=\"line\">            while (slow != fast) &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[fast - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return slow;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>For the explaination:</p>\n<p>suppose the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 2 5 1 1 4 3</li>\n</ul>\n<p>first subtract 1 from each element in the array, so it is much easy to understand.<br>use the value as pointer. the array becomes:</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 1 4 0 0 3 2</li>\n</ul>\n<p>enter image description here</p>\n<p><img src=\"http://cyukang.com/images/cycle3.png\" alt=\"description\"></p>\n<p>Second if the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 0 1 2 4 2 3</li>\n</ul>\n<p>we must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.</p>\n<p>Now the problem is the same as find the cycle in linkedlist!</p>\n","excerpt":"<blockquote>\n<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>\n<p>Note:</p>\n<ul>\n<li>You must not modify the array (assume the array is read only).</li>\n<li>You must use only constant, O(1) extra space.</li>\n<li>Your runtime complexity should be less than O(n2).</li>\n<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 287, and it is easy if you can modify this array. Sort and find, O(NlogN) time complexity.</p>\n<p>If you can use O(N) space, you can use a array to store all the num and check whether it is appeared once.</p>\n<p>However, you can not modify, so you need to find another solution.</p>\n<p>I dont know if I use bitset is ok? If it is good, I can finish this with O(1) space and O(n) time.</p>\n<p>And if I can use the O(n2) time complexity, I can use the two loops solution.</p>\n<p>If the duplicate number can only be repeated once. U can make this problem into a Math problem.</p>\n<p>So, I come up with such a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt;= 1) &#123;</div><div class=\"line\">                return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int n = nums.size();</div><div class=\"line\">            int slow = n;</div><div class=\"line\">            int fast = n;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[nums[fast - 1] - 1];</div><div class=\"line\">            &#125; while (slow != fast);</div><div class=\"line\">            slow = n;</div><div class=\"line\">            while (slow != fast) &#123;</div><div class=\"line\">                slow = nums[slow - 1];</div><div class=\"line\">                fast = nums[fast - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return slow;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>For the explaination:</p>\n<p>suppose the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 2 5 1 1 4 3</li>\n</ul>\n<p>first subtract 1 from each element in the array, so it is much easy to understand.<br>use the value as pointer. the array becomes:</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 1 4 0 0 3 2</li>\n</ul>\n<p>enter image description here</p>\n<p><img src=\"http://cyukang.com/images/cycle3.png\" alt=\"description\"></p>\n<p>Second if the array is</p>\n<ul>\n<li>index: 0 1 2 3 4 5</li>\n<li>value: 0 1 2 4 2 3</li>\n</ul>\n<p>we must choose the last element as the head of the linked list. If we choose 0, we can not detect the cycle.</p>\n<p>Now the problem is the same as find the cycle in linkedlist!</p>"},{"title":"Increasing Subsequences","date":"2017-01-29T15:16:14.000Z","_content":"\n\n> Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\n>\n> Example:\n>\n> + Input: [4, 6, 7, 7]\n> + Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n>\n> Note:\n>\n> + The length of the given array will not exceed 15.\n> + The range of integer in the given array is [-100,100].\n> + The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.\n\n<!--more-->\n\nThis is Leetcode 491. It's a problem with much fun. You can find a solution by using a stack and a back trace.\n\nNot a clear solution, but I try to make it easy to think and easy to understand.\n\nI try to combine all the possible combination and check whether it is good to move further.\n\n```\nclass Solution {\n    public:\n        set<vector<int> > res;\n        vector<vector<int> > findSubsequences(vector<int> &nums) {\n            vector<int> current;\n            vector<vector<int> > ret;\n\n            res.clear();\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                _doIt(nums, i, current);\n            }\n\n            for (vector<int> n : res) {\n                ret.push_back(n);\n            }\n            return ret;\n        }\n\n        void _doIt(vector<int> nums, int idx, vector<int> current) {\n            for (int i = idx; i < (int)nums.size(); i++) {\n                if (current.size() > 0 && nums[i] >= current[current.size() - 1]) {\n                    current.push_back(nums[i]);\n                    if (current.size() > 1) {\n                        res.insert(vector<int>(current));\n                    }\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n                if (current.size() == 0){\n                    current.push_back(nums[i]);\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/IncreasingSubsequences.md","raw":"---\ntitle: Increasing Subsequences\ndate: 2017-01-29 23:16:14\ntags:\n    - Depth-first Search\n---\n\n\n> Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .\n>\n> Example:\n>\n> + Input: [4, 6, 7, 7]\n> + Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]\n>\n> Note:\n>\n> + The length of the given array will not exceed 15.\n> + The range of integer in the given array is [-100,100].\n> + The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.\n\n<!--more-->\n\nThis is Leetcode 491. It's a problem with much fun. You can find a solution by using a stack and a back trace.\n\nNot a clear solution, but I try to make it easy to think and easy to understand.\n\nI try to combine all the possible combination and check whether it is good to move further.\n\n```\nclass Solution {\n    public:\n        set<vector<int> > res;\n        vector<vector<int> > findSubsequences(vector<int> &nums) {\n            vector<int> current;\n            vector<vector<int> > ret;\n\n            res.clear();\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                _doIt(nums, i, current);\n            }\n\n            for (vector<int> n : res) {\n                ret.push_back(n);\n            }\n            return ret;\n        }\n\n        void _doIt(vector<int> nums, int idx, vector<int> current) {\n            for (int i = idx; i < (int)nums.size(); i++) {\n                if (current.size() > 0 && nums[i] >= current[current.size() - 1]) {\n                    current.push_back(nums[i]);\n                    if (current.size() > 1) {\n                        res.insert(vector<int>(current));\n                    }\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n                if (current.size() == 0){\n                    current.push_back(nums[i]);\n                    _doIt(nums, i + 1, current);\n                    current.pop_back();\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","slug":"IncreasingSubsequences","published":1,"updated":"2017-01-29T15:39:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvt001qg5f4tnr6trad","content":"<blockquote>\n<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>\n<p>Example:</p>\n<ul>\n<li>Input: [4, 6, 7, 7]</li>\n<li>Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of the given array will not exceed 15.</li>\n<li>The range of integer in the given array is [-100,100].</li>\n<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 491. Its a problem with much fun. You can find a solution by using a stack and a back trace.</p>\n<p>Not a clear solution, but I try to make it easy to think and easy to understand.</p>\n<p>I try to combine all the possible combination and check whether it is good to move further.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        set&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; findSubsequences(vector&lt;int&gt; &amp;nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; current;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; ret;</div><div class=\"line\"></div><div class=\"line\">            res.clear();</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                _doIt(nums, i, current);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (vector&lt;int&gt; n : res) &#123;</div><div class=\"line\">                ret.push_back(n);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _doIt(vector&lt;int&gt; nums, int idx, vector&lt;int&gt; current) &#123;</div><div class=\"line\">            for (int i = idx; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (current.size() &gt; 0 &amp;&amp; nums[i] &gt;= current[current.size() - 1]) &#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    if (current.size() &gt; 1) &#123;</div><div class=\"line\">                        res.insert(vector&lt;int&gt;(current));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (current.size() == 0)&#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>\n<p>Example:</p>\n<ul>\n<li>Input: [4, 6, 7, 7]</li>\n<li>Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of the given array will not exceed 15.</li>\n<li>The range of integer in the given array is [-100,100].</li>\n<li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 491. Its a problem with much fun. You can find a solution by using a stack and a back trace.</p>\n<p>Not a clear solution, but I try to make it easy to think and easy to understand.</p>\n<p>I try to combine all the possible combination and check whether it is good to move further.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        set&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; findSubsequences(vector&lt;int&gt; &amp;nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; current;</div><div class=\"line\">            vector&lt;vector&lt;int&gt; &gt; ret;</div><div class=\"line\"></div><div class=\"line\">            res.clear();</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                _doIt(nums, i, current);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (vector&lt;int&gt; n : res) &#123;</div><div class=\"line\">                ret.push_back(n);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _doIt(vector&lt;int&gt; nums, int idx, vector&lt;int&gt; current) &#123;</div><div class=\"line\">            for (int i = idx; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (current.size() &gt; 0 &amp;&amp; nums[i] &gt;= current[current.size() - 1]) &#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    if (current.size() &gt; 1) &#123;</div><div class=\"line\">                        res.insert(vector&lt;int&gt;(current));</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (current.size() == 0)&#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    _doIt(nums, i + 1, current);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Font Size","date":"2017-02-14T06:21:49.000Z","_content":"\n> **Description:**\n>\n> Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters.\n>\n> Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Steven's phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show W / S characters in a line and H / S lines in a page. (x is the largest integer no more than x)\n>\n> So here's the question, if Steven wants to control the number of pages no more than P, what's the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs.\n>\n> **Input:**\n>\n> Input may contain multiple test cases.\n>\n> The first line is an integer TASKS, representing the number of test cases.\n>\n> For each test case, the first line contains four integers N, P, W and H, as described above.\n>\n> The second line contains N integers a1, a2, ... aN, indicating the number of characters in each paragraph.\n>\n> For all test cases,\n> + 1 <= N <= 103,\n> + 1 <= W, H, ai <= 103,\n> + 1 <= P <= 106,\n>\n> There is always a way to control the number of pages no more than P.\n>\n> **Output**\n>\n> For each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set.\n>\n<!--more-->\n> + Example Input:\n> ```\n 2\n 1 10 4 3\n 10\n 2 10 4 3\n 10 103\n```\n> + Example Output:\n> ```\n 3\n 2\n```\n\n<!--more-->\n\nThis is one problem from hihocode, it is No. 1288, and it is also one of the microsoft hiring test. So, it must be fun enough to waste time to figure it out.\n\nIt actually has fun. You should find the relationship with the Maxline and Maxwordperline.\n\nIf you read my code, you will understand quickly.\n\n```\nusing namespace std;\n\nbool checkIsOk(int pageHeight, int pageWidth, int fontSize, vector<int> wordNums, int maxPageNums) {\n    int currentWordsPerLine = (int)(pageWidth / fontSize);\n    int currentLinesPerPage = (int)(pageHeight / fontSize);\n\n    int totalLineNum = currentLinesPerPage * maxPageNums;\n    for (int i = 0; i < (int)wordNums.size(); i++) {\n        if (totalLineNum < 0) {\n            return false;\n        }\n        int currentLineNum = 1;\n        while (wordNums[i] - (currentWordsPerLine * currentLineNum) > 0) {\n            currentLineNum++;\n        }\n        totalLineNum = totalLineNum - currentLineNum;\n    }\n    return totalLineNum >= 0;\n}\n\nint main() {\n    int TASKS;\n    int N, P, W, H;\n    while (cin >> TASKS) {\n        for (int i = 0; i < TASKS; i++) {\n            cin >> N >> P >> W >> H;\n            vector<int> wordNums(N);\n            for (int idx = 0; idx < N; idx++) {\n                cin >> wordNums[idx];\n            }\n\n            int low = 1, high = W, res = -1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (checkIsOk(H, W, mid, wordNums, P)) {\n                    res = max(res, mid);\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            cout << res << endl;\n        }\n    }\n\n    return 0;\n}\n```\n\nIt gets AC.\n","source":"_posts/FontSize.md","raw":"---\ntitle: Font Size\ndate: 2017-02-14 14:21:49\ntags:\n    - Math\n    - Binary Search\n---\n\n> **Description:**\n>\n> Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters.\n>\n> Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Steven's phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show W / S characters in a line and H / S lines in a page. (x is the largest integer no more than x)\n>\n> So here's the question, if Steven wants to control the number of pages no more than P, what's the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs.\n>\n> **Input:**\n>\n> Input may contain multiple test cases.\n>\n> The first line is an integer TASKS, representing the number of test cases.\n>\n> For each test case, the first line contains four integers N, P, W and H, as described above.\n>\n> The second line contains N integers a1, a2, ... aN, indicating the number of characters in each paragraph.\n>\n> For all test cases,\n> + 1 <= N <= 103,\n> + 1 <= W, H, ai <= 103,\n> + 1 <= P <= 106,\n>\n> There is always a way to control the number of pages no more than P.\n>\n> **Output**\n>\n> For each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set.\n>\n<!--more-->\n> + Example Input:\n> ```\n 2\n 1 10 4 3\n 10\n 2 10 4 3\n 10 103\n```\n> + Example Output:\n> ```\n 3\n 2\n```\n\n<!--more-->\n\nThis is one problem from hihocode, it is No. 1288, and it is also one of the microsoft hiring test. So, it must be fun enough to waste time to figure it out.\n\nIt actually has fun. You should find the relationship with the Maxline and Maxwordperline.\n\nIf you read my code, you will understand quickly.\n\n```\nusing namespace std;\n\nbool checkIsOk(int pageHeight, int pageWidth, int fontSize, vector<int> wordNums, int maxPageNums) {\n    int currentWordsPerLine = (int)(pageWidth / fontSize);\n    int currentLinesPerPage = (int)(pageHeight / fontSize);\n\n    int totalLineNum = currentLinesPerPage * maxPageNums;\n    for (int i = 0; i < (int)wordNums.size(); i++) {\n        if (totalLineNum < 0) {\n            return false;\n        }\n        int currentLineNum = 1;\n        while (wordNums[i] - (currentWordsPerLine * currentLineNum) > 0) {\n            currentLineNum++;\n        }\n        totalLineNum = totalLineNum - currentLineNum;\n    }\n    return totalLineNum >= 0;\n}\n\nint main() {\n    int TASKS;\n    int N, P, W, H;\n    while (cin >> TASKS) {\n        for (int i = 0; i < TASKS; i++) {\n            cin >> N >> P >> W >> H;\n            vector<int> wordNums(N);\n            for (int idx = 0; idx < N; idx++) {\n                cin >> wordNums[idx];\n            }\n\n            int low = 1, high = W, res = -1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (checkIsOk(H, W, mid, wordNums, P)) {\n                    res = max(res, mid);\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n            cout << res << endl;\n        }\n    }\n\n    return 0;\n}\n```\n\nIt gets AC.\n","slug":"FontSize","published":1,"updated":"2017-02-15T05:22:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvw001sg5f46f33e7n4","content":"<blockquote>\n<p><strong>Description:</strong></p>\n<p>Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters.</p>\n<p>Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Stevens phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show W / S characters in a line and H / S lines in a page. (x is the largest integer no more than x)</p>\n<p>So heres the question, if Steven wants to control the number of pages no more than P, whats the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs.</p>\n<p><strong>Input:</strong></p>\n<p>Input may contain multiple test cases.</p>\n<p>The first line is an integer TASKS, representing the number of test cases.</p>\n<p>For each test case, the first line contains four integers N, P, W and H, as described above.</p>\n<p>The second line contains N integers a1, a2,  aN, indicating the number of characters in each paragraph.</p>\n<p>For all test cases,</p>\n<ul>\n<li>1 &lt;= N &lt;= 103,</li>\n<li>1 &lt;= W, H, ai &lt;= 103,</li>\n<li>1 &lt;= P &lt;= 106,</li>\n</ul>\n<p>There is always a way to control the number of pages no more than P.</p>\n<p><strong>Output</strong></p>\n<p>For each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set.</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>Example Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">2</div><div class=\"line\">1 10 4 3</div><div class=\"line\">10</div><div class=\"line\">2 10 4 3</div><div class=\"line\">10 103</div></pre></td></tr></table></figure>\n</li>\n<li><p>Example Output:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">3</div><div class=\"line\">2</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<!--more-->\n<p>This is one problem from hihocode, it is No. 1288, and it is also one of the microsoft hiring test. So, it must be fun enough to waste time to figure it out.</p>\n<p>It actually has fun. You should find the relationship with the Maxline and Maxwordperline.</p>\n<p>If you read my code, you will understand quickly.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">bool checkIsOk(int pageHeight, int pageWidth, int fontSize, vector&lt;int&gt; wordNums, int maxPageNums) &#123;</div><div class=\"line\">    int currentWordsPerLine = (int)(pageWidth / fontSize);</div><div class=\"line\">    int currentLinesPerPage = (int)(pageHeight / fontSize);</div><div class=\"line\"></div><div class=\"line\">    int totalLineNum = currentLinesPerPage * maxPageNums;</div><div class=\"line\">    for (int i = 0; i &lt; (int)wordNums.size(); i++) &#123;</div><div class=\"line\">        if (totalLineNum &lt; 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int currentLineNum = 1;</div><div class=\"line\">        while (wordNums[i] - (currentWordsPerLine * currentLineNum) &gt; 0) &#123;</div><div class=\"line\">            currentLineNum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        totalLineNum = totalLineNum - currentLineNum;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return totalLineNum &gt;= 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main() &#123;</div><div class=\"line\">    int TASKS;</div><div class=\"line\">    int N, P, W, H;</div><div class=\"line\">    while (cin &gt;&gt; TASKS) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; TASKS; i++) &#123;</div><div class=\"line\">            cin &gt;&gt; N &gt;&gt; P &gt;&gt; W &gt;&gt; H;</div><div class=\"line\">            vector&lt;int&gt; wordNums(N);</div><div class=\"line\">            for (int idx = 0; idx &lt; N; idx++) &#123;</div><div class=\"line\">                cin &gt;&gt; wordNums[idx];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int low = 1, high = W, res = -1;</div><div class=\"line\">            while (low &lt;= high) &#123;</div><div class=\"line\">                int mid = (low + high) / 2;</div><div class=\"line\">                if (checkIsOk(H, W, mid, wordNums, P)) &#123;</div><div class=\"line\">                    res = max(res, mid);</div><div class=\"line\">                    low = mid + 1;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    high = mid - 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            cout &lt;&lt; res &lt;&lt; endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p><strong>Description:</strong></p>\n<p>Steven loves reading book on his phone. The book he reads now consists of N paragraphs and the i-th paragraph contains ai characters.</p>\n<p>Steven wants to make the characters easier to read, so he decides to increase the font size of characters. But the size of Stevens phone screen is limited. Its width is W and height is H. As a result, if the font size of characters is S then it can only show W / S characters in a line and H / S lines in a page. (x is the largest integer no more than x)</p>\n<p>So heres the question, if Steven wants to control the number of pages no more than P, whats the maximum font size he can set? Note that paragraphs must start in a new line and there is no empty line between paragraphs.</p>\n<p><strong>Input:</strong></p>\n<p>Input may contain multiple test cases.</p>\n<p>The first line is an integer TASKS, representing the number of test cases.</p>\n<p>For each test case, the first line contains four integers N, P, W and H, as described above.</p>\n<p>The second line contains N integers a1, a2,  aN, indicating the number of characters in each paragraph.</p>\n<p>For all test cases,</p>\n<ul>\n<li>1 &lt;= N &lt;= 103,</li>\n<li>1 &lt;= W, H, ai &lt;= 103,</li>\n<li>1 &lt;= P &lt;= 106,</li>\n</ul>\n<p>There is always a way to control the number of pages no more than P.</p>\n<p><strong>Output</strong></p>\n<p>For each testcase, output a line with an integer Ans, indicating the maximum font size Steven can set.</p>","more":"<ul>\n<li><p>Example Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">2</div><div class=\"line\">1 10 4 3</div><div class=\"line\">10</div><div class=\"line\">2 10 4 3</div><div class=\"line\">10 103</div></pre></td></tr></table></figure>\n</li>\n<li><p>Example Output:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">3</div><div class=\"line\">2</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<!--more-->\n<p>This is one problem from hihocode, it is No. 1288, and it is also one of the microsoft hiring test. So, it must be fun enough to waste time to figure it out.</p>\n<p>It actually has fun. You should find the relationship with the Maxline and Maxwordperline.</p>\n<p>If you read my code, you will understand quickly.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">bool checkIsOk(int pageHeight, int pageWidth, int fontSize, vector&lt;int&gt; wordNums, int maxPageNums) &#123;</div><div class=\"line\">    int currentWordsPerLine = (int)(pageWidth / fontSize);</div><div class=\"line\">    int currentLinesPerPage = (int)(pageHeight / fontSize);</div><div class=\"line\"></div><div class=\"line\">    int totalLineNum = currentLinesPerPage * maxPageNums;</div><div class=\"line\">    for (int i = 0; i &lt; (int)wordNums.size(); i++) &#123;</div><div class=\"line\">        if (totalLineNum &lt; 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int currentLineNum = 1;</div><div class=\"line\">        while (wordNums[i] - (currentWordsPerLine * currentLineNum) &gt; 0) &#123;</div><div class=\"line\">            currentLineNum++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        totalLineNum = totalLineNum - currentLineNum;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return totalLineNum &gt;= 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main() &#123;</div><div class=\"line\">    int TASKS;</div><div class=\"line\">    int N, P, W, H;</div><div class=\"line\">    while (cin &gt;&gt; TASKS) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; TASKS; i++) &#123;</div><div class=\"line\">            cin &gt;&gt; N &gt;&gt; P &gt;&gt; W &gt;&gt; H;</div><div class=\"line\">            vector&lt;int&gt; wordNums(N);</div><div class=\"line\">            for (int idx = 0; idx &lt; N; idx++) &#123;</div><div class=\"line\">                cin &gt;&gt; wordNums[idx];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int low = 1, high = W, res = -1;</div><div class=\"line\">            while (low &lt;= high) &#123;</div><div class=\"line\">                int mid = (low + high) / 2;</div><div class=\"line\">                if (checkIsOk(H, W, mid, wordNums, P)) &#123;</div><div class=\"line\">                    res = max(res, mid);</div><div class=\"line\">                    low = mid + 1;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    high = mid - 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            cout &lt;&lt; res &lt;&lt; endl;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Integer Break","date":"2017-03-11T04:45:11.000Z","_content":"\n> Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\n>\n> For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).\n>\n> Note: You may assume that n is not less than 2 and not larger than 58.\n>\n> Hint:\n>\n> + There is a simple O(n) solution to this problem.\n> + You may check the breaking results of n ranging from 7 to 10 to discover the regularities.\n\n<!--more-->\n\nThis is Leetcode No.343. At first I thought it is a simple DP problem. But I failed once.\n\nI thought the DP array will be like this:\n\n```\nDP[num] = DP[num / 2] + DP[num - num / 2];\n```\n\nHowever, the number 9 is not following this rule. the max is 9 = 3 + 3 + 3 (27) instead of 9 = 4 + 5 (24).\n\nSo, the result becomes:\n\n```\nDP[num] = max(i - 3, DP[i - 3]);\n```\n\nThe result becomes:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<int> DP;\n        int integerBreak(int num) {\n            if (DP.size() == 0) {\n                DP.push_back(0);\n                DP.push_back(1);\n                DP.push_back(1); // [0, 0, 1]\n            }\n            for (int i = DP.size(); i <= num; i++) {\n                DP.push_back(3 * DP[i - 3]);\n            }\n            return DP[num];\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/IntegerBreak.md","raw":"---\ntitle: Integer Break\ndate: 2017-03-11 12:45:11\ntags:\n    - Math\n    - Dynamic Programming\n---\n\n> Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.\n>\n> For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).\n>\n> Note: You may assume that n is not less than 2 and not larger than 58.\n>\n> Hint:\n>\n> + There is a simple O(n) solution to this problem.\n> + You may check the breaking results of n ranging from 7 to 10 to discover the regularities.\n\n<!--more-->\n\nThis is Leetcode No.343. At first I thought it is a simple DP problem. But I failed once.\n\nI thought the DP array will be like this:\n\n```\nDP[num] = DP[num / 2] + DP[num - num / 2];\n```\n\nHowever, the number 9 is not following this rule. the max is 9 = 3 + 3 + 3 (27) instead of 9 = 4 + 5 (24).\n\nSo, the result becomes:\n\n```\nDP[num] = max(i - 3, DP[i - 3]);\n```\n\nThe result becomes:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<int> DP;\n        int integerBreak(int num) {\n            if (DP.size() == 0) {\n                DP.push_back(0);\n                DP.push_back(1);\n                DP.push_back(1); // [0, 0, 1]\n            }\n            for (int i = DP.size(); i <= num; i++) {\n                DP.push_back(3 * DP[i - 3]);\n            }\n            return DP[num];\n        }\n};\n```\n\nIt gets AC.\n","slug":"IntegerBreak","published":1,"updated":"2017-03-11T05:35:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvy001ug5f4ym52m7oe","content":"<blockquote>\n<p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>\n<p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>\n<p>Note: You may assume that n is not less than 2 and not larger than 58.</p>\n<p>Hint:</p>\n<ul>\n<li>There is a simple O(n) solution to this problem.</li>\n<li>You may check the breaking results of n ranging from 7 to 10 to discover the regularities.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.343. At first I thought it is a simple DP problem. But I failed once.</p>\n<p>I thought the DP array will be like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DP[num] = DP[num / 2] + DP[num - num / 2];</div></pre></td></tr></table></figure>\n<p>However, the number 9 is not following this rule. the max is 9 = 3 + 3 + 3 (27) instead of 9 = 4 + 5 (24).</p>\n<p>So, the result becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DP[num] = max(i - 3, DP[i - 3]);</div></pre></td></tr></table></figure>\n<p>The result becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; DP;</div><div class=\"line\">        int integerBreak(int num) &#123;</div><div class=\"line\">            if (DP.size() == 0) &#123;</div><div class=\"line\">                DP.push_back(0);</div><div class=\"line\">                DP.push_back(1);</div><div class=\"line\">                DP.push_back(1); // [0, 0, 1]</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = DP.size(); i &lt;= num; i++) &#123;</div><div class=\"line\">                DP.push_back(3 * DP[i - 3]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[num];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>\n<p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>\n<p>Note: You may assume that n is not less than 2 and not larger than 58.</p>\n<p>Hint:</p>\n<ul>\n<li>There is a simple O(n) solution to this problem.</li>\n<li>You may check the breaking results of n ranging from 7 to 10 to discover the regularities.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.343. At first I thought it is a simple DP problem. But I failed once.</p>\n<p>I thought the DP array will be like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DP[num] = DP[num / 2] + DP[num - num / 2];</div></pre></td></tr></table></figure>\n<p>However, the number 9 is not following this rule. the max is 9 = 3 + 3 + 3 (27) instead of 9 = 4 + 5 (24).</p>\n<p>So, the result becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DP[num] = max(i - 3, DP[i - 3]);</div></pre></td></tr></table></figure>\n<p>The result becomes:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; DP;</div><div class=\"line\">        int integerBreak(int num) &#123;</div><div class=\"line\">            if (DP.size() == 0) &#123;</div><div class=\"line\">                DP.push_back(0);</div><div class=\"line\">                DP.push_back(1);</div><div class=\"line\">                DP.push_back(1); // [0, 0, 1]</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = DP.size(); i &lt;= num; i++) &#123;</div><div class=\"line\">                DP.push_back(3 * DP[i - 3]);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[num];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Integer Replacement","date":"2017-01-22T15:04:22.000Z","_content":"\n> Given a positive integer n and you can do operations as follow:\n>\n> + If n is even, replace n with n/2.\n> + If n is odd, you can replace n with either n + 1 or n - 1.\n>\n> What is the minimum number of replacements needed for n to become 1?\n>\n> Example 1:\n> + Input: 8\n> + Output: 3\n> + Explanation: 8 -> 4 -> 2 -> 1\n>\n> Example 2:\n> + Input: 7\n> + Output: 4\n> + Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1\n\n<!-- more-->\n\nThis is Leetcode 397, and we can quickly find a solution in recuisive way:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt(num);\n        }\n\n        int _doIt(int num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nWithout any doubt, we get a RTE.\n\nBecause, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.\n\nSo, a easy way to solve or take over the problem is using the data type long:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt((long)num);\n        }\n\n        int _doIt(long num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nNot a nice solution, but it gets AC.\n","source":"_posts/IntegerReplacement.md","raw":"---\ntitle: Integer Replacement\ndate: 2017-01-22 23:04:22\ntags:\n    - Math\n    - Bitmap\n---\n\n> Given a positive integer n and you can do operations as follow:\n>\n> + If n is even, replace n with n/2.\n> + If n is odd, you can replace n with either n + 1 or n - 1.\n>\n> What is the minimum number of replacements needed for n to become 1?\n>\n> Example 1:\n> + Input: 8\n> + Output: 3\n> + Explanation: 8 -> 4 -> 2 -> 1\n>\n> Example 2:\n> + Input: 7\n> + Output: 4\n> + Explanation: 7 -> 8 -> 4 -> 2 -> 1 or 7 -> 6 -> 3 -> 2 -> 1\n\n<!-- more-->\n\nThis is Leetcode 397, and we can quickly find a solution in recuisive way:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt(num);\n        }\n\n        int _doIt(int num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nWithout any doubt, we get a RTE.\n\nBecause, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.\n\nSo, a easy way to solve or take over the problem is using the data type long:\n\n```\nclass Solution {\n    public:\n        int integerReplacement(int num) {\n            return _doIt((long)num);\n        }\n\n        int _doIt(long num) {\n            if (num == 1) {\n                return 0;\n            } else if ((num & 1) == 0) { // even\n                return 1 + _doIt(num >> 1);\n            } else {\n                return 1 + min(_doIt(num + 1), _doIt(num - 1));\n            }\n        }\n};\n```\n\nNot a nice solution, but it gets AC.\n","slug":"IntegerReplacement","published":1,"updated":"2017-01-24T15:41:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatvz001xg5f4fpb1tgcn","content":"<blockquote>\n<p>Given a positive integer n and you can do operations as follow:</p>\n<ul>\n<li>If n is even, replace n with n/2.</li>\n<li>If n is odd, you can replace n with either n + 1 or n - 1.</li>\n</ul>\n<p>What is the minimum number of replacements needed for n to become 1?</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 8</li>\n<li>Output: 3</li>\n<li>Explanation: 8 -&gt; 4 -&gt; 2 -&gt; 1</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 7</li>\n<li>Output: 4</li>\n<li>Explanation: 7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 or 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 397, and we can quickly find a solution in recuisive way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt(num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(int num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Without any doubt, we get a RTE.</p>\n<p>Because, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.</p>\n<p>So, a easy way to solve or take over the problem is using the data type long:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt((long)num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(long num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Not a nice solution, but it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer n and you can do operations as follow:</p>\n<ul>\n<li>If n is even, replace n with n/2.</li>\n<li>If n is odd, you can replace n with either n + 1 or n - 1.</li>\n</ul>\n<p>What is the minimum number of replacements needed for n to become 1?</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 8</li>\n<li>Output: 3</li>\n<li>Explanation: 8 -&gt; 4 -&gt; 2 -&gt; 1</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 7</li>\n<li>Output: 4</li>\n<li>Explanation: 7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1 or 7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 397, and we can quickly find a solution in recuisive way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt(num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(int num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Without any doubt, we get a RTE.</p>\n<p>Because, a little problem cause, when the given num is INT_MAX, the (num + 1) will get error.</p>\n<p>So, a easy way to solve or take over the problem is using the data type long:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int integerReplacement(int num) &#123;</div><div class=\"line\">            return _doIt((long)num);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _doIt(long num) &#123;</div><div class=\"line\">            if (num == 1) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125; else if ((num &amp; 1) == 0) &#123; // even</div><div class=\"line\">                return 1 + _doIt(num &gt;&gt; 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return 1 + min(_doIt(num + 1), _doIt(num - 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Not a nice solution, but it gets AC.</p>"},{"title":"License Key Formatting","date":"2017-01-17T15:18:47.000Z","_content":"> Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.\n>\n> We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.\n>\n> So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.\n>\n>\n> Example 1:\n>   + Input: S = \"2-4A0r7-4k\", K = 4\n>   + Output: \"24A0-R74K\"\n>   + Explanation: The string S has been split into two parts, each part has 4 characters.\n>\n> Example 2:\n>   + Input: S = \"2-4A0r7-4k\", K = 3\n>   + Output: \"24-A0R-74K\"\n>   + Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.\n>\n> Note:\n> + The length of string S will not exceed 12,000, and K is a positive integer.\n> + String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\n> + String S is non-empty.\n\n<!--more-->\n\nThis is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.\n\n```\nclass Solution {\n    public:\n        string licenseKeyFormatting(string S, int K) {\n            vector<char> strs;\n            for (int i = 0; i < (int)S.length(); i++) {\n                if (S[i] == '-') {\n                    continue;\n                } else if ('a' <= S[i] && S[i] <= 'z') {\n                    strs.push_back((char)(S[i] - 'a' + 'A'));\n                } else {\n                    strs.push_back(S[i]);\n                }\n            }\n            int firstIdx = strs.size() % K;\n            string res = \"\";\n            for (int i = 0; i < firstIdx; i++) {\n                res = res + strs[i];\n            }\n            for (int i = firstIdx; i < (int)strs.size(); i++) {\n                if (i != 0 && (i - firstIdx) % K == 0) {\n                    res = res + '-';\n                }\n                res = res + strs[i];\n            }\n            return res;\n        }\n};\n```\n\nThis code I just type and submit and get AC in the first time. Such an easy problem.\n\n","source":"_posts/LicenseKeyFormatting.md","raw":"---\ntitle: License Key Formatting\ndate: 2017-01-17 23:18:47\ntags:\n    - String\n---\n> Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.\n>\n> We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.\n>\n> So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.\n>\n>\n> Example 1:\n>   + Input: S = \"2-4A0r7-4k\", K = 4\n>   + Output: \"24A0-R74K\"\n>   + Explanation: The string S has been split into two parts, each part has 4 characters.\n>\n> Example 2:\n>   + Input: S = \"2-4A0r7-4k\", K = 3\n>   + Output: \"24-A0R-74K\"\n>   + Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.\n>\n> Note:\n> + The length of string S will not exceed 12,000, and K is a positive integer.\n> + String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).\n> + String S is non-empty.\n\n<!--more-->\n\nThis is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.\n\n```\nclass Solution {\n    public:\n        string licenseKeyFormatting(string S, int K) {\n            vector<char> strs;\n            for (int i = 0; i < (int)S.length(); i++) {\n                if (S[i] == '-') {\n                    continue;\n                } else if ('a' <= S[i] && S[i] <= 'z') {\n                    strs.push_back((char)(S[i] - 'a' + 'A'));\n                } else {\n                    strs.push_back(S[i]);\n                }\n            }\n            int firstIdx = strs.size() % K;\n            string res = \"\";\n            for (int i = 0; i < firstIdx; i++) {\n                res = res + strs[i];\n            }\n            for (int i = firstIdx; i < (int)strs.size(); i++) {\n                if (i != 0 && (i - firstIdx) % K == 0) {\n                    res = res + '-';\n                }\n                res = res + strs[i];\n            }\n            return res;\n        }\n};\n```\n\nThis code I just type and submit and get AC in the first time. Such an easy problem.\n\n","slug":"LicenseKeyFormatting","published":1,"updated":"2017-01-17T15:33:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw0001zg5f4c3257cju","content":"<blockquote>\n<p>Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.</p>\n<p>We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.</p>\n<p>So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: S = 2-4A0r7-4k, K = 4</li>\n<li>Output: 24A0-R74K</li>\n<li>Explanation: The string S has been split into two parts, each part has 4 characters.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: S = 2-4A0r7-4k, K = 3</li>\n<li>Output: 24-A0R-74K</li>\n<li>Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>\n<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>\n<li>String S is non-empty.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string licenseKeyFormatting(string S, int K) &#123;</div><div class=\"line\">            vector&lt;char&gt; strs;</div><div class=\"line\">            for (int i = 0; i &lt; (int)S.length(); i++) &#123;</div><div class=\"line\">                if (S[i] == &apos;-&apos;) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125; else if (&apos;a&apos; &lt;= S[i] &amp;&amp; S[i] &lt;= &apos;z&apos;) &#123;</div><div class=\"line\">                    strs.push_back((char)(S[i] - &apos;a&apos; + &apos;A&apos;));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    strs.push_back(S[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int firstIdx = strs.size() % K;</div><div class=\"line\">            string res = &quot;&quot;;</div><div class=\"line\">            for (int i = 0; i &lt; firstIdx; i++) &#123;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = firstIdx; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                if (i != 0 &amp;&amp; (i - firstIdx) % K == 0) &#123;</div><div class=\"line\">                    res = res + &apos;-&apos;;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This code I just type and submit and get AC in the first time. Such an easy problem.</p>\n","excerpt":"<blockquote>\n<p>Now you are given a string S, which represents a software license key which we would like to format. The string S is composed of alphanumerical characters and dashes. The dashes split the alphanumerical characters within the string into groups. (i.e. if there are M dashes, the string is split into M+1 groups). The dashes in the given string are possibly misplaced.</p>\n<p>We want each group of characters to be of length K (except for possibly the first group, which could be shorter, but still must contain at least one character). To satisfy this requirement, we will reinsert dashes. Additionally, all the lower case letters in the string must be converted to upper case.</p>\n<p>So, you are given a non-empty string S, representing a license key to format, and an integer K. And you need to return the license key formatted according to the description above.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: S = 2-4A0r7-4k, K = 4</li>\n<li>Output: 24A0-R74K</li>\n<li>Explanation: The string S has been split into two parts, each part has 4 characters.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: S = 2-4A0r7-4k, K = 3</li>\n<li>Output: 24-A0R-74K</li>\n<li>Explanation: The string S has been split into three parts, each part has 3 characters except the first part as it could be shorter as said above.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length of string S will not exceed 12,000, and K is a positive integer.</li>\n<li>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).</li>\n<li>String S is non-empty.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 482, and I think it is just a simulation problem. So there is none technical skills just use force and quick type skills.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string licenseKeyFormatting(string S, int K) &#123;</div><div class=\"line\">            vector&lt;char&gt; strs;</div><div class=\"line\">            for (int i = 0; i &lt; (int)S.length(); i++) &#123;</div><div class=\"line\">                if (S[i] == &apos;-&apos;) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125; else if (&apos;a&apos; &lt;= S[i] &amp;&amp; S[i] &lt;= &apos;z&apos;) &#123;</div><div class=\"line\">                    strs.push_back((char)(S[i] - &apos;a&apos; + &apos;A&apos;));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    strs.push_back(S[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int firstIdx = strs.size() % K;</div><div class=\"line\">            string res = &quot;&quot;;</div><div class=\"line\">            for (int i = 0; i &lt; firstIdx; i++) &#123;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = firstIdx; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                if (i != 0 &amp;&amp; (i - firstIdx) % K == 0) &#123;</div><div class=\"line\">                    res = res + &apos;-&apos;;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = res + strs[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>This code I just type and submit and get AC in the first time. Such an easy problem.</p>"},{"title":"Largest Divisible Subset","date":"2017-01-13T03:04:11.000Z","_content":"\n> Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\n>\n> If there are multiple solutions, return any subset is fine.\n>\n> Example 1:\n> nums: [1,2,3]\n> Result: [1,2] (of course, [1,3] will also be ok)\n>\n> Example 2:\n> nums: [1,2,4,8]\n> Result: [1,2,4,8]\n\n<!--more-->\n\nThis is Leetcode 368, and it's a usual DP problem.\n\nWe use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.\n\nThen we can find the solution:\n\n```\nclass Solution {\n    public:\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\n            vector<int> v;\n            if (nums.size() < 1) {\n                return v;\n            }\n            sort(nums.begin(), nums.end());\n            map<int, vector<int> > numMap;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                vector<int> vtmp;\n                vtmp.push_back(nums[i]);\n                numMap.insert(pair<int, vector<int> >(nums[i], vtmp));\n            }\n            for (int i = 0; i < (int)nums.size(); i++) {\n                for (int j = i + 1; j < (int)nums.size(); j++) {\n                    if (nums[j] % nums[i] == 0) {\n                        if (numMap.find(nums[j])->second.size() < numMap.find(nums[i])->second.size() + 1) {\n                            vector<int> vtmp;\n                            vtmp.assign(numMap.find(nums[i])->second.begin(), numMap.find(nums[i])->second.end());\n                            vtmp.push_back(nums[j]);\n                            numMap.find(nums[j])->second = vtmp;\n                        }\n                    }\n                }\n            }\n\n            int idx = 0, max = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (max < (int)numMap.find(nums[i])->second.size()) {\n                    idx = nums[i];\n                    max = numMap.find(nums[i])->second.size();\n                }\n            }\n            return  numMap.find(idx)->second;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/LargestDivisibleSubset.md","raw":"---\ntitle: Largest Divisible Subset\ndate: 2017-01-13 11:04:11\ntags:\n    - Math\n    - Dynamic Programming\n---\n\n> Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.\n>\n> If there are multiple solutions, return any subset is fine.\n>\n> Example 1:\n> nums: [1,2,3]\n> Result: [1,2] (of course, [1,3] will also be ok)\n>\n> Example 2:\n> nums: [1,2,4,8]\n> Result: [1,2,4,8]\n\n<!--more-->\n\nThis is Leetcode 368, and it's a usual DP problem.\n\nWe use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.\n\nThen we can find the solution:\n\n```\nclass Solution {\n    public:\n        vector<int> largestDivisibleSubset(vector<int>& nums) {\n            vector<int> v;\n            if (nums.size() < 1) {\n                return v;\n            }\n            sort(nums.begin(), nums.end());\n            map<int, vector<int> > numMap;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                vector<int> vtmp;\n                vtmp.push_back(nums[i]);\n                numMap.insert(pair<int, vector<int> >(nums[i], vtmp));\n            }\n            for (int i = 0; i < (int)nums.size(); i++) {\n                for (int j = i + 1; j < (int)nums.size(); j++) {\n                    if (nums[j] % nums[i] == 0) {\n                        if (numMap.find(nums[j])->second.size() < numMap.find(nums[i])->second.size() + 1) {\n                            vector<int> vtmp;\n                            vtmp.assign(numMap.find(nums[i])->second.begin(), numMap.find(nums[i])->second.end());\n                            vtmp.push_back(nums[j]);\n                            numMap.find(nums[j])->second = vtmp;\n                        }\n                    }\n                }\n            }\n\n            int idx = 0, max = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (max < (int)numMap.find(nums[i])->second.size()) {\n                    idx = nums[i];\n                    max = numMap.find(nums[i])->second.size();\n                }\n            }\n            return  numMap.find(idx)->second;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"LargestDivisibleSubset","published":1,"updated":"2017-01-14T12:11:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw10022g5f4rcktbelh","content":"<blockquote>\n<p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>\n<p>If there are multiple solutions, return any subset is fine.</p>\n<p>Example 1:<br>nums: [1,2,3]<br>Result: [1,2] (of course, [1,3] will also be ok)</p>\n<p>Example 2:<br>nums: [1,2,4,8]<br>Result: [1,2,4,8]</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 368, and its a usual DP problem.</p>\n<p>We use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.</p>\n<p>Then we can find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; v;</div><div class=\"line\">            if (nums.size() &lt; 1) &#123;</div><div class=\"line\">                return v;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            map&lt;int, vector&lt;int&gt; &gt; numMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                vector&lt;int&gt; vtmp;</div><div class=\"line\">                vtmp.push_back(nums[i]);</div><div class=\"line\">                numMap.insert(pair&lt;int, vector&lt;int&gt; &gt;(nums[i], vtmp));</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (nums[j] % nums[i] == 0) &#123;</div><div class=\"line\">                        if (numMap.find(nums[j])-&gt;second.size() &lt; numMap.find(nums[i])-&gt;second.size() + 1) &#123;</div><div class=\"line\">                            vector&lt;int&gt; vtmp;</div><div class=\"line\">                            vtmp.assign(numMap.find(nums[i])-&gt;second.begin(), numMap.find(nums[i])-&gt;second.end());</div><div class=\"line\">                            vtmp.push_back(nums[j]);</div><div class=\"line\">                            numMap.find(nums[j])-&gt;second = vtmp;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int idx = 0, max = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (max &lt; (int)numMap.find(nums[i])-&gt;second.size()) &#123;</div><div class=\"line\">                    idx = nums[i];</div><div class=\"line\">                    max = numMap.find(nums[i])-&gt;second.size();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return  numMap.find(idx)-&gt;second;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>\n<p>If there are multiple solutions, return any subset is fine.</p>\n<p>Example 1:<br>nums: [1,2,3]<br>Result: [1,2] (of course, [1,3] will also be ok)</p>\n<p>Example 2:<br>nums: [1,2,4,8]<br>Result: [1,2,4,8]</p>\n</blockquote>","more":"<p>This is Leetcode 368, and its a usual DP problem.</p>\n<p>We use a numMap to store the pairs for each number. For example: {4:[1,2], 8:[1,2,4]}.</p>\n<p>Then we can find the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; v;</div><div class=\"line\">            if (nums.size() &lt; 1) &#123;</div><div class=\"line\">                return v;</div><div class=\"line\">            &#125;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            map&lt;int, vector&lt;int&gt; &gt; numMap;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                vector&lt;int&gt; vtmp;</div><div class=\"line\">                vtmp.push_back(nums[i]);</div><div class=\"line\">                numMap.insert(pair&lt;int, vector&lt;int&gt; &gt;(nums[i], vtmp));</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (nums[j] % nums[i] == 0) &#123;</div><div class=\"line\">                        if (numMap.find(nums[j])-&gt;second.size() &lt; numMap.find(nums[i])-&gt;second.size() + 1) &#123;</div><div class=\"line\">                            vector&lt;int&gt; vtmp;</div><div class=\"line\">                            vtmp.assign(numMap.find(nums[i])-&gt;second.begin(), numMap.find(nums[i])-&gt;second.end());</div><div class=\"line\">                            vtmp.push_back(nums[j]);</div><div class=\"line\">                            numMap.find(nums[j])-&gt;second = vtmp;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int idx = 0, max = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (max &lt; (int)numMap.find(nums[i])-&gt;second.size()) &#123;</div><div class=\"line\">                    idx = nums[i];</div><div class=\"line\">                    max = numMap.find(nums[i])-&gt;second.size();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return  numMap.find(idx)-&gt;second;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Intersection of Two Arrays II","date":"2017-01-08T14:36:11.000Z","_content":"\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n>\n>   + Each element in the result should appear as many times as it shows in both arrays.\n>   + The result can be in any order.\n>\n> Follow up:\n>\n>   + What if the given array is already sorted? How would you optimize your algorithm?\n>   + What if nums1's size is small compared to nums2's size? Which algorithm is better?\n>   + What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n<!--more-->\n\nThis is Leetcode 350. It's an easy problem, we can quickly write a solution based on hash map:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            map<int, int> nums;\n            vector<int> res;\n\n\n            for (int i = 0; i < (int)nums1.size(); i++) {\n                if (nums.find(nums1[i]) == nums.end()) {\n                    nums.insert(pair<int, int>(nums1[i], 1));\n                } else {\n                    nums.find(nums1[i])->second++;\n                }\n            }\n\n            for (int i = 0; i < (int)nums2.size(); i++) {\n                if (nums.find(nums2[i]) != nums.end() && nums.find(nums2[i])->second > 0) {\n                    res.push_back(nums2[i]);\n                    nums.find(nums2[i])->second--;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            int idx = 0, idy = 0;\n            vector<int> res;\n\n            sort(nums1.begin(), nums1.end());\n            sort(nums2.begin(), nums2.end());\n\n            while (idx < (int)nums1.size() && idy < (int)nums2.size()) {\n                if (nums1[idx] == nums2[idy]) {\n                    res.push_back(nums1[idx]);\n                    idx++; idy++;\n                } else if (nums1[idx] > nums2[idy]) {\n                    idy++;\n                } else if (nums1[idx] < nums2[idy]) {\n                    idx++;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.\n\nIf the memeory is limited such that we can't load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.\n\n","source":"_posts/IntersectionofTwoArraysII.md","raw":"---\ntitle: Intersection of Two Arrays II\ndate: 2017-01-08 22:36:11\ntags:\n    - Binary Search\n    - Hash Table\n    - Two Pointers\n    - Sort\n---\n\n\n> Given two arrays, write a function to compute their intersection.\n>\n> Example:\n> Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].\n>\n> Note:\n>\n>   + Each element in the result should appear as many times as it shows in both arrays.\n>   + The result can be in any order.\n>\n> Follow up:\n>\n>   + What if the given array is already sorted? How would you optimize your algorithm?\n>   + What if nums1's size is small compared to nums2's size? Which algorithm is better?\n>   + What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?\n\n<!--more-->\n\nThis is Leetcode 350. It's an easy problem, we can quickly write a solution based on hash map:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            map<int, int> nums;\n            vector<int> res;\n\n\n            for (int i = 0; i < (int)nums1.size(); i++) {\n                if (nums.find(nums1[i]) == nums.end()) {\n                    nums.insert(pair<int, int>(nums1[i], 1));\n                } else {\n                    nums.find(nums1[i])->second++;\n                }\n            }\n\n            for (int i = 0; i < (int)nums2.size(); i++) {\n                if (nums.find(nums2[i]) != nums.end() && nums.find(nums2[i])->second > 0) {\n                    res.push_back(nums2[i]);\n                    nums.find(nums2[i])->second--;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:\n\n```\nclass Solution {\n    public:\n        vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n            int idx = 0, idy = 0;\n            vector<int> res;\n\n            sort(nums1.begin(), nums1.end());\n            sort(nums2.begin(), nums2.end());\n\n            while (idx < (int)nums1.size() && idy < (int)nums2.size()) {\n                if (nums1[idx] == nums2[idy]) {\n                    res.push_back(nums1[idx]);\n                    idx++; idy++;\n                } else if (nums1[idx] > nums2[idy]) {\n                    idy++;\n                } else if (nums1[idx] < nums2[idy]) {\n                    idx++;\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nIts time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.\n\nIf the memeory is limited such that we can't load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.\n\n","slug":"IntersectionofTwoArraysII","published":1,"updated":"2017-01-08T15:01:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw30024g5f4msi6904a","content":"<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:</p>\n<ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p>Follow up:</p>\n<ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if nums1s size is small compared to nums2s size? Which algorithm is better?</li>\n<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 350. Its an easy problem, we can quickly write a solution based on hash map:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            map&lt;int, int&gt; nums;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums1.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums1[i]) == nums.end()) &#123;</div><div class=\"line\">                    nums.insert(pair&lt;int, int&gt;(nums1[i], 1));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    nums.find(nums1[i])-&gt;second++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums2.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums2[i]) != nums.end() &amp;&amp; nums.find(nums2[i])-&gt;second &gt; 0) &#123;</div><div class=\"line\">                    res.push_back(nums2[i]);</div><div class=\"line\">                    nums.find(nums2[i])-&gt;second--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            int idx = 0, idy = 0;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            sort(nums1.begin(), nums1.end());</div><div class=\"line\">            sort(nums2.begin(), nums2.end());</div><div class=\"line\"></div><div class=\"line\">            while (idx &lt; (int)nums1.size() &amp;&amp; idy &lt; (int)nums2.size()) &#123;</div><div class=\"line\">                if (nums1[idx] == nums2[idy]) &#123;</div><div class=\"line\">                    res.push_back(nums1[idx]);</div><div class=\"line\">                    idx++; idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &gt; nums2[idy]) &#123;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &lt; nums2[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.</p>\n<p>If the memeory is limited such that we cant load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.</p>\n","excerpt":"<blockquote>\n<p>Given two arrays, write a function to compute their intersection.</p>\n<p>Example:<br>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].</p>\n<p>Note:</p>\n<ul>\n<li>Each element in the result should appear as many times as it shows in both arrays.</li>\n<li>The result can be in any order.</li>\n</ul>\n<p>Follow up:</p>\n<ul>\n<li>What if the given array is already sorted? How would you optimize your algorithm?</li>\n<li>What if nums1s size is small compared to nums2s size? Which algorithm is better?</li>\n<li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 350. Its an easy problem, we can quickly write a solution based on hash map:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            map&lt;int, int&gt; nums;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums1.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums1[i]) == nums.end()) &#123;</div><div class=\"line\">                    nums.insert(pair&lt;int, int&gt;(nums1[i], 1));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    nums.find(nums1[i])-&gt;second++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums2.size(); i++) &#123;</div><div class=\"line\">                if (nums.find(nums2[i]) != nums.end() &amp;&amp; nums.find(nums2[i])-&gt;second &gt; 0) &#123;</div><div class=\"line\">                    res.push_back(nums2[i]);</div><div class=\"line\">                    nums.find(nums2[i])-&gt;second--;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n), and its space complex is O(n), which makes it not a good solution. So, as the follow up, we can assume that the both arrays are sorted. Then we can use the two points method like below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</div><div class=\"line\">            int idx = 0, idy = 0;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            sort(nums1.begin(), nums1.end());</div><div class=\"line\">            sort(nums2.begin(), nums2.end());</div><div class=\"line\"></div><div class=\"line\">            while (idx &lt; (int)nums1.size() &amp;&amp; idy &lt; (int)nums2.size()) &#123;</div><div class=\"line\">                if (nums1[idx] == nums2[idy]) &#123;</div><div class=\"line\">                    res.push_back(nums1[idx]);</div><div class=\"line\">                    idx++; idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &gt; nums2[idy]) &#123;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else if (nums1[idx] &lt; nums2[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(n) but its space complex is O(1), which makes it better than the hash map solution.</p>\n<p>If the memeory is limited such that we cant load all elements into the memory at once? This is a common problem. And we can use the hash algorithm to divide all elements in to different group and then we deal with them one by one.</p>"},{"title":"K-diff Pairs in an Array","date":"2017-03-05T13:51:13.000Z","_content":"\n> Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\n>\n> Example 1:\n>```\nInput: [3, 1, 4, 1, 5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\n            Although we have two 1s in the input, we should only return the number of unique pairs.\n```\n> Example 2:\n>```\nInput:[1, 2, 3, 4, 5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n```\n> Example 3:\n>```\nInput: [1, 3, 1, 5, 4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n```\n> Note:\n> + The pairs (i, j) and (j, i) count as the same pair.\n> + The length of the array won't exceed 10,000.\n> + All the integers in the given input belong to the range: [-1e7, 1e7].\n\n<!--more-->\n\nThis is Leetcode No.532. It is a easy problem. Here is my answer, using a set to store the result:\n\n```\nclass Solution {\n    public:\n        int findPairs(vector<int>& nums, int target) {\n            set<string> res;\n            sort(nums.begin(), nums.end());\n\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                for (int idy = 0; idy < (int)nums.size(); idy++) {\n                    if (abs(nums[idx] - nums[idy]) == target) {\n                        string key = to_string(nums[idx]) + to_string(nums[idy]);\n                        if (res.find(key) == res.end()) {\n                            res.insert(key);\n                            continue;\n                        }\n                    }\n                }\n            }\n\n            return res.size();\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/K-diffPairsinanArray.md","raw":"---\ntitle: K-diff Pairs in an Array\ndate: 2017-03-05 21:51:13\ntags:\n    - Array\n    - Two Pointers\n---\n\n> Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\n>\n> Example 1:\n>```\nInput: [3, 1, 4, 1, 5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\n            Although we have two 1s in the input, we should only return the number of unique pairs.\n```\n> Example 2:\n>```\nInput:[1, 2, 3, 4, 5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n```\n> Example 3:\n>```\nInput: [1, 3, 1, 5, 4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\n```\n> Note:\n> + The pairs (i, j) and (j, i) count as the same pair.\n> + The length of the array won't exceed 10,000.\n> + All the integers in the given input belong to the range: [-1e7, 1e7].\n\n<!--more-->\n\nThis is Leetcode No.532. It is a easy problem. Here is my answer, using a set to store the result:\n\n```\nclass Solution {\n    public:\n        int findPairs(vector<int>& nums, int target) {\n            set<string> res;\n            sort(nums.begin(), nums.end());\n\n            for (int idx = 0; idx < (int)nums.size(); idx++) {\n                for (int idy = 0; idy < (int)nums.size(); idy++) {\n                    if (abs(nums[idx] - nums[idy]) == target) {\n                        string key = to_string(nums[idx]) + to_string(nums[idy]);\n                        if (res.find(key) == res.end()) {\n                            res.insert(key);\n                            continue;\n                        }\n                    }\n                }\n            }\n\n            return res.size();\n        }\n};\n```\n\nIt gets AC.\n","slug":"K-diffPairsinanArray","published":1,"updated":"2017-03-05T14:21:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw40027g5f4awano6gh","content":"<blockquote>\n<p>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [3, 1, 4, 1, 5], k = 2</div><div class=\"line\">Output: 2</div><div class=\"line\">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</div><div class=\"line\">            Although we have two 1s in the input, we should only return the number of unique pairs.</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:[1, 2, 3, 4, 5], k = 1</div><div class=\"line\">Output: 4</div><div class=\"line\">Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</div></pre></td></tr></table></figure></p>\n<p>Example 3:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [1, 3, 1, 5, 4], k = 0</div><div class=\"line\">Output: 1</div><div class=\"line\">Explanation: There is one 0-diff pair in the array, (1, 1).</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The pairs (i, j) and (j, i) count as the same pair.</li>\n<li>The length of the array wont exceed 10,000.</li>\n<li>All the integers in the given input belong to the range: [-1e7, 1e7].</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.532. It is a easy problem. Here is my answer, using a set to store the result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findPairs(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            set&lt;string&gt; res;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)nums.size(); idy++) &#123;</div><div class=\"line\">                    if (abs(nums[idx] - nums[idy]) == target) &#123;</div><div class=\"line\">                        string key = to_string(nums[idx]) + to_string(nums[idy]);</div><div class=\"line\">                        if (res.find(key) == res.end()) &#123;</div><div class=\"line\">                            res.insert(key);</div><div class=\"line\">                            continue;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res.size();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [3, 1, 4, 1, 5], k = 2</div><div class=\"line\">Output: 2</div><div class=\"line\">Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</div><div class=\"line\">            Although we have two 1s in the input, we should only return the number of unique pairs.</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:[1, 2, 3, 4, 5], k = 1</div><div class=\"line\">Output: 4</div><div class=\"line\">Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).</div></pre></td></tr></table></figure></p>\n<p>Example 3:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [1, 3, 1, 5, 4], k = 0</div><div class=\"line\">Output: 1</div><div class=\"line\">Explanation: There is one 0-diff pair in the array, (1, 1).</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The pairs (i, j) and (j, i) count as the same pair.</li>\n<li>The length of the array wont exceed 10,000.</li>\n<li>All the integers in the given input belong to the range: [-1e7, 1e7].</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.532. It is a easy problem. Here is my answer, using a set to store the result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findPairs(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            set&lt;string&gt; res;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)nums.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)nums.size(); idy++) &#123;</div><div class=\"line\">                    if (abs(nums[idx] - nums[idy]) == target) &#123;</div><div class=\"line\">                        string key = to_string(nums[idx]) + to_string(nums[idy]);</div><div class=\"line\">                        if (res.find(key) == res.end()) &#123;</div><div class=\"line\">                            res.insert(key);</div><div class=\"line\">                            continue;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res.size();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Keyboard Row","date":"2017-02-20T02:12:50.000Z","_content":"\n> Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.\n>\n> American keyboard:\n> ![keyboard](https://leetcode.com/static/images/problemset/keyboard.png)\n>\n> Example 1:\n> + Input: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\n> + Output: [\"Alaska\", \"Dad\"]\n>\n> Note:\n> + You may use one character in the keyboard more than once.\n> + You may assume the input string will only contain letters of alphabet.\n\n<!--more-->\n\nIt is Leetcode No.500, and it is a very easy problem.\n\n```\nclass Solution {\n    public:\n        vector<string> findWords(vector<string>& words) {\n            set<char> level[3];\n            vector<string> res;\n\n            level[0].insert('q');\n            level[0].insert('w');\n            level[0].insert('e');\n            level[0].insert('r');\n            level[0].insert('t');\n            level[0].insert('y');\n            level[0].insert('u');\n            level[0].insert('i');\n            level[0].insert('o');\n            level[0].insert('p');\n\n            level[0].insert('Q');\n            level[0].insert('W');\n            level[0].insert('E');\n            level[0].insert('R');\n            level[0].insert('T');\n            level[0].insert('Y');\n            level[0].insert('U');\n            level[0].insert('I');\n            level[0].insert('O');\n            level[0].insert('P');\n\n            level[1].insert('a');\n            level[1].insert('s');\n            level[1].insert('d');\n            level[1].insert('f');\n            level[1].insert('g');\n            level[1].insert('h');\n            level[1].insert('j');\n            level[1].insert('k');\n            level[1].insert('l');\n\n\n            level[1].insert('A');\n            level[1].insert('S');\n            level[1].insert('D');\n            level[1].insert('F');\n            level[1].insert('G');\n            level[1].insert('H');\n            level[1].insert('J');\n            level[1].insert('K');\n            level[1].insert('L');\n\n\n            level[2].insert('z');\n            level[2].insert('x');\n            level[2].insert('c');\n            level[2].insert('v');\n            level[2].insert('b');\n            level[2].insert('n');\n            level[2].insert('m');\n\n            level[2].insert('Z');\n            level[2].insert('X');\n            level[2].insert('C');\n            level[2].insert('V');\n            level[2].insert('B');\n            level[2].insert('N');\n            level[2].insert('M');\n\n            for (auto word : words) {\n                int idx = -1;\n                for (int i = 0; i < 3; i++) {\n                    if (level[i].find(word[0]) != level[i].end()) {\n                        idx = i;\n                        break;\n                    }\n                }\n                for (int i = 1; i < (int)word.length(); i++) {\n                    if (level[idx].find(word[i]) == level[idx].end()) {\n                        idx = -1;\n                        break;\n                    }\n                }\n                if (idx != -1) {\n                    res.push_back(word);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/KeyboardRow.md","raw":"---\ntitle: Keyboard Row\ndate: 2017-02-20 10:12:50\ntags:\n    - Hash Table\n---\n\n> Given a List of words, return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below.\n>\n> American keyboard:\n> ![keyboard](https://leetcode.com/static/images/problemset/keyboard.png)\n>\n> Example 1:\n> + Input: [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\n> + Output: [\"Alaska\", \"Dad\"]\n>\n> Note:\n> + You may use one character in the keyboard more than once.\n> + You may assume the input string will only contain letters of alphabet.\n\n<!--more-->\n\nIt is Leetcode No.500, and it is a very easy problem.\n\n```\nclass Solution {\n    public:\n        vector<string> findWords(vector<string>& words) {\n            set<char> level[3];\n            vector<string> res;\n\n            level[0].insert('q');\n            level[0].insert('w');\n            level[0].insert('e');\n            level[0].insert('r');\n            level[0].insert('t');\n            level[0].insert('y');\n            level[0].insert('u');\n            level[0].insert('i');\n            level[0].insert('o');\n            level[0].insert('p');\n\n            level[0].insert('Q');\n            level[0].insert('W');\n            level[0].insert('E');\n            level[0].insert('R');\n            level[0].insert('T');\n            level[0].insert('Y');\n            level[0].insert('U');\n            level[0].insert('I');\n            level[0].insert('O');\n            level[0].insert('P');\n\n            level[1].insert('a');\n            level[1].insert('s');\n            level[1].insert('d');\n            level[1].insert('f');\n            level[1].insert('g');\n            level[1].insert('h');\n            level[1].insert('j');\n            level[1].insert('k');\n            level[1].insert('l');\n\n\n            level[1].insert('A');\n            level[1].insert('S');\n            level[1].insert('D');\n            level[1].insert('F');\n            level[1].insert('G');\n            level[1].insert('H');\n            level[1].insert('J');\n            level[1].insert('K');\n            level[1].insert('L');\n\n\n            level[2].insert('z');\n            level[2].insert('x');\n            level[2].insert('c');\n            level[2].insert('v');\n            level[2].insert('b');\n            level[2].insert('n');\n            level[2].insert('m');\n\n            level[2].insert('Z');\n            level[2].insert('X');\n            level[2].insert('C');\n            level[2].insert('V');\n            level[2].insert('B');\n            level[2].insert('N');\n            level[2].insert('M');\n\n            for (auto word : words) {\n                int idx = -1;\n                for (int i = 0; i < 3; i++) {\n                    if (level[i].find(word[0]) != level[i].end()) {\n                        idx = i;\n                        break;\n                    }\n                }\n                for (int i = 1; i < (int)word.length(); i++) {\n                    if (level[idx].find(word[i]) == level[idx].end()) {\n                        idx = -1;\n                        break;\n                    }\n                }\n                if (idx != -1) {\n                    res.push_back(word);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"KeyboardRow","published":1,"updated":"2017-02-20T02:44:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw50029g5f4ect5snlw","content":"<blockquote>\n<p>Given a List of words, return the words that can be typed using letters of alphabet on only one rows of American keyboard like the image below.</p>\n<p>American keyboard:<br><img src=\"https://leetcode.com/static/images/problemset/keyboard.png\" alt=\"keyboard\"></p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [Hello, Alaska, Dad, Peace]</li>\n<li>Output: [Alaska, Dad]</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>You may use one character in the keyboard more than once.</li>\n<li>You may assume the input string will only contain letters of alphabet.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is Leetcode No.500, and it is a very easy problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;</div><div class=\"line\">            set&lt;char&gt; level[3];</div><div class=\"line\">            vector&lt;string&gt; res;</div><div class=\"line\"></div><div class=\"line\">            level[0].insert(&apos;q&apos;);</div><div class=\"line\">            level[0].insert(&apos;w&apos;);</div><div class=\"line\">            level[0].insert(&apos;e&apos;);</div><div class=\"line\">            level[0].insert(&apos;r&apos;);</div><div class=\"line\">            level[0].insert(&apos;t&apos;);</div><div class=\"line\">            level[0].insert(&apos;y&apos;);</div><div class=\"line\">            level[0].insert(&apos;u&apos;);</div><div class=\"line\">            level[0].insert(&apos;i&apos;);</div><div class=\"line\">            level[0].insert(&apos;o&apos;);</div><div class=\"line\">            level[0].insert(&apos;p&apos;);</div><div class=\"line\"></div><div class=\"line\">            level[0].insert(&apos;Q&apos;);</div><div class=\"line\">            level[0].insert(&apos;W&apos;);</div><div class=\"line\">            level[0].insert(&apos;E&apos;);</div><div class=\"line\">            level[0].insert(&apos;R&apos;);</div><div class=\"line\">            level[0].insert(&apos;T&apos;);</div><div class=\"line\">            level[0].insert(&apos;Y&apos;);</div><div class=\"line\">            level[0].insert(&apos;U&apos;);</div><div class=\"line\">            level[0].insert(&apos;I&apos;);</div><div class=\"line\">            level[0].insert(&apos;O&apos;);</div><div class=\"line\">            level[0].insert(&apos;P&apos;);</div><div class=\"line\"></div><div class=\"line\">            level[1].insert(&apos;a&apos;);</div><div class=\"line\">            level[1].insert(&apos;s&apos;);</div><div class=\"line\">            level[1].insert(&apos;d&apos;);</div><div class=\"line\">            level[1].insert(&apos;f&apos;);</div><div class=\"line\">            level[1].insert(&apos;g&apos;);</div><div class=\"line\">            level[1].insert(&apos;h&apos;);</div><div class=\"line\">            level[1].insert(&apos;j&apos;);</div><div class=\"line\">            level[1].insert(&apos;k&apos;);</div><div class=\"line\">            level[1].insert(&apos;l&apos;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            level[1].insert(&apos;A&apos;);</div><div class=\"line\">            level[1].insert(&apos;S&apos;);</div><div class=\"line\">            level[1].insert(&apos;D&apos;);</div><div class=\"line\">            level[1].insert(&apos;F&apos;);</div><div class=\"line\">            level[1].insert(&apos;G&apos;);</div><div class=\"line\">            level[1].insert(&apos;H&apos;);</div><div class=\"line\">            level[1].insert(&apos;J&apos;);</div><div class=\"line\">            level[1].insert(&apos;K&apos;);</div><div class=\"line\">            level[1].insert(&apos;L&apos;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            level[2].insert(&apos;z&apos;);</div><div class=\"line\">            level[2].insert(&apos;x&apos;);</div><div class=\"line\">            level[2].insert(&apos;c&apos;);</div><div class=\"line\">            level[2].insert(&apos;v&apos;);</div><div class=\"line\">            level[2].insert(&apos;b&apos;);</div><div class=\"line\">            level[2].insert(&apos;n&apos;);</div><div class=\"line\">            level[2].insert(&apos;m&apos;);</div><div class=\"line\"></div><div class=\"line\">            level[2].insert(&apos;Z&apos;);</div><div class=\"line\">            level[2].insert(&apos;X&apos;);</div><div class=\"line\">            level[2].insert(&apos;C&apos;);</div><div class=\"line\">            level[2].insert(&apos;V&apos;);</div><div class=\"line\">            level[2].insert(&apos;B&apos;);</div><div class=\"line\">            level[2].insert(&apos;N&apos;);</div><div class=\"line\">            level[2].insert(&apos;M&apos;);</div><div class=\"line\"></div><div class=\"line\">            for (auto word : words) &#123;</div><div class=\"line\">                int idx = -1;</div><div class=\"line\">                for (int i = 0; i &lt; 3; i++) &#123;</div><div class=\"line\">                    if (level[i].find(word[0]) != level[i].end()) &#123;</div><div class=\"line\">                        idx = i;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                for (int i = 1; i &lt; (int)word.length(); i++) &#123;</div><div class=\"line\">                    if (level[idx].find(word[i]) == level[idx].end()) &#123;</div><div class=\"line\">                        idx = -1;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (idx != -1) &#123;</div><div class=\"line\">                    res.push_back(word);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a List of words, return the words that can be typed using letters of alphabet on only one rows of American keyboard like the image below.</p>\n<p>American keyboard:<br><img src=\"https://leetcode.com/static/images/problemset/keyboard.png\" alt=\"keyboard\"></p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [Hello, Alaska, Dad, Peace]</li>\n<li>Output: [Alaska, Dad]</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>You may use one character in the keyboard more than once.</li>\n<li>You may assume the input string will only contain letters of alphabet.</li>\n</ul>\n</blockquote>","more":"<p>It is Leetcode No.500, and it is a very easy problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) &#123;</div><div class=\"line\">            set&lt;char&gt; level[3];</div><div class=\"line\">            vector&lt;string&gt; res;</div><div class=\"line\"></div><div class=\"line\">            level[0].insert(&apos;q&apos;);</div><div class=\"line\">            level[0].insert(&apos;w&apos;);</div><div class=\"line\">            level[0].insert(&apos;e&apos;);</div><div class=\"line\">            level[0].insert(&apos;r&apos;);</div><div class=\"line\">            level[0].insert(&apos;t&apos;);</div><div class=\"line\">            level[0].insert(&apos;y&apos;);</div><div class=\"line\">            level[0].insert(&apos;u&apos;);</div><div class=\"line\">            level[0].insert(&apos;i&apos;);</div><div class=\"line\">            level[0].insert(&apos;o&apos;);</div><div class=\"line\">            level[0].insert(&apos;p&apos;);</div><div class=\"line\"></div><div class=\"line\">            level[0].insert(&apos;Q&apos;);</div><div class=\"line\">            level[0].insert(&apos;W&apos;);</div><div class=\"line\">            level[0].insert(&apos;E&apos;);</div><div class=\"line\">            level[0].insert(&apos;R&apos;);</div><div class=\"line\">            level[0].insert(&apos;T&apos;);</div><div class=\"line\">            level[0].insert(&apos;Y&apos;);</div><div class=\"line\">            level[0].insert(&apos;U&apos;);</div><div class=\"line\">            level[0].insert(&apos;I&apos;);</div><div class=\"line\">            level[0].insert(&apos;O&apos;);</div><div class=\"line\">            level[0].insert(&apos;P&apos;);</div><div class=\"line\"></div><div class=\"line\">            level[1].insert(&apos;a&apos;);</div><div class=\"line\">            level[1].insert(&apos;s&apos;);</div><div class=\"line\">            level[1].insert(&apos;d&apos;);</div><div class=\"line\">            level[1].insert(&apos;f&apos;);</div><div class=\"line\">            level[1].insert(&apos;g&apos;);</div><div class=\"line\">            level[1].insert(&apos;h&apos;);</div><div class=\"line\">            level[1].insert(&apos;j&apos;);</div><div class=\"line\">            level[1].insert(&apos;k&apos;);</div><div class=\"line\">            level[1].insert(&apos;l&apos;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            level[1].insert(&apos;A&apos;);</div><div class=\"line\">            level[1].insert(&apos;S&apos;);</div><div class=\"line\">            level[1].insert(&apos;D&apos;);</div><div class=\"line\">            level[1].insert(&apos;F&apos;);</div><div class=\"line\">            level[1].insert(&apos;G&apos;);</div><div class=\"line\">            level[1].insert(&apos;H&apos;);</div><div class=\"line\">            level[1].insert(&apos;J&apos;);</div><div class=\"line\">            level[1].insert(&apos;K&apos;);</div><div class=\"line\">            level[1].insert(&apos;L&apos;);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">            level[2].insert(&apos;z&apos;);</div><div class=\"line\">            level[2].insert(&apos;x&apos;);</div><div class=\"line\">            level[2].insert(&apos;c&apos;);</div><div class=\"line\">            level[2].insert(&apos;v&apos;);</div><div class=\"line\">            level[2].insert(&apos;b&apos;);</div><div class=\"line\">            level[2].insert(&apos;n&apos;);</div><div class=\"line\">            level[2].insert(&apos;m&apos;);</div><div class=\"line\"></div><div class=\"line\">            level[2].insert(&apos;Z&apos;);</div><div class=\"line\">            level[2].insert(&apos;X&apos;);</div><div class=\"line\">            level[2].insert(&apos;C&apos;);</div><div class=\"line\">            level[2].insert(&apos;V&apos;);</div><div class=\"line\">            level[2].insert(&apos;B&apos;);</div><div class=\"line\">            level[2].insert(&apos;N&apos;);</div><div class=\"line\">            level[2].insert(&apos;M&apos;);</div><div class=\"line\"></div><div class=\"line\">            for (auto word : words) &#123;</div><div class=\"line\">                int idx = -1;</div><div class=\"line\">                for (int i = 0; i &lt; 3; i++) &#123;</div><div class=\"line\">                    if (level[i].find(word[0]) != level[i].end()) &#123;</div><div class=\"line\">                        idx = i;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                for (int i = 1; i &lt; (int)word.length(); i++) &#123;</div><div class=\"line\">                    if (level[idx].find(word[i]) == level[idx].end()) &#123;</div><div class=\"line\">                        idx = -1;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (idx != -1) &#123;</div><div class=\"line\">                    res.push_back(word);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Longest Increasing Path in a Matrix","date":"2017-01-09T08:15:57.000Z","_content":"\n> Given an integer matrix, find the length of the longest increasing path.\n>\n> From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n>\n> Example 1:\n>\n> nums = [ [9,9,4], [6,6,8], [2,1,1] ]\n>\n> Return 4\n> The longest increasing path is [1, 2, 6, 9].\n>\n> Example 2:\n>\n> nums = [ [3,4,5], [3,2,6], [2,2,1] ]\n>\n> Return 4\n> The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n<!-- more -->\n\nThis is Leetcode 329, it's a classic DFS problem. And you can use more space to improve its performance.\n\nFor example, you can use two maxDepth array to store the max depth in current position and its direction.\n\nSo, its solution will be as following, (we use the build-in dfs function):\n\n```\nclass Solution {\n    public:\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\n            int rows = matrix.size();\n            if (!rows) return 0;\n            int cols = matrix[0].size();\n\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\n                if (dp[x][y]) return dp[x][y];\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n                for (auto &dir : dirs) {\n                    int xx = x + dir[0], yy = y + dir[1];\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\n                }\n                return ++dp[x][y];\n            };\n\n            int ret = 0;\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    ret = std::max(ret, dfs(i, j));\n                }\n            }\n\n            return ret;\n        }\n};\n```\n","source":"_posts/LongestIncreasingPathinaMatrix.md","raw":"---\ntitle: Longest Increasing Path in a Matrix\ndate: 2017-01-09 16:15:57\ntags:\n    - Depth-first Search\n    - Memoization\n    - Topological sort\n---\n\n> Given an integer matrix, find the length of the longest increasing path.\n>\n> From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n>\n> Example 1:\n>\n> nums = [ [9,9,4], [6,6,8], [2,1,1] ]\n>\n> Return 4\n> The longest increasing path is [1, 2, 6, 9].\n>\n> Example 2:\n>\n> nums = [ [3,4,5], [3,2,6], [2,2,1] ]\n>\n> Return 4\n> The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n\n<!-- more -->\n\nThis is Leetcode 329, it's a classic DFS problem. And you can use more space to improve its performance.\n\nFor example, you can use two maxDepth array to store the max depth in current position and its direction.\n\nSo, its solution will be as following, (we use the build-in dfs function):\n\n```\nclass Solution {\n    public:\n        int longestIncreasingPath(vector<vector<int>>& matrix) {\n            int rows = matrix.size();\n            if (!rows) return 0;\n            int cols = matrix[0].size();\n\n            vector<vector<int>> dp(rows, vector<int>(cols, 0));\n            std::function<int(int, int)> dfs = [&] (int x, int y) {\n                if (dp[x][y]) return dp[x][y];\n                vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n                for (auto &dir : dirs) {\n                    int xx = x + dir[0], yy = y + dir[1];\n                    if (xx < 0 || xx >= rows || yy < 0 || yy >= cols) continue;\n                    if (matrix[xx][yy] <= matrix[x][y]) continue;\n                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));\n                }\n                return ++dp[x][y];\n            };\n\n            int ret = 0;\n            for (int i = 0; i < rows; ++i) {\n                for (int j = 0; j < cols; ++j) {\n                    ret = std::max(ret, dfs(i, j));\n                }\n            }\n\n            return ret;\n        }\n};\n```\n","slug":"LongestIncreasingPathinaMatrix","published":1,"updated":"2017-01-09T08:24:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw6002bg5f40gndouwz","content":"<blockquote>\n<p>Given an integer matrix, find the length of the longest increasing path.</p>\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n<p>Example 1:</p>\n<p>nums = [ [9,9,4], [6,6,8], [2,1,1] ]</p>\n<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>\n<p>Example 2:</p>\n<p>nums = [ [3,4,5], [3,2,6], [2,2,1] ]</p>\n<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 329, its a classic DFS problem. And you can use more space to improve its performance.</p>\n<p>For example, you can use two maxDepth array to store the max depth in current position and its direction.</p>\n<p>So, its solution will be as following, (we use the build-in dfs function):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class=\"line\">            int rows = matrix.size();</div><div class=\"line\">            if (!rows) return 0;</div><div class=\"line\">            int cols = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));</div><div class=\"line\">            std::function&lt;int(int, int)&gt; dfs = [&amp;] (int x, int y) &#123;</div><div class=\"line\">                if (dp[x][y]) return dp[x][y];</div><div class=\"line\">                vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</div><div class=\"line\">                for (auto &amp;dir : dirs) &#123;</div><div class=\"line\">                    int xx = x + dir[0], yy = y + dir[1];</div><div class=\"line\">                    if (xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue;</div><div class=\"line\">                    if (matrix[xx][yy] &lt;= matrix[x][y]) continue;</div><div class=\"line\">                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));</div><div class=\"line\">                &#125;</div><div class=\"line\">                return ++dp[x][y];</div><div class=\"line\">            &#125;;</div><div class=\"line\"></div><div class=\"line\">            int ret = 0;</div><div class=\"line\">            for (int i = 0; i &lt; rows; ++i) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; cols; ++j) &#123;</div><div class=\"line\">                    ret = std::max(ret, dfs(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given an integer matrix, find the length of the longest increasing path.</p>\n<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>\n<p>Example 1:</p>\n<p>nums = [ [9,9,4], [6,6,8], [2,1,1] ]</p>\n<p>Return 4<br>The longest increasing path is [1, 2, 6, 9].</p>\n<p>Example 2:</p>\n<p>nums = [ [3,4,5], [3,2,6], [2,2,1] ]</p>\n<p>Return 4<br>The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>\n</blockquote>","more":"<p>This is Leetcode 329, its a classic DFS problem. And you can use more space to improve its performance.</p>\n<p>For example, you can use two maxDepth array to store the max depth in current position and its direction.</p>\n<p>So, its solution will be as following, (we use the build-in dfs function):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</div><div class=\"line\">            int rows = matrix.size();</div><div class=\"line\">            if (!rows) return 0;</div><div class=\"line\">            int cols = matrix[0].size();</div><div class=\"line\"></div><div class=\"line\">            vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, 0));</div><div class=\"line\">            std::function&lt;int(int, int)&gt; dfs = [&amp;] (int x, int y) &#123;</div><div class=\"line\">                if (dp[x][y]) return dp[x][y];</div><div class=\"line\">                vector&lt;vector&lt;int&gt;&gt; dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;</div><div class=\"line\">                for (auto &amp;dir : dirs) &#123;</div><div class=\"line\">                    int xx = x + dir[0], yy = y + dir[1];</div><div class=\"line\">                    if (xx &lt; 0 || xx &gt;= rows || yy &lt; 0 || yy &gt;= cols) continue;</div><div class=\"line\">                    if (matrix[xx][yy] &lt;= matrix[x][y]) continue;</div><div class=\"line\">                    dp[x][y] = std::max(dp[x][y], dfs(xx, yy));</div><div class=\"line\">                &#125;</div><div class=\"line\">                return ++dp[x][y];</div><div class=\"line\">            &#125;;</div><div class=\"line\"></div><div class=\"line\">            int ret = 0;</div><div class=\"line\">            for (int i = 0; i &lt; rows; ++i) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; cols; ++j) &#123;</div><div class=\"line\">                    ret = std::max(ret, dfs(i, j));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return ret;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Lonely Pixel II","date":"2017-03-06T05:44:35.000Z","_content":"\n> Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:\n>\n> + Row R and column C both contain exactly N black pixels.\n> + For all rows that have a black pixel at column C, they should be exactly the same as row R\n>\n> The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively.\n>\n> Example:\n>```\nInput:\n[\n    ['W', 'B', 'W', 'B', 'B', 'W'],\n    ['W', 'B', 'W', 'B', 'B', 'W'],\n    ['W', 'B', 'W', 'B', 'B', 'W'],\n    ['W', 'W', 'B', 'W', 'B', 'W']\n]\nN = 3\nOutput: 6\nExplanation: All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).\n          0    1    2    3    4    5         column index\n    [\n0       ['W', 'B', 'W', 'B', 'B', 'W'],\n1       ['W', 'B', 'W', 'B', 'B', 'W'],\n2       ['W', 'B', 'W', 'B', 'B', 'W'],\n3       ['W', 'W', 'B', 'W', 'B', 'W']\n    ]\nrow index\n\nTake 'B' at row R = 0 and column C = 1 as an example:\nRule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.\nRule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.\n```\n> Note:\n> + The range of width and height of the input 2D array is [1,200].\n\n<!--more-->\n\nThis is Leetcode No.533 , and for some reason I miss the time I can submit my answer... So, here is my answer and I don't know whether it is correct...\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int findBlackPixel(vector<vector<char> >& picture, int N) {\n        int res = 0;\n        for (int idx = 0; idx < (int)picture.size(); idx++) {\n            for (int idy = 0; idy < (int)picture[0].size(); idy++) {\n                if (picture[idx][idy] == 'B' && check(picture, idx, idy, N)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n\n    bool check(vector<vector<char> > picture, int idx, int idy, int N) {\n        int res = 0;\n        for (int i = 0; i < (int)picture.size(); i++) {\n            if (picture[idx][i] == 'B') {\n                res++;\n            }\n        }\n        if (res != N) {\n            return false;\n        }\n        res = 0;\n        for (int i = 0; i < (int)picture[0].size(); i++) {\n            if (picture[i][idy] == 'B') {\n                res++;\n            }\n        }\n        return res == N;\n    }\n};\n```\n","source":"_posts/LonelyPixelII.md","raw":"---\ntitle: Lonely Pixel II\ndate: 2017-03-06 13:44:35\ntags:\n    - Array\n    - Depth-first Search\n---\n\n> Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:\n>\n> + Row R and column C both contain exactly N black pixels.\n> + For all rows that have a black pixel at column C, they should be exactly the same as row R\n>\n> The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively.\n>\n> Example:\n>```\nInput:\n[\n    ['W', 'B', 'W', 'B', 'B', 'W'],\n    ['W', 'B', 'W', 'B', 'B', 'W'],\n    ['W', 'B', 'W', 'B', 'B', 'W'],\n    ['W', 'W', 'B', 'W', 'B', 'W']\n]\nN = 3\nOutput: 6\nExplanation: All the bold 'B' are the black pixels we need (all 'B's at column 1 and 3).\n          0    1    2    3    4    5         column index\n    [\n0       ['W', 'B', 'W', 'B', 'B', 'W'],\n1       ['W', 'B', 'W', 'B', 'B', 'W'],\n2       ['W', 'B', 'W', 'B', 'B', 'W'],\n3       ['W', 'W', 'B', 'W', 'B', 'W']\n    ]\nrow index\n\nTake 'B' at row R = 0 and column C = 1 as an example:\nRule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.\nRule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.\n```\n> Note:\n> + The range of width and height of the input 2D array is [1,200].\n\n<!--more-->\n\nThis is Leetcode No.533 , and for some reason I miss the time I can submit my answer... So, here is my answer and I don't know whether it is correct...\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int findBlackPixel(vector<vector<char> >& picture, int N) {\n        int res = 0;\n        for (int idx = 0; idx < (int)picture.size(); idx++) {\n            for (int idy = 0; idy < (int)picture[0].size(); idy++) {\n                if (picture[idx][idy] == 'B' && check(picture, idx, idy, N)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n\n    bool check(vector<vector<char> > picture, int idx, int idy, int N) {\n        int res = 0;\n        for (int i = 0; i < (int)picture.size(); i++) {\n            if (picture[idx][i] == 'B') {\n                res++;\n            }\n        }\n        if (res != N) {\n            return false;\n        }\n        res = 0;\n        for (int i = 0; i < (int)picture[0].size(); i++) {\n            if (picture[i][idy] == 'B') {\n                res++;\n            }\n        }\n        return res == N;\n    }\n};\n```\n","slug":"LonelyPixelII","published":1,"updated":"2017-03-08T02:22:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw8002eg5f4zt6z83tu","content":"<blockquote>\n<p>Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:</p>\n<ul>\n<li>Row R and column C both contain exactly N black pixels.</li>\n<li>For all rows that have a black pixel at column C, they should be exactly the same as row R</li>\n</ul>\n<p>The picture is represented by a 2D char array consisting of B and W, which means black and white pixels respectively.</p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">[</div><div class=\"line\">    [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">    [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">    [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">    [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]</div><div class=\"line\">]</div><div class=\"line\">N = 3</div><div class=\"line\">Output: 6</div><div class=\"line\">Explanation: All the bold &apos;B&apos; are the black pixels we need (all &apos;B&apos;s at column 1 and 3).</div><div class=\"line\">          0    1    2    3    4    5         column index</div><div class=\"line\">    [</div><div class=\"line\">0       [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">1       [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">2       [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">3       [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]</div><div class=\"line\">    ]</div><div class=\"line\">row index</div><div class=\"line\"></div><div class=\"line\">Take &apos;B&apos; at row R = 0 and column C = 1 as an example:</div><div class=\"line\">Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.</div><div class=\"line\">Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The range of width and height of the input 2D array is [1,200].</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.533 , and for some reason I miss the time I can submit my answer So, here is my answer and I dont know whether it is correct</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int findBlackPixel(vector&lt;vector&lt;char&gt; &gt;&amp; picture, int N) &#123;</div><div class=\"line\">        int res = 0;</div><div class=\"line\">        for (int idx = 0; idx &lt; (int)picture.size(); idx++) &#123;</div><div class=\"line\">            for (int idy = 0; idy &lt; (int)picture[0].size(); idy++) &#123;</div><div class=\"line\">                if (picture[idx][idy] == &apos;B&apos; &amp;&amp; check(picture, idx, idy, N)) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool check(vector&lt;vector&lt;char&gt; &gt; picture, int idx, int idy, int N) &#123;</div><div class=\"line\">        int res = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)picture.size(); i++) &#123;</div><div class=\"line\">            if (picture[idx][i] == &apos;B&apos;) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (res != N) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        res = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)picture[0].size(); i++) &#123;</div><div class=\"line\">            if (picture[i][idy] == &apos;B&apos;) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res == N;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:</p>\n<ul>\n<li>Row R and column C both contain exactly N black pixels.</li>\n<li>For all rows that have a black pixel at column C, they should be exactly the same as row R</li>\n</ul>\n<p>The picture is represented by a 2D char array consisting of B and W, which means black and white pixels respectively.</p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">[</div><div class=\"line\">    [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">    [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">    [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">    [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]</div><div class=\"line\">]</div><div class=\"line\">N = 3</div><div class=\"line\">Output: 6</div><div class=\"line\">Explanation: All the bold &apos;B&apos; are the black pixels we need (all &apos;B&apos;s at column 1 and 3).</div><div class=\"line\">          0    1    2    3    4    5         column index</div><div class=\"line\">    [</div><div class=\"line\">0       [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">1       [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">2       [&apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;B&apos;, &apos;W&apos;],</div><div class=\"line\">3       [&apos;W&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;, &apos;B&apos;, &apos;W&apos;]</div><div class=\"line\">    ]</div><div class=\"line\">row index</div><div class=\"line\"></div><div class=\"line\">Take &apos;B&apos; at row R = 0 and column C = 1 as an example:</div><div class=\"line\">Rule 1, row R = 0 and column C = 1 both have exactly N = 3 black pixels.</div><div class=\"line\">Rule 2, the rows have black pixel at column C = 1 are row 0, row 1 and row 2. They are exactly the same as row R = 0.</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The range of width and height of the input 2D array is [1,200].</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.533 , and for some reason I miss the time I can submit my answer So, here is my answer and I dont know whether it is correct</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int findBlackPixel(vector&lt;vector&lt;char&gt; &gt;&amp; picture, int N) &#123;</div><div class=\"line\">        int res = 0;</div><div class=\"line\">        for (int idx = 0; idx &lt; (int)picture.size(); idx++) &#123;</div><div class=\"line\">            for (int idy = 0; idy &lt; (int)picture[0].size(); idy++) &#123;</div><div class=\"line\">                if (picture[idx][idy] == &apos;B&apos; &amp;&amp; check(picture, idx, idy, N)) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    bool check(vector&lt;vector&lt;char&gt; &gt; picture, int idx, int idy, int N) &#123;</div><div class=\"line\">        int res = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)picture.size(); i++) &#123;</div><div class=\"line\">            if (picture[idx][i] == &apos;B&apos;) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (res != N) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        res = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)picture[0].size(); i++) &#123;</div><div class=\"line\">            if (picture[i][idy] == &apos;B&apos;) &#123;</div><div class=\"line\">                res++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return res == N;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Longest Increasing Subsequence","date":"2017-03-22T07:49:41.000Z","_content":"\n> Given an unsorted array of integers, find the length of longest increasing subsequence.\n>\n> For example,\n> Given [10, 9, 2, 5, 3, 7, 101, 18],\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n>\n> Your algorithm should run in O(n2) complexity.\n>\n> Follow up: Could you improve it to O(n log n) time complexity?\n\n<!--more-->\n\nThis is Leetcode No.300. It is a DP problem. So you can quickly find the O(n^3) solution.\n\nBy using for loop for three times. You can find the result. But if you use a DP array to store the result. You can improve the time complex to O(n^2).\n\nHere is my solution:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int lengthOfLIS(vector<int> nums) {\n            vector<int> DP;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                DP.push_back(1);\n            }\n            for (int i = 1; i < (int)nums.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                    if (nums[i] > nums[j]) {\n                        DP[i] = max(DP[i], DP[j] + 1);\n                    }\n                }\n            }\n            int res = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res = max(DP[i], res);\n\n            }\n            return res;\n        }\n};\n```\n\nBut I can't find the O(nlogn) method until I find the solution in the Discuss channel.\n\n```\nint lengthOfLIS(vector<int>& nums) {\n    vector<int> res;\n    for(int i=0; i<nums.size(); i++) {\n        auto it = std::lower_bound(res.begin(), res.end(), nums[i]);\n        if(it==res.end()) res.push_back(nums[i]);\n        else *it = nums[i];\n    }\n    return res.size();\n}\n```\n\nIt is a great method!\n","source":"_posts/LongestIncreasingSubsequence.md","raw":"---\ntitle: Longest Increasing Subsequence\ndate: 2017-03-22 15:49:41\ntags:\n    - Binary Search\n    - Dynamic Programming\n---\n\n> Given an unsorted array of integers, find the length of longest increasing subsequence.\n>\n> For example,\n> Given [10, 9, 2, 5, 3, 7, 101, 18],\n> The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.\n>\n> Your algorithm should run in O(n2) complexity.\n>\n> Follow up: Could you improve it to O(n log n) time complexity?\n\n<!--more-->\n\nThis is Leetcode No.300. It is a DP problem. So you can quickly find the O(n^3) solution.\n\nBy using for loop for three times. You can find the result. But if you use a DP array to store the result. You can improve the time complex to O(n^2).\n\nHere is my solution:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int lengthOfLIS(vector<int> nums) {\n            vector<int> DP;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                DP.push_back(1);\n            }\n            for (int i = 1; i < (int)nums.size(); i++) {\n                for (int j = 0; j < i; j++) {\n                    if (nums[i] > nums[j]) {\n                        DP[i] = max(DP[i], DP[j] + 1);\n                    }\n                }\n            }\n            int res = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res = max(DP[i], res);\n\n            }\n            return res;\n        }\n};\n```\n\nBut I can't find the O(nlogn) method until I find the solution in the Discuss channel.\n\n```\nint lengthOfLIS(vector<int>& nums) {\n    vector<int> res;\n    for(int i=0; i<nums.size(); i++) {\n        auto it = std::lower_bound(res.begin(), res.end(), nums[i]);\n        if(it==res.end()) res.push_back(nums[i]);\n        else *it = nums[i];\n    }\n    return res.size();\n}\n```\n\nIt is a great method!\n","slug":"LongestIncreasingSubsequence","published":1,"updated":"2017-03-22T09:00:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatw9002gg5f4cax8w5ix","content":"<blockquote>\n<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>\n<p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>\n<p>Your algorithm should run in O(n2) complexity.</p>\n<p>Follow up: Could you improve it to O(n log n) time complexity?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.300. It is a DP problem. So you can quickly find the O(n^3) solution.</p>\n<p>By using for loop for three times. You can find the result. But if you use a DP array to store the result. You can improve the time complex to O(n^2).</p>\n<p>Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int lengthOfLIS(vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; DP;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                DP.push_back(1);</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; i; j++) &#123;</div><div class=\"line\">                    if (nums[i] &gt; nums[j]) &#123;</div><div class=\"line\">                        DP[i] = max(DP[i], DP[j] + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = max(DP[i], res);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But I cant find the O(nlogn) method until I find the solution in the Discuss channel.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    vector&lt;int&gt; res;</div><div class=\"line\">    for(int i=0; i&lt;nums.size(); i++) &#123;</div><div class=\"line\">        auto it = std::lower_bound(res.begin(), res.end(), nums[i]);</div><div class=\"line\">        if(it==res.end()) res.push_back(nums[i]);</div><div class=\"line\">        else *it = nums[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res.size();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>It is a great method!</p>\n","excerpt":"<blockquote>\n<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>\n<p>For example,<br>Given [10, 9, 2, 5, 3, 7, 101, 18],<br>The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>\n<p>Your algorithm should run in O(n2) complexity.</p>\n<p>Follow up: Could you improve it to O(n log n) time complexity?</p>\n</blockquote>","more":"<p>This is Leetcode No.300. It is a DP problem. So you can quickly find the O(n^3) solution.</p>\n<p>By using for loop for three times. You can find the result. But if you use a DP array to store the result. You can improve the time complex to O(n^2).</p>\n<p>Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int lengthOfLIS(vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; DP;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                DP.push_back(1);</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; i; j++) &#123;</div><div class=\"line\">                    if (nums[i] &gt; nums[j]) &#123;</div><div class=\"line\">                        DP[i] = max(DP[i], DP[j] + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = max(DP[i], res);</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But I cant find the O(nlogn) method until I find the solution in the Discuss channel.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    vector&lt;int&gt; res;</div><div class=\"line\">    for(int i=0; i&lt;nums.size(); i++) &#123;</div><div class=\"line\">        auto it = std::lower_bound(res.begin(), res.end(), nums[i]);</div><div class=\"line\">        if(it==res.end()) res.push_back(nums[i]);</div><div class=\"line\">        else *it = nums[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res.size();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>It is a great method!</p>"},{"title":"Matchsticks to Square","date":"2017-02-04T05:50:52.000Z","_content":"\n> Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n>\n> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n>\n> Example 1:\n>\n> + Input: [1,1,2,2,2]\n> + Output: true\n> + Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n>\n> Example 2:\n>\n> + Input: [3,3,3,3,4]\n> + Output: false\n> + Explanation: You cannot find a way to form a square with all the matchsticks.\n>\n> Note:\n> + The length sum of the given matchsticks is in the range of 0 to 10^9.\n> + The length of the given matchstick array will not exceed 15.\n\n<!--more-->\n\nThis is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length can't be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.\n\nSo, the problem becomes to find that if the array can be reformed by four (total length)/4.\n\nMaybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:\n\n```\nbool _calcLength(vector<int>& nums, int target, int currentNum) {\n    if (currentNum == 3) {\n        return true;\n    } else {\n        int startIdx = 0, endIdx = 0, currentSum = 0;\n        while (visited[startIdx] == 1) {\n            startIdx++;\n        }\n\n        endIdx = startIdx, currentSum = nums[startIdx];\n        visited[startIdx] = 1;\n        while (endIdx < (int)nums.size() && startIdx <= endIdx) {\n            if (visited[endIdx] == 1) {\n                endIdx++;\n                continue;\n            }\n            if (visited[startIdx] == 1) {\n                startIdx++;\n                continue;\n            }\n\n            if (currentSum > target) {\n                currentSum = currentSum - nums[startIdx];\n                visited[startIdx] = 0;\n                startIdx++;\n            } else if (currentSum == target) {\n                return _calcLength(nums, target, currentNum + 1);\n            } else {\n                currentSum = currentSum + nums[endIdx];\n                visited[endIdx] = 1;\n                endIdx++;\n            }\n        }\n        return false;\n    }\n}\n```\n\nBut I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.\n\nSo, it must be some other solution. Then I find a blur force solution.\n\n```\nclass Solution {\n    public:\n        bool makesquare(vector<int>& nums) {\n            if (nums.size() < 4) {\n                return false;\n            }\n\n            long long totalLength = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                totalLength = totalLength + nums[i];\n            }\n\n            int sums[4];\n            memset(sums, 0, sizeof(sums));\n\n            if (totalLength % 4 != 0) {\n                return false;\n            } else {\n                return _calcLength(nums, sums, 0, totalLength/4);\n            }\n        }\n\n        bool _calcLength(vector<int>& nums, int sums[], int idx, int target) {\n            if (idx == (int)nums.size()) {\n                if (sums[0] == target && sums[1] == target && sums[2] == target) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n            for (int i = 0; i < 4; i++) {\n                if (sums[i] + nums[idx] > target) {\n                    continue;\n                }\n                sums[i] = sums[i] + nums[idx];\n                if (_calcLength(nums, sums, idx + 1, target)) {\n                    return true;\n                }\n                sums[i] = sums[i] - nums[idx];\n            }\n            return false;\n        }\n};\n```\n\nIt simply gets AC.\n","source":"_posts/MatchstickstoSquare.md","raw":"---\ntitle: Matchsticks to Square\ndate: 2017-02-04 13:50:52\ntags:\n    - Depth-first Search\n---\n\n> Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n>\n> Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n>\n> Example 1:\n>\n> + Input: [1,1,2,2,2]\n> + Output: true\n> + Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n>\n> Example 2:\n>\n> + Input: [3,3,3,3,4]\n> + Output: false\n> + Explanation: You cannot find a way to form a square with all the matchsticks.\n>\n> Note:\n> + The length sum of the given matchsticks is in the range of 0 to 10^9.\n> + The length of the given matchstick array will not exceed 15.\n\n<!--more-->\n\nThis is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length can't be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.\n\nSo, the problem becomes to find that if the array can be reformed by four (total length)/4.\n\nMaybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:\n\n```\nbool _calcLength(vector<int>& nums, int target, int currentNum) {\n    if (currentNum == 3) {\n        return true;\n    } else {\n        int startIdx = 0, endIdx = 0, currentSum = 0;\n        while (visited[startIdx] == 1) {\n            startIdx++;\n        }\n\n        endIdx = startIdx, currentSum = nums[startIdx];\n        visited[startIdx] = 1;\n        while (endIdx < (int)nums.size() && startIdx <= endIdx) {\n            if (visited[endIdx] == 1) {\n                endIdx++;\n                continue;\n            }\n            if (visited[startIdx] == 1) {\n                startIdx++;\n                continue;\n            }\n\n            if (currentSum > target) {\n                currentSum = currentSum - nums[startIdx];\n                visited[startIdx] = 0;\n                startIdx++;\n            } else if (currentSum == target) {\n                return _calcLength(nums, target, currentNum + 1);\n            } else {\n                currentSum = currentSum + nums[endIdx];\n                visited[endIdx] = 1;\n                endIdx++;\n            }\n        }\n        return false;\n    }\n}\n```\n\nBut I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.\n\nSo, it must be some other solution. Then I find a blur force solution.\n\n```\nclass Solution {\n    public:\n        bool makesquare(vector<int>& nums) {\n            if (nums.size() < 4) {\n                return false;\n            }\n\n            long long totalLength = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                totalLength = totalLength + nums[i];\n            }\n\n            int sums[4];\n            memset(sums, 0, sizeof(sums));\n\n            if (totalLength % 4 != 0) {\n                return false;\n            } else {\n                return _calcLength(nums, sums, 0, totalLength/4);\n            }\n        }\n\n        bool _calcLength(vector<int>& nums, int sums[], int idx, int target) {\n            if (idx == (int)nums.size()) {\n                if (sums[0] == target && sums[1] == target && sums[2] == target) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n\n            for (int i = 0; i < 4; i++) {\n                if (sums[i] + nums[idx] > target) {\n                    continue;\n                }\n                sums[i] = sums[i] + nums[idx];\n                if (_calcLength(nums, sums, idx + 1, target)) {\n                    return true;\n                }\n                sums[i] = sums[i] - nums[idx];\n            }\n            return false;\n        }\n};\n```\n\nIt simply gets AC.\n","slug":"MatchstickstoSquare","published":1,"updated":"2017-02-04T07:49:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwa002jg5f45x91xf36","content":"<blockquote>\n<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>\n<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,1,2,2,2]</li>\n<li>Output: true</li>\n<li>Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [3,3,3,3,4]</li>\n<li>Output: false</li>\n<li>Explanation: You cannot find a way to form a square with all the matchsticks.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length sum of the given matchsticks is in the range of 0 to 10^9.</li>\n<li>The length of the given matchstick array will not exceed 15.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length cant be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.</p>\n<p>So, the problem becomes to find that if the array can be reformed by four (total length)/4.</p>\n<p>Maybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calcLength(vector&lt;int&gt;&amp; nums, int target, int currentNum) &#123;</div><div class=\"line\">    if (currentNum == 3) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        int startIdx = 0, endIdx = 0, currentSum = 0;</div><div class=\"line\">        while (visited[startIdx] == 1) &#123;</div><div class=\"line\">            startIdx++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        endIdx = startIdx, currentSum = nums[startIdx];</div><div class=\"line\">        visited[startIdx] = 1;</div><div class=\"line\">        while (endIdx &lt; (int)nums.size() &amp;&amp; startIdx &lt;= endIdx) &#123;</div><div class=\"line\">            if (visited[endIdx] == 1) &#123;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (visited[startIdx] == 1) &#123;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentSum &gt; target) &#123;</div><div class=\"line\">                currentSum = currentSum - nums[startIdx];</div><div class=\"line\">                visited[startIdx] = 0;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">            &#125; else if (currentSum == target) &#123;</div><div class=\"line\">                return _calcLength(nums, target, currentNum + 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                currentSum = currentSum + nums[endIdx];</div><div class=\"line\">                visited[endIdx] = 1;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.</p>\n<p>So, it must be some other solution. Then I find a blur force solution.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 4) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long long totalLength = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                totalLength = totalLength + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int sums[4];</div><div class=\"line\">            memset(sums, 0, sizeof(sums));</div><div class=\"line\"></div><div class=\"line\">            if (totalLength % 4 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return _calcLength(nums, sums, 0, totalLength/4);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calcLength(vector&lt;int&gt;&amp; nums, int sums[], int idx, int target) &#123;</div><div class=\"line\">            if (idx == (int)nums.size()) &#123;</div><div class=\"line\">                if (sums[0] == target &amp;&amp; sums[1] == target &amp;&amp; sums[2] == target) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; 4; i++) &#123;</div><div class=\"line\">                if (sums[i] + nums[idx] &gt; target) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] + nums[idx];</div><div class=\"line\">                if (_calcLength(nums, sums, idx + 1, target)) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] - nums[idx];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It simply gets AC.</p>\n","excerpt":"<blockquote>\n<p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p>\n<p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,1,2,2,2]</li>\n<li>Output: true</li>\n<li>Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [3,3,3,3,4]</li>\n<li>Output: false</li>\n<li>Explanation: You cannot find a way to form a square with all the matchsticks.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The length sum of the given matchsticks is in the range of 0 to 10^9.</li>\n<li>The length of the given matchstick array will not exceed 15.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 473. It is an interesting problem. You can quickly find the condition which never make a square. When the total length cant be divided by 4. If it can be divided by 4, you also make sure the sticks can be reformed to that length.</p>\n<p>So, the problem becomes to find that if the array can be reformed by four (total length)/4.</p>\n<p>Maybe we can use the two pointer function here to find the suitable solution, use a visited array to mark every stick we used, it may use O(NlogN + 4N) time. As following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calcLength(vector&lt;int&gt;&amp; nums, int target, int currentNum) &#123;</div><div class=\"line\">    if (currentNum == 3) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        int startIdx = 0, endIdx = 0, currentSum = 0;</div><div class=\"line\">        while (visited[startIdx] == 1) &#123;</div><div class=\"line\">            startIdx++;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        endIdx = startIdx, currentSum = nums[startIdx];</div><div class=\"line\">        visited[startIdx] = 1;</div><div class=\"line\">        while (endIdx &lt; (int)nums.size() &amp;&amp; startIdx &lt;= endIdx) &#123;</div><div class=\"line\">            if (visited[endIdx] == 1) &#123;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (visited[startIdx] == 1) &#123;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentSum &gt; target) &#123;</div><div class=\"line\">                currentSum = currentSum - nums[startIdx];</div><div class=\"line\">                visited[startIdx] = 0;</div><div class=\"line\">                startIdx++;</div><div class=\"line\">            &#125; else if (currentSum == target) &#123;</div><div class=\"line\">                return _calcLength(nums, target, currentNum + 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                currentSum = currentSum + nums[endIdx];</div><div class=\"line\">                visited[endIdx] = 1;</div><div class=\"line\">                endIdx++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>But I failed, because when the case is [3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5], I have to find the 12, so I find [3, 3, 3, 3], and it will make the next failed.</p>\n<p>So, it must be some other solution. Then I find a blur force solution.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool makesquare(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 4) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            long long totalLength = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                totalLength = totalLength + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int sums[4];</div><div class=\"line\">            memset(sums, 0, sizeof(sums));</div><div class=\"line\"></div><div class=\"line\">            if (totalLength % 4 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return _calcLength(nums, sums, 0, totalLength/4);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calcLength(vector&lt;int&gt;&amp; nums, int sums[], int idx, int target) &#123;</div><div class=\"line\">            if (idx == (int)nums.size()) &#123;</div><div class=\"line\">                if (sums[0] == target &amp;&amp; sums[1] == target &amp;&amp; sums[2] == target) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; 4; i++) &#123;</div><div class=\"line\">                if (sums[i] + nums[idx] &gt; target) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] + nums[idx];</div><div class=\"line\">                if (_calcLength(nums, sums, idx + 1, target)) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125;</div><div class=\"line\">                sums[i] = sums[i] - nums[idx];</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It simply gets AC.</p>"},{"title":"Max Consecutive Ones II","date":"2017-01-15T06:18:18.000Z","_content":"\n> Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n>\n> Example 1:\n>\n> Input: [1,0,1,1,0]\n> Output: 4\n> Explanation: Flip the first zero will get the the maximum number of consecutive 1s.\n> > After flipping, the maximum number of consecutive 1s is 4.\n>\n> Note:\n> + The input array will only contain 0 and 1.\n> + The length of input array is a positive integer and will not exceed 10,000\n>\n> Follow up:\n> What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?\n\n<!--more-->\n\nThis is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.\n\nFirst, I find a bad idea, I try to combine the nums like:\n```\n1 0 1 1 0 1 => 1 0 2 0 1\n```\n\nAnd try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.\n```\nnums: 1 0 1 1 0 1\nDP 1: 1 2 3 4 0 1\nDP 2: 1 0 1 2 3 4\n```\n\nBecause only four situation will happen. 0 -> 1, 1 -> 1, 0 -> 0, 1 -> 0.\n\nSo the solution is following:\n\n```\nclass Solution {\n    public:\n        int findMaxConsecutiveOnes(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n            int res = 0, flag = 0; // flag 0 represents up use the flip\n            vector<int> flags1(nums.size() + 1), flags2(nums.size() + 1);\n            flags1.push_back(0);\n            flags2.push_back(0);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (nums[i] == 0) {\n                    if (flag == 0) {\n                        flag = 1;\n                        flags1[i+1] = flags1[i] + 1;\n                        flags2[i+1] = 0;\n                    } else {\n                        flag = 0;\n                        flags1[i+1] = 0;\n                        flags2[i+1] = flags2[i] + 1;\n                    }\n                } else {\n                    flags1[i+1] = flags1[i] + 1;\n                    flags2[i+1] = flags2[i] + 1;\n                }\n                res = max(res, max(flags1[i+1], flags2[i+1]));\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/MaxConsecutiveOnesII.md","raw":"---\ntitle: Max Consecutive Ones II\ndate: 2017-01-15 14:18:18\ntags:\n    - Dynamic Programming\n---\n\n> Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.\n>\n> Example 1:\n>\n> Input: [1,0,1,1,0]\n> Output: 4\n> Explanation: Flip the first zero will get the the maximum number of consecutive 1s.\n> > After flipping, the maximum number of consecutive 1s is 4.\n>\n> Note:\n> + The input array will only contain 0 and 1.\n> + The length of input array is a positive integer and will not exceed 10,000\n>\n> Follow up:\n> What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?\n\n<!--more-->\n\nThis is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.\n\nFirst, I find a bad idea, I try to combine the nums like:\n```\n1 0 1 1 0 1 => 1 0 2 0 1\n```\n\nAnd try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.\n```\nnums: 1 0 1 1 0 1\nDP 1: 1 2 3 4 0 1\nDP 2: 1 0 1 2 3 4\n```\n\nBecause only four situation will happen. 0 -> 1, 1 -> 1, 0 -> 0, 1 -> 0.\n\nSo the solution is following:\n\n```\nclass Solution {\n    public:\n        int findMaxConsecutiveOnes(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n            int res = 0, flag = 0; // flag 0 represents up use the flip\n            vector<int> flags1(nums.size() + 1), flags2(nums.size() + 1);\n            flags1.push_back(0);\n            flags2.push_back(0);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (nums[i] == 0) {\n                    if (flag == 0) {\n                        flag = 1;\n                        flags1[i+1] = flags1[i] + 1;\n                        flags2[i+1] = 0;\n                    } else {\n                        flag = 0;\n                        flags1[i+1] = 0;\n                        flags2[i+1] = flags2[i] + 1;\n                    }\n                } else {\n                    flags1[i+1] = flags1[i] + 1;\n                    flags2[i+1] = flags2[i] + 1;\n                }\n                res = max(res, max(flags1[i+1], flags2[i+1]));\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"MaxConsecutiveOnesII","published":1,"updated":"2017-01-15T06:31:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwb002lg5f4x5a1lzom","content":"<blockquote>\n<p>Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.</p>\n<p>Example 1:</p>\n<p>Input: [1,0,1,1,0]<br>Output: 4<br>Explanation: Flip the first zero will get the the maximum number of consecutive 1s.</p>\n<blockquote>\n<p>After flipping, the maximum number of consecutive 1s is 4.</p>\n</blockquote>\n<p>Note:</p>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<p>Follow up:<br>What if the input numbers come in one by one as an infinite stream? In other words, you cant store all numbers coming from the stream as its too large to hold in memory. Could you solve it efficiently?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.</p>\n<p>First, I find a bad idea, I try to combine the nums like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">1 0 1 1 0 1 =&gt; 1 0 2 0 1</div></pre></td></tr></table></figure></p>\n<p>And try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">nums: 1 0 1 1 0 1</div><div class=\"line\">DP 1: 1 2 3 4 0 1</div><div class=\"line\">DP 2: 1 0 1 2 3 4</div></pre></td></tr></table></figure></p>\n<p>Because only four situation will happen. 0 -&gt; 1, 1 -&gt; 1, 0 -&gt; 0, 1 -&gt; 0.</p>\n<p>So the solution is following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int res = 0, flag = 0; // flag 0 represents up use the flip</div><div class=\"line\">            vector&lt;int&gt; flags1(nums.size() + 1), flags2(nums.size() + 1);</div><div class=\"line\">            flags1.push_back(0);</div><div class=\"line\">            flags2.push_back(0);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] == 0) &#123;</div><div class=\"line\">                    if (flag == 0) &#123;</div><div class=\"line\">                        flag = 1;</div><div class=\"line\">                        flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                        flags2[i+1] = 0;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        flag = 0;</div><div class=\"line\">                        flags1[i+1] = 0;</div><div class=\"line\">                        flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                    flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = max(res, max(flags1[i+1], flags2[i+1]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.</p>\n<p>Example 1:</p>\n<p>Input: [1,0,1,1,0]<br>Output: 4<br>Explanation: Flip the first zero will get the the maximum number of consecutive 1s.</p>\n<blockquote>\n<p>After flipping, the maximum number of consecutive 1s is 4.</p>\n</blockquote>\n<p>Note:</p>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n<p>Follow up:<br>What if the input numbers come in one by one as an infinite stream? In other words, you cant store all numbers coming from the stream as its too large to hold in memory. Could you solve it efficiently?</p>\n</blockquote>","more":"<p>This is a problem from Leetcode week contest, AKA No.487. And I think it is a DP problem.</p>\n<p>First, I find a bad idea, I try to combine the nums like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">1 0 1 1 0 1 =&gt; 1 0 2 0 1</div></pre></td></tr></table></figure></p>\n<p>And try to deal with the transformed array. But it is still a hard problem. So I think in the DP way. Because its number of situations is limited. So, I can use a two DP array to store the number currently.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">nums: 1 0 1 1 0 1</div><div class=\"line\">DP 1: 1 2 3 4 0 1</div><div class=\"line\">DP 2: 1 0 1 2 3 4</div></pre></td></tr></table></figure></p>\n<p>Because only four situation will happen. 0 -&gt; 1, 1 -&gt; 1, 0 -&gt; 0, 1 -&gt; 0.</p>\n<p>So the solution is following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int res = 0, flag = 0; // flag 0 represents up use the flip</div><div class=\"line\">            vector&lt;int&gt; flags1(nums.size() + 1), flags2(nums.size() + 1);</div><div class=\"line\">            flags1.push_back(0);</div><div class=\"line\">            flags2.push_back(0);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] == 0) &#123;</div><div class=\"line\">                    if (flag == 0) &#123;</div><div class=\"line\">                        flag = 1;</div><div class=\"line\">                        flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                        flags2[i+1] = 0;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        flag = 0;</div><div class=\"line\">                        flags1[i+1] = 0;</div><div class=\"line\">                        flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    flags1[i+1] = flags1[i] + 1;</div><div class=\"line\">                    flags2[i+1] = flags2[i] + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = max(res, max(flags1[i+1], flags2[i+1]));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Longest Word in Dictionary through Deleting","date":"2017-03-01T01:19:18.000Z","_content":"\n> Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n>\n> Example 1:\n>```\nInput:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n\nOutput:\n\"apple\"\n```\n> Example 2:\n>```\nInput:\ns = \"abpcplea\", d = [\"a\",\"b\",\"c\"]\n\nOutput:\n\"a\"\n```\n> Note:\n>\n>  + All the strings in the input will only contain lower-case letters.\n>  + The size of the dictionary won't exceed 1,000.\n>  + The length of all the strings in the input won't exceed 1,000.\n\n<!--more-->\n\nThis is Leetcode No.524, at first I thought that the problem is find the result string can be formed by the characters in the given str. So, I write this answer:\n\n```\nclass Solution {\n    public:\n        string findLongestWord(string str, vector<string>& dic) {\n            sort(dic.begin(), dic.end());\n\n            int chars[26] = {0}, maxLen = INT_MAX;\n            string res;\n\n            for (int i = 0; i < (int)str.length(); i++) {\n                chars[str[i] - 'a']++;\n            }\n\n            int tmp[26] = {0}, flag = 0;\n            for (int i = 0; i < (int)dic.size(); i++) {\n                flag = 1;\n                memset(tmp, 0, sizeof(tmp));\n                for (int j = 0; j < (int)dic[i].length(); j++) {\n                    tmp[dic[i][j] - 'a']++;\n                }\n\n                for (int j = 0; j < 26; j++) {\n                    if (tmp[j] > chars[j]) {\n                        flag = -1;\n                        break;\n                    } else {\n                        flag = flag + chars[j] - tmp[j];\n                    }\n                }\n\n                if (flag >= 0 && flag < maxLen) {\n                    maxLen = flag;\n                    res = dic[i];\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nBut, it get WA of cause. So I realize that I can only delete chars instead of change its order.\n\nSo, here you can use the two-pointers method. To make the code clean:\n\n```\nclass Solution {\n    public:\n        string findLongestWord(string str, vector<string>& dic) {\n            sort(dic.begin(), dic.end());\n\n            int chars[26] = {0}, maxLen = INT_MIN;\n            string res;\n\n            for (int i = 0; i < (int)str.length(); i++) {\n                chars[str[i] - 'a']++;\n            }\n\n            for (int i = 0; i < (int)dic.size(); i++) {\n                if (checkStr(str, dic[i], 0, 0)) {\n                    res = (int)dic[i].length() > maxLen ? dic[i] : res;\n                    maxLen = max((int)dic[i].length(), maxLen);\n                }\n            }\n\n            return res;\n        }\n\n        bool checkStr(string src, string des, int idx, int idy) {\n            if (des.length() > src.length()) {\n                return false;\n            }\n            if (idy == (int)des.length()) {\n                return true;\n            }\n            if (idx == (int)src.length()) {\n                return false;\n            }\n            if (src[idx] == des[idy]) {\n                return checkStr(src, des, idx + 1, idy + 1);\n            } else {\n                return checkStr(src, des, idx + 1, idy);\n            }\n        }\n};\n```\n\nI write code like this, but it gets a MLE... Absolutly the stack is overflow. So, I should improve the check method.\n\n```\nclass Solution {\n    public:\n        string findLongestWord(string str, vector<string>& dic) {\n            sort(dic.begin(), dic.end());\n\n            int chars[26] = {0}, maxLen = INT_MIN;\n            string res;\n\n            for (int i = 0; i < (int)str.length(); i++) {\n                chars[str[i] - 'a']++;\n            }\n\n            for (int i = 0; i < (int)dic.size(); i++) {\n                if (checkStr(str, dic[i], 0, 0)) {\n                    res = (int)dic[i].length() > maxLen ? dic[i] : res;\n                    maxLen = max((int)dic[i].length(), maxLen);\n                }\n            }\n\n            return res;\n        }\n\n        bool checkStr(string src, string des, int idx, int idy) {\n            if (des.length() > src.length()) {\n                return false;\n            }\n\n            while (idy < (int)des.length() && idx < (int)src.length()) {\n                if (src[idx] == des[idy]) {\n                    idx++;\n                    idy++;\n                } else {\n                    idx++;\n                }\n            }\n\n            if (idy == (int)des.length()) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n};\n```\n\nIt gets AC...\n","source":"_posts/LongestWordinDictionarythroughDeleting.md","raw":"---\ntitle: Longest Word in Dictionary through Deleting\ndate: 2017-03-01 09:19:18\ntags:\n    - Two Pointers\n    - Sort\n---\n\n> Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n>\n> Example 1:\n>```\nInput:\ns = \"abpcplea\", d = [\"ale\",\"apple\",\"monkey\",\"plea\"]\n\nOutput:\n\"apple\"\n```\n> Example 2:\n>```\nInput:\ns = \"abpcplea\", d = [\"a\",\"b\",\"c\"]\n\nOutput:\n\"a\"\n```\n> Note:\n>\n>  + All the strings in the input will only contain lower-case letters.\n>  + The size of the dictionary won't exceed 1,000.\n>  + The length of all the strings in the input won't exceed 1,000.\n\n<!--more-->\n\nThis is Leetcode No.524, at first I thought that the problem is find the result string can be formed by the characters in the given str. So, I write this answer:\n\n```\nclass Solution {\n    public:\n        string findLongestWord(string str, vector<string>& dic) {\n            sort(dic.begin(), dic.end());\n\n            int chars[26] = {0}, maxLen = INT_MAX;\n            string res;\n\n            for (int i = 0; i < (int)str.length(); i++) {\n                chars[str[i] - 'a']++;\n            }\n\n            int tmp[26] = {0}, flag = 0;\n            for (int i = 0; i < (int)dic.size(); i++) {\n                flag = 1;\n                memset(tmp, 0, sizeof(tmp));\n                for (int j = 0; j < (int)dic[i].length(); j++) {\n                    tmp[dic[i][j] - 'a']++;\n                }\n\n                for (int j = 0; j < 26; j++) {\n                    if (tmp[j] > chars[j]) {\n                        flag = -1;\n                        break;\n                    } else {\n                        flag = flag + chars[j] - tmp[j];\n                    }\n                }\n\n                if (flag >= 0 && flag < maxLen) {\n                    maxLen = flag;\n                    res = dic[i];\n                }\n            }\n\n            return res;\n        }\n};\n```\n\nBut, it get WA of cause. So I realize that I can only delete chars instead of change its order.\n\nSo, here you can use the two-pointers method. To make the code clean:\n\n```\nclass Solution {\n    public:\n        string findLongestWord(string str, vector<string>& dic) {\n            sort(dic.begin(), dic.end());\n\n            int chars[26] = {0}, maxLen = INT_MIN;\n            string res;\n\n            for (int i = 0; i < (int)str.length(); i++) {\n                chars[str[i] - 'a']++;\n            }\n\n            for (int i = 0; i < (int)dic.size(); i++) {\n                if (checkStr(str, dic[i], 0, 0)) {\n                    res = (int)dic[i].length() > maxLen ? dic[i] : res;\n                    maxLen = max((int)dic[i].length(), maxLen);\n                }\n            }\n\n            return res;\n        }\n\n        bool checkStr(string src, string des, int idx, int idy) {\n            if (des.length() > src.length()) {\n                return false;\n            }\n            if (idy == (int)des.length()) {\n                return true;\n            }\n            if (idx == (int)src.length()) {\n                return false;\n            }\n            if (src[idx] == des[idy]) {\n                return checkStr(src, des, idx + 1, idy + 1);\n            } else {\n                return checkStr(src, des, idx + 1, idy);\n            }\n        }\n};\n```\n\nI write code like this, but it gets a MLE... Absolutly the stack is overflow. So, I should improve the check method.\n\n```\nclass Solution {\n    public:\n        string findLongestWord(string str, vector<string>& dic) {\n            sort(dic.begin(), dic.end());\n\n            int chars[26] = {0}, maxLen = INT_MIN;\n            string res;\n\n            for (int i = 0; i < (int)str.length(); i++) {\n                chars[str[i] - 'a']++;\n            }\n\n            for (int i = 0; i < (int)dic.size(); i++) {\n                if (checkStr(str, dic[i], 0, 0)) {\n                    res = (int)dic[i].length() > maxLen ? dic[i] : res;\n                    maxLen = max((int)dic[i].length(), maxLen);\n                }\n            }\n\n            return res;\n        }\n\n        bool checkStr(string src, string des, int idx, int idy) {\n            if (des.length() > src.length()) {\n                return false;\n            }\n\n            while (idy < (int)des.length() && idx < (int)src.length()) {\n                if (src[idx] == des[idy]) {\n                    idx++;\n                    idy++;\n                } else {\n                    idx++;\n                }\n            }\n\n            if (idy == (int)des.length()) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n};\n```\n\nIt gets AC...\n","slug":"LongestWordinDictionarythroughDeleting","published":1,"updated":"2017-03-01T02:02:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwd002og5f4mkj239ev","content":"<blockquote>\n<p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">&quot;apple&quot;</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">&quot;a&quot;</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>All the strings in the input will only contain lower-case letters.</li>\n<li>The size of the dictionary wont exceed 1,000.</li>\n<li>The length of all the strings in the input wont exceed 1,000.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.524, at first I thought that the problem is find the result string can be formed by the characters in the given str. So, I write this answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string findLongestWord(string str, vector&lt;string&gt;&amp; dic) &#123;</div><div class=\"line\">            sort(dic.begin(), dic.end());</div><div class=\"line\"></div><div class=\"line\">            int chars[26] = &#123;0&#125;, maxLen = INT_MAX;</div><div class=\"line\">            string res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)str.length(); i++) &#123;</div><div class=\"line\">                chars[str[i] - &apos;a&apos;]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int tmp[26] = &#123;0&#125;, flag = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)dic.size(); i++) &#123;</div><div class=\"line\">                flag = 1;</div><div class=\"line\">                memset(tmp, 0, sizeof(tmp));</div><div class=\"line\">                for (int j = 0; j &lt; (int)dic[i].length(); j++) &#123;</div><div class=\"line\">                    tmp[dic[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    if (tmp[j] &gt; chars[j]) &#123;</div><div class=\"line\">                        flag = -1;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        flag = flag + chars[j] - tmp[j];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (flag &gt;= 0 &amp;&amp; flag &lt; maxLen) &#123;</div><div class=\"line\">                    maxLen = flag;</div><div class=\"line\">                    res = dic[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, it get WA of cause. So I realize that I can only delete chars instead of change its order.</p>\n<p>So, here you can use the two-pointers method. To make the code clean:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string findLongestWord(string str, vector&lt;string&gt;&amp; dic) &#123;</div><div class=\"line\">            sort(dic.begin(), dic.end());</div><div class=\"line\"></div><div class=\"line\">            int chars[26] = &#123;0&#125;, maxLen = INT_MIN;</div><div class=\"line\">            string res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)str.length(); i++) &#123;</div><div class=\"line\">                chars[str[i] - &apos;a&apos;]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)dic.size(); i++) &#123;</div><div class=\"line\">                if (checkStr(str, dic[i], 0, 0)) &#123;</div><div class=\"line\">                    res = (int)dic[i].length() &gt; maxLen ? dic[i] : res;</div><div class=\"line\">                    maxLen = max((int)dic[i].length(), maxLen);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkStr(string src, string des, int idx, int idy) &#123;</div><div class=\"line\">            if (des.length() &gt; src.length()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idy == (int)des.length()) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idx == (int)src.length()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (src[idx] == des[idy]) &#123;</div><div class=\"line\">                return checkStr(src, des, idx + 1, idy + 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return checkStr(src, des, idx + 1, idy);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>I write code like this, but it gets a MLE Absolutly the stack is overflow. So, I should improve the check method.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string findLongestWord(string str, vector&lt;string&gt;&amp; dic) &#123;</div><div class=\"line\">            sort(dic.begin(), dic.end());</div><div class=\"line\"></div><div class=\"line\">            int chars[26] = &#123;0&#125;, maxLen = INT_MIN;</div><div class=\"line\">            string res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)str.length(); i++) &#123;</div><div class=\"line\">                chars[str[i] - &apos;a&apos;]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)dic.size(); i++) &#123;</div><div class=\"line\">                if (checkStr(str, dic[i], 0, 0)) &#123;</div><div class=\"line\">                    res = (int)dic[i].length() &gt; maxLen ? dic[i] : res;</div><div class=\"line\">                    maxLen = max((int)dic[i].length(), maxLen);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkStr(string src, string des, int idx, int idy) &#123;</div><div class=\"line\">            if (des.length() &gt; src.length()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            while (idy &lt; (int)des.length() &amp;&amp; idx &lt; (int)src.length()) &#123;</div><div class=\"line\">                if (src[idx] == des[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (idy == (int)des.length()) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC</p>\n","excerpt":"<blockquote>\n<p>Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">&quot;apple&quot;</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">&quot;a&quot;</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>All the strings in the input will only contain lower-case letters.</li>\n<li>The size of the dictionary wont exceed 1,000.</li>\n<li>The length of all the strings in the input wont exceed 1,000.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.524, at first I thought that the problem is find the result string can be formed by the characters in the given str. So, I write this answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string findLongestWord(string str, vector&lt;string&gt;&amp; dic) &#123;</div><div class=\"line\">            sort(dic.begin(), dic.end());</div><div class=\"line\"></div><div class=\"line\">            int chars[26] = &#123;0&#125;, maxLen = INT_MAX;</div><div class=\"line\">            string res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)str.length(); i++) &#123;</div><div class=\"line\">                chars[str[i] - &apos;a&apos;]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int tmp[26] = &#123;0&#125;, flag = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)dic.size(); i++) &#123;</div><div class=\"line\">                flag = 1;</div><div class=\"line\">                memset(tmp, 0, sizeof(tmp));</div><div class=\"line\">                for (int j = 0; j &lt; (int)dic[i].length(); j++) &#123;</div><div class=\"line\">                    tmp[dic[i][j] - &apos;a&apos;]++;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                for (int j = 0; j &lt; 26; j++) &#123;</div><div class=\"line\">                    if (tmp[j] &gt; chars[j]) &#123;</div><div class=\"line\">                        flag = -1;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        flag = flag + chars[j] - tmp[j];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (flag &gt;= 0 &amp;&amp; flag &lt; maxLen) &#123;</div><div class=\"line\">                    maxLen = flag;</div><div class=\"line\">                    res = dic[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, it get WA of cause. So I realize that I can only delete chars instead of change its order.</p>\n<p>So, here you can use the two-pointers method. To make the code clean:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string findLongestWord(string str, vector&lt;string&gt;&amp; dic) &#123;</div><div class=\"line\">            sort(dic.begin(), dic.end());</div><div class=\"line\"></div><div class=\"line\">            int chars[26] = &#123;0&#125;, maxLen = INT_MIN;</div><div class=\"line\">            string res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)str.length(); i++) &#123;</div><div class=\"line\">                chars[str[i] - &apos;a&apos;]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)dic.size(); i++) &#123;</div><div class=\"line\">                if (checkStr(str, dic[i], 0, 0)) &#123;</div><div class=\"line\">                    res = (int)dic[i].length() &gt; maxLen ? dic[i] : res;</div><div class=\"line\">                    maxLen = max((int)dic[i].length(), maxLen);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkStr(string src, string des, int idx, int idy) &#123;</div><div class=\"line\">            if (des.length() &gt; src.length()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idy == (int)des.length()) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (idx == (int)src.length()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (src[idx] == des[idy]) &#123;</div><div class=\"line\">                return checkStr(src, des, idx + 1, idy + 1);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return checkStr(src, des, idx + 1, idy);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>I write code like this, but it gets a MLE Absolutly the stack is overflow. So, I should improve the check method.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string findLongestWord(string str, vector&lt;string&gt;&amp; dic) &#123;</div><div class=\"line\">            sort(dic.begin(), dic.end());</div><div class=\"line\"></div><div class=\"line\">            int chars[26] = &#123;0&#125;, maxLen = INT_MIN;</div><div class=\"line\">            string res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)str.length(); i++) &#123;</div><div class=\"line\">                chars[str[i] - &apos;a&apos;]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)dic.size(); i++) &#123;</div><div class=\"line\">                if (checkStr(str, dic[i], 0, 0)) &#123;</div><div class=\"line\">                    res = (int)dic[i].length() &gt; maxLen ? dic[i] : res;</div><div class=\"line\">                    maxLen = max((int)dic[i].length(), maxLen);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool checkStr(string src, string des, int idx, int idy) &#123;</div><div class=\"line\">            if (des.length() &gt; src.length()) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            while (idy &lt; (int)des.length() &amp;&amp; idx &lt; (int)src.length()) &#123;</div><div class=\"line\">                if (src[idx] == des[idy]) &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                    idy++;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    idx++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (idy == (int)des.length()) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC</p>"},{"title":"Maximum Product of Word Lengths","date":"2017-01-18T14:23:09.000Z","_content":"\n> Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n>\n> Example 1:\n>\n> + Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n> + Return 16 The two words can be \"abcw\", \"xtfn\".\n>\n> Example 2:\n>\n> + Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n> + Return 4 The two words can be \"ab\", \"cd\".\n>\n> Example 3:\n>\n> + Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n> + Return 0 No such pair of words.\n\n<!--more-->\n\nThis is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).\n\nI just use the simplest method to get AC...\n\n```\nclass Solution {\n    public:\n        int maxProduct(vector<string>& words) {\n            if (words.size() == 0) {\n                return 0;\n            }\n            vector<bitset<26> > wordsets;\n            for (unsigned int i = 0; i < words.size(); i++) {\n                wordsets.push_back(bitset<26>());\n                for (unsigned int j = 0; j < words[i].length(); j++) {\n                    wordsets[i][words[i][j] - 'a'] = 1;\n                }\n            }\n\n            int result = 0;\n            for (unsigned int i = 0; i < words.size() - 1; i++) {\n                for (unsigned int j = i + 1; j < words.size(); j++) {\n                    bitset<26> res = wordsets[i] ^ wordsets[j];\n                    if (res.count() == wordsets[i].count() + wordsets[j].count()) {\n                        result = max(int(words[i].length() * words[j].length()), result);\n                    }\n                }\n            }\n            return result;\n        }\n};\n```\n\nThat's so easy...\n","source":"_posts/MaximumProductofWordLengths.md","raw":"---\ntitle: Maximum Product of Word Lengths\ndate: 2017-01-18 22:23:09\ntags:\n    - Bitmap\n---\n\n> Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n>\n> Example 1:\n>\n> + Given [\"abcw\", \"baz\", \"foo\", \"bar\", \"xtfn\", \"abcdef\"]\n> + Return 16 The two words can be \"abcw\", \"xtfn\".\n>\n> Example 2:\n>\n> + Given [\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"]\n> + Return 4 The two words can be \"ab\", \"cd\".\n>\n> Example 3:\n>\n> + Given [\"a\", \"aa\", \"aaa\", \"aaaa\"]\n> + Return 0 No such pair of words.\n\n<!--more-->\n\nThis is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).\n\nI just use the simplest method to get AC...\n\n```\nclass Solution {\n    public:\n        int maxProduct(vector<string>& words) {\n            if (words.size() == 0) {\n                return 0;\n            }\n            vector<bitset<26> > wordsets;\n            for (unsigned int i = 0; i < words.size(); i++) {\n                wordsets.push_back(bitset<26>());\n                for (unsigned int j = 0; j < words[i].length(); j++) {\n                    wordsets[i][words[i][j] - 'a'] = 1;\n                }\n            }\n\n            int result = 0;\n            for (unsigned int i = 0; i < words.size() - 1; i++) {\n                for (unsigned int j = i + 1; j < words.size(); j++) {\n                    bitset<26> res = wordsets[i] ^ wordsets[j];\n                    if (res.count() == wordsets[i].count() + wordsets[j].count()) {\n                        result = max(int(words[i].length() * words[j].length()), result);\n                    }\n                }\n            }\n            return result;\n        }\n};\n```\n\nThat's so easy...\n","slug":"MaximumProductofWordLengths","published":1,"updated":"2017-01-27T14:08:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwh002qg5f4ui8hwu7e","content":"<blockquote>\n<p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>\n<p>Example 1:</p>\n<ul>\n<li>Given [abcw, baz, foo, bar, xtfn, abcdef]</li>\n<li>Return 16 The two words can be abcw, xtfn.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Given [a, ab, abc, d, cd, bcd, abcd]</li>\n<li>Return 4 The two words can be ab, cd.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Given [a, aa, aaa, aaaa]</li>\n<li>Return 0 No such pair of words.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).</p>\n<p>I just use the simplest method to get AC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProduct(vector&lt;string&gt;&amp; words) &#123;</div><div class=\"line\">            if (words.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            vector&lt;bitset&lt;26&gt; &gt; wordsets;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size(); i++) &#123;</div><div class=\"line\">                wordsets.push_back(bitset&lt;26&gt;());</div><div class=\"line\">                for (unsigned int j = 0; j &lt; words[i].length(); j++) &#123;</div><div class=\"line\">                    wordsets[i][words[i][j] - &apos;a&apos;] = 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int result = 0;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size() - 1; i++) &#123;</div><div class=\"line\">                for (unsigned int j = i + 1; j &lt; words.size(); j++) &#123;</div><div class=\"line\">                    bitset&lt;26&gt; res = wordsets[i] ^ wordsets[j];</div><div class=\"line\">                    if (res.count() == wordsets[i].count() + wordsets[j].count()) &#123;</div><div class=\"line\">                        result = max(int(words[i].length() * words[j].length()), result);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Thats so easy</p>\n","excerpt":"<blockquote>\n<p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p>\n<p>Example 1:</p>\n<ul>\n<li>Given [abcw, baz, foo, bar, xtfn, abcdef]</li>\n<li>Return 16 The two words can be abcw, xtfn.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Given [a, ab, abc, d, cd, bcd, abcd]</li>\n<li>Return 4 The two words can be ab, cd.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Given [a, aa, aaa, aaaa]</li>\n<li>Return 0 No such pair of words.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 318, and it is just a change from the common simulation problem(add some conditions).</p>\n<p>I just use the simplest method to get AC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int maxProduct(vector&lt;string&gt;&amp; words) &#123;</div><div class=\"line\">            if (words.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\">            vector&lt;bitset&lt;26&gt; &gt; wordsets;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size(); i++) &#123;</div><div class=\"line\">                wordsets.push_back(bitset&lt;26&gt;());</div><div class=\"line\">                for (unsigned int j = 0; j &lt; words[i].length(); j++) &#123;</div><div class=\"line\">                    wordsets[i][words[i][j] - &apos;a&apos;] = 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int result = 0;</div><div class=\"line\">            for (unsigned int i = 0; i &lt; words.size() - 1; i++) &#123;</div><div class=\"line\">                for (unsigned int j = i + 1; j &lt; words.size(); j++) &#123;</div><div class=\"line\">                    bitset&lt;26&gt; res = wordsets[i] ^ wordsets[j];</div><div class=\"line\">                    if (res.count() == wordsets[i].count() + wordsets[j].count()) &#123;</div><div class=\"line\">                        result = max(int(words[i].length() * words[j].length()), result);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return result;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Thats so easy</p>"},{"title":"Longest Palindromic Subsequence","date":"2017-02-22T05:41:22.000Z","_content":"\n\n> Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.\n>\n> Example 1:\n> + Input: \"bbbab\"\n> + Output: 4\n> + One possible longest palindromic subsequence is \"bbbb\".\n>\n> Example 2:\n> + Input: \"cbbd\"\n> + Output: 2\n> + One possible longest palindromic subsequence is \"bb\".\n\n<!--more-->\n\nThis is Leetcode No.516. As a DP problem the most important thing is to find out the relationship of the state transformation.\n\nSo, here we need to use a DP[idx][idy] to mark the longest palindromic subsequence between idx and idy.\n\nAnd we can find that:\n\n```\nDP[idx][idy] = (str[idx] == str[idy + 1] ? DP[idx + 1][idy - 1] + 2 : max(DP[idx][idy - 1], DP[idx + 1][idy]));\n```\n\nSo here comes our solution:\n\n```\nclass Solution {\n    public:\n        int longestPalindromeSubseq(string str) {\n            int DP[1001][1001];\n            memset(DP, 0, sizeof(DP));\n            for (int idx = str.length() - 1; idx >= 0; idx--) {\n                DP[idx][idx] = 1;\n                for (int idy = idx + 1; idy < (int)str.length(); idy++) {\n                    if (str[idx] == str[idy]) {\n                        DP[idx][idy] = DP[idx + 1][idy - 1] + 2;\n                    } else {\n                        DP[idx][idy] = max(DP[idx + 1][idy], DP[idx][idy - 1]);\n                    }\n                }\n            }\n            return DP[0][str.length() - 1];\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/LongestPalindromicSubsequence.md","raw":"---\ntitle: Longest Palindromic Subsequence\ndate: 2017-02-22 13:41:22\ntags:\n    - Dynamic Programming\n---\n\n\n> Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.\n>\n> Example 1:\n> + Input: \"bbbab\"\n> + Output: 4\n> + One possible longest palindromic subsequence is \"bbbb\".\n>\n> Example 2:\n> + Input: \"cbbd\"\n> + Output: 2\n> + One possible longest palindromic subsequence is \"bb\".\n\n<!--more-->\n\nThis is Leetcode No.516. As a DP problem the most important thing is to find out the relationship of the state transformation.\n\nSo, here we need to use a DP[idx][idy] to mark the longest palindromic subsequence between idx and idy.\n\nAnd we can find that:\n\n```\nDP[idx][idy] = (str[idx] == str[idy + 1] ? DP[idx + 1][idy - 1] + 2 : max(DP[idx][idy - 1], DP[idx + 1][idy]));\n```\n\nSo here comes our solution:\n\n```\nclass Solution {\n    public:\n        int longestPalindromeSubseq(string str) {\n            int DP[1001][1001];\n            memset(DP, 0, sizeof(DP));\n            for (int idx = str.length() - 1; idx >= 0; idx--) {\n                DP[idx][idx] = 1;\n                for (int idy = idx + 1; idy < (int)str.length(); idy++) {\n                    if (str[idx] == str[idy]) {\n                        DP[idx][idy] = DP[idx + 1][idy - 1] + 2;\n                    } else {\n                        DP[idx][idy] = max(DP[idx + 1][idy], DP[idx][idy - 1]);\n                    }\n                }\n            }\n            return DP[0][str.length() - 1];\n        }\n};\n```\n\nIt gets AC.\n","slug":"LongestPalindromicSubsequence","published":1,"updated":"2017-02-22T06:20:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwj002tg5f4cikdr4la","content":"<blockquote>\n<p>Given a string s, find the longest palindromic subsequences length in s. You may assume that the maximum length of s is 1000.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: bbbab</li>\n<li>Output: 4</li>\n<li>One possible longest palindromic subsequence is bbbb.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: cbbd</li>\n<li>Output: 2</li>\n<li>One possible longest palindromic subsequence is bb.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.516. As a DP problem the most important thing is to find out the relationship of the state transformation.</p>\n<p>So, here we need to use a DP[idx][idy] to mark the longest palindromic subsequence between idx and idy.</p>\n<p>And we can find that:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DP[idx][idy] = (str[idx] == str[idy + 1] ? DP[idx + 1][idy - 1] + 2 : max(DP[idx][idy - 1], DP[idx + 1][idy]));</div></pre></td></tr></table></figure>\n<p>So here comes our solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestPalindromeSubseq(string str) &#123;</div><div class=\"line\">            int DP[1001][1001];</div><div class=\"line\">            memset(DP, 0, sizeof(DP));</div><div class=\"line\">            for (int idx = str.length() - 1; idx &gt;= 0; idx--) &#123;</div><div class=\"line\">                DP[idx][idx] = 1;</div><div class=\"line\">                for (int idy = idx + 1; idy &lt; (int)str.length(); idy++) &#123;</div><div class=\"line\">                    if (str[idx] == str[idy]) &#123;</div><div class=\"line\">                        DP[idx][idy] = DP[idx + 1][idy - 1] + 2;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        DP[idx][idy] = max(DP[idx + 1][idy], DP[idx][idy - 1]);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[0][str.length() - 1];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a string s, find the longest palindromic subsequences length in s. You may assume that the maximum length of s is 1000.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: bbbab</li>\n<li>Output: 4</li>\n<li>One possible longest palindromic subsequence is bbbb.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: cbbd</li>\n<li>Output: 2</li>\n<li>One possible longest palindromic subsequence is bb.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.516. As a DP problem the most important thing is to find out the relationship of the state transformation.</p>\n<p>So, here we need to use a DP[idx][idy] to mark the longest palindromic subsequence between idx and idy.</p>\n<p>And we can find that:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DP[idx][idy] = (str[idx] == str[idy + 1] ? DP[idx + 1][idy - 1] + 2 : max(DP[idx][idy - 1], DP[idx + 1][idy]));</div></pre></td></tr></table></figure>\n<p>So here comes our solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestPalindromeSubseq(string str) &#123;</div><div class=\"line\">            int DP[1001][1001];</div><div class=\"line\">            memset(DP, 0, sizeof(DP));</div><div class=\"line\">            for (int idx = str.length() - 1; idx &gt;= 0; idx--) &#123;</div><div class=\"line\">                DP[idx][idx] = 1;</div><div class=\"line\">                for (int idy = idx + 1; idy &lt; (int)str.length(); idy++) &#123;</div><div class=\"line\">                    if (str[idx] == str[idy]) &#123;</div><div class=\"line\">                        DP[idx][idy] = DP[idx + 1][idy - 1] + 2;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        DP[idx][idy] = max(DP[idx + 1][idy], DP[idx][idy - 1]);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[0][str.length() - 1];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Max Consecutive Ones","date":"2017-02-19T08:58:58.000Z","_content":"\n> Given a binary array, find the maximum number of consecutive 1s in this array.\n>\n> Example 1:\n>\n> Input: [1,1,0,1,1,1]\n>\n> Output: 3\n>\n> Explanation:\n>  + The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n>\n> Note:\n>\n> + The input array will only contain 0 and 1.\n> + The length of input array is a positive integer and will not exceed 10,000\n\n<!--more-->\n\nThis is Leetcode No.485, and it is an easy problem. Here is my solution:\n\n```\nclass Solution {\n    public:\n        int findMaxConsecutiveOnes(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n\n            int res = 0, current = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (nums[i] == 0) {\n                    current = 0;\n                } else {\n                    current = current + 1;\n                }\n                res = max(res, current);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/MaxConsecutiveOnes.md","raw":"---\ntitle: Max Consecutive Ones\ndate: 2017-02-19 16:58:58\ntags:\n    - Array\n---\n\n> Given a binary array, find the maximum number of consecutive 1s in this array.\n>\n> Example 1:\n>\n> Input: [1,1,0,1,1,1]\n>\n> Output: 3\n>\n> Explanation:\n>  + The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n>\n> Note:\n>\n> + The input array will only contain 0 and 1.\n> + The length of input array is a positive integer and will not exceed 10,000\n\n<!--more-->\n\nThis is Leetcode No.485, and it is an easy problem. Here is my solution:\n\n```\nclass Solution {\n    public:\n        int findMaxConsecutiveOnes(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n\n            int res = 0, current = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (nums[i] == 0) {\n                    current = 0;\n                } else {\n                    current = current + 1;\n                }\n                res = max(res, current);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"MaxConsecutiveOnes","published":1,"updated":"2017-02-19T09:09:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwk002vg5f44zbmqkla","content":"<blockquote>\n<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>\n<p>Example 1:</p>\n<p>Input: [1,1,0,1,1,1]</p>\n<p>Output: 3</p>\n<p>Explanation:</p>\n<ul>\n<li>The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.485, and it is an easy problem. Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0, current = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] == 0) &#123;</div><div class=\"line\">                    current = 0;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    current = current + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = max(res, current);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>\n<p>Example 1:</p>\n<p>Input: [1,1,0,1,1,1]</p>\n<p>Output: 3</p>\n<p>Explanation:</p>\n<ul>\n<li>The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>The input array will only contain 0 and 1.</li>\n<li>The length of input array is a positive integer and will not exceed 10,000</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.485, and it is an easy problem. Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0, current = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] == 0) &#123;</div><div class=\"line\">                    current = 0;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    current = current + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">                res = max(res, current);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Longest Substring with At Least K Repeating Characters","date":"2017-03-29T01:44:56.000Z","_content":"\n> Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n>\n> Example 1:\n>```\nInput:\ns = \"aaabb\", k = 3\nOutput:\n3\n```\n> + The longest substring is \"aaa\", as 'a' is repeated 3 times.\n>\n> Example 2:\n>```\nInput:\ns = \"ababbc\", k = 2\nOutput:\n5\n```\n> + The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n<!--more-->\n\nThis is Leetcode No.395. It is a string problem. I can quickly find this solution with O(n^2) time complex.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int longestSubstring(string str, int num) {\n            int res = 0;\n            for (int idx = 0; idx < (int)str.length(); idx++) {\n                map<char, int> chars;\n                for (int idy = idx; idy < (int)str.length(); idy++) {\n                    if (chars.find(str[idy]) != chars.end()) {\n                        chars.find(str[idy])->second++;\n                    } else {\n                        chars.insert(pair<char, int>(str[idy], 1));\n                    }\n\n                    bool isOk = true;\n                    for (auto i : chars) {\n                        if (i.second < num) {\n                            isOk = false;\n                            break;\n                        }\n                    }\n\n                    if (isOk) {\n                        res = max(res, idy - idx + 1);\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets TLE, and we can make it quicker.\n\n+ in the first pass I record counts of every character in a hashmap\n+ in the second pass I locate the first character that appear less than k times in the string. this character is definitely not included in the result, and that separates the string into two parts.\n+ keep doing this recursively and the maximum of the left/right part is the answer.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int longestSubstring(string str, int num) {\n            if(str.size() == 0 || num > (int)str.size())   return 0;\n            if(num == 0)  return str.size();\n\n            map<char,int> Map;\n            for(int i = 0; i < (int)str.size(); i++){\n                Map[str[i]]++;\n            }\n\n            int idx =0;\n            while(idx < (int)str.size() && Map[str[idx]] >= num)    idx++;\n            if(idx == (int)str.size()) return str.size();\n\n            int left = longestSubstring(str.substr(0 , idx) , num);\n            int right = longestSubstring(str.substr(idx+1) , num);\n\n            return max(left, right);\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/LongestSubstringwithAtLeastKRepeatingCharacters.md","raw":"---\ntitle: Longest Substring with At Least K Repeating Characters\ndate: 2017-03-29 09:44:56\ntags:\n    - String\n---\n\n> Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.\n>\n> Example 1:\n>```\nInput:\ns = \"aaabb\", k = 3\nOutput:\n3\n```\n> + The longest substring is \"aaa\", as 'a' is repeated 3 times.\n>\n> Example 2:\n>```\nInput:\ns = \"ababbc\", k = 2\nOutput:\n5\n```\n> + The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n<!--more-->\n\nThis is Leetcode No.395. It is a string problem. I can quickly find this solution with O(n^2) time complex.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int longestSubstring(string str, int num) {\n            int res = 0;\n            for (int idx = 0; idx < (int)str.length(); idx++) {\n                map<char, int> chars;\n                for (int idy = idx; idy < (int)str.length(); idy++) {\n                    if (chars.find(str[idy]) != chars.end()) {\n                        chars.find(str[idy])->second++;\n                    } else {\n                        chars.insert(pair<char, int>(str[idy], 1));\n                    }\n\n                    bool isOk = true;\n                    for (auto i : chars) {\n                        if (i.second < num) {\n                            isOk = false;\n                            break;\n                        }\n                    }\n\n                    if (isOk) {\n                        res = max(res, idy - idx + 1);\n                    }\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets TLE, and we can make it quicker.\n\n+ in the first pass I record counts of every character in a hashmap\n+ in the second pass I locate the first character that appear less than k times in the string. this character is definitely not included in the result, and that separates the string into two parts.\n+ keep doing this recursively and the maximum of the left/right part is the answer.\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int longestSubstring(string str, int num) {\n            if(str.size() == 0 || num > (int)str.size())   return 0;\n            if(num == 0)  return str.size();\n\n            map<char,int> Map;\n            for(int i = 0; i < (int)str.size(); i++){\n                Map[str[i]]++;\n            }\n\n            int idx =0;\n            while(idx < (int)str.size() && Map[str[idx]] >= num)    idx++;\n            if(idx == (int)str.size()) return str.size();\n\n            int left = longestSubstring(str.substr(0 , idx) , num);\n            int right = longestSubstring(str.substr(idx+1) , num);\n\n            return max(left, right);\n        }\n};\n```\n\nIt gets AC.\n","slug":"LongestSubstringwithAtLeastKRepeatingCharacters","published":1,"updated":"2017-03-29T05:50:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwm002yg5f437k03ube","content":"<blockquote>\n<p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;aaabb&quot;, k = 3</div><div class=\"line\">Output:</div><div class=\"line\">3</div></pre></td></tr></table></figure></p>\n<ul>\n<li>The longest substring is aaa, as a is repeated 3 times.</li>\n</ul>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;ababbc&quot;, k = 2</div><div class=\"line\">Output:</div><div class=\"line\">5</div></pre></td></tr></table></figure></p>\n<ul>\n<li>The longest substring is ababb, as a is repeated 2 times and b is repeated 3 times.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.395. It is a string problem. I can quickly find this solution with O(n^2) time complex.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestSubstring(string str, int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)str.length(); idx++) &#123;</div><div class=\"line\">                map&lt;char, int&gt; chars;</div><div class=\"line\">                for (int idy = idx; idy &lt; (int)str.length(); idy++) &#123;</div><div class=\"line\">                    if (chars.find(str[idy]) != chars.end()) &#123;</div><div class=\"line\">                        chars.find(str[idy])-&gt;second++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        chars.insert(pair&lt;char, int&gt;(str[idy], 1));</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    bool isOk = true;</div><div class=\"line\">                    for (auto i : chars) &#123;</div><div class=\"line\">                        if (i.second &lt; num) &#123;</div><div class=\"line\">                            isOk = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if (isOk) &#123;</div><div class=\"line\">                        res = max(res, idy - idx + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets TLE, and we can make it quicker.</p>\n<ul>\n<li>in the first pass I record counts of every character in a hashmap</li>\n<li>in the second pass I locate the first character that appear less than k times in the string. this character is definitely not included in the result, and that separates the string into two parts.</li>\n<li>keep doing this recursively and the maximum of the left/right part is the answer.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestSubstring(string str, int num) &#123;</div><div class=\"line\">            if(str.size() == 0 || num &gt; (int)str.size())   return 0;</div><div class=\"line\">            if(num == 0)  return str.size();</div><div class=\"line\"></div><div class=\"line\">            map&lt;char,int&gt; Map;</div><div class=\"line\">            for(int i = 0; i &lt; (int)str.size(); i++)&#123;</div><div class=\"line\">                Map[str[i]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int idx =0;</div><div class=\"line\">            while(idx &lt; (int)str.size() &amp;&amp; Map[str[idx]] &gt;= num)    idx++;</div><div class=\"line\">            if(idx == (int)str.size()) return str.size();</div><div class=\"line\"></div><div class=\"line\">            int left = longestSubstring(str.substr(0 , idx) , num);</div><div class=\"line\">            int right = longestSubstring(str.substr(idx+1) , num);</div><div class=\"line\"></div><div class=\"line\">            return max(left, right);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;aaabb&quot;, k = 3</div><div class=\"line\">Output:</div><div class=\"line\">3</div></pre></td></tr></table></figure></p>\n<ul>\n<li>The longest substring is aaa, as a is repeated 3 times.</li>\n</ul>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">s = &quot;ababbc&quot;, k = 2</div><div class=\"line\">Output:</div><div class=\"line\">5</div></pre></td></tr></table></figure></p>\n<ul>\n<li>The longest substring is ababb, as a is repeated 2 times and b is repeated 3 times.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.395. It is a string problem. I can quickly find this solution with O(n^2) time complex.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestSubstring(string str, int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)str.length(); idx++) &#123;</div><div class=\"line\">                map&lt;char, int&gt; chars;</div><div class=\"line\">                for (int idy = idx; idy &lt; (int)str.length(); idy++) &#123;</div><div class=\"line\">                    if (chars.find(str[idy]) != chars.end()) &#123;</div><div class=\"line\">                        chars.find(str[idy])-&gt;second++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        chars.insert(pair&lt;char, int&gt;(str[idy], 1));</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    bool isOk = true;</div><div class=\"line\">                    for (auto i : chars) &#123;</div><div class=\"line\">                        if (i.second &lt; num) &#123;</div><div class=\"line\">                            isOk = false;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\"></div><div class=\"line\">                    if (isOk) &#123;</div><div class=\"line\">                        res = max(res, idy - idx + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets TLE, and we can make it quicker.</p>\n<ul>\n<li>in the first pass I record counts of every character in a hashmap</li>\n<li>in the second pass I locate the first character that appear less than k times in the string. this character is definitely not included in the result, and that separates the string into two parts.</li>\n<li>keep doing this recursively and the maximum of the left/right part is the answer.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int longestSubstring(string str, int num) &#123;</div><div class=\"line\">            if(str.size() == 0 || num &gt; (int)str.size())   return 0;</div><div class=\"line\">            if(num == 0)  return str.size();</div><div class=\"line\"></div><div class=\"line\">            map&lt;char,int&gt; Map;</div><div class=\"line\">            for(int i = 0; i &lt; (int)str.size(); i++)&#123;</div><div class=\"line\">                Map[str[i]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int idx =0;</div><div class=\"line\">            while(idx &lt; (int)str.size() &amp;&amp; Map[str[idx]] &gt;= num)    idx++;</div><div class=\"line\">            if(idx == (int)str.size()) return str.size();</div><div class=\"line\"></div><div class=\"line\">            int left = longestSubstring(str.substr(0 , idx) , num);</div><div class=\"line\">            int right = longestSubstring(str.substr(idx+1) , num);</div><div class=\"line\"></div><div class=\"line\">            return max(left, right);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Maximum XOR of Two Numbers in an Array","date":"2017-02-09T15:05:44.000Z","_content":"\n> Given a non-empty array of numbers, a0, a1, a2,  , an-1, where 0  ai < 231.\n>\n> Find the maximum result of ai XOR aj, where 0  i, j < n.\n>\n> Could you do this in O(n) runtime?\n>\n> Example:\n>\n> + Input: [3, 10, 5, 25, 2, 8]\n> + Output: 28\n> + Explanation: The maximum result is 5 ^ 25 = 28.\n\n<!--more-->\n\nThis is Leetcode 421, and it is such a Trie problem. So, this is the result:\n\n```\nclass Solution {\n    public:\n        class TreeNode {\n        public:\n            TreeNode* next[2];\n            TreeNode () {next[0] = NULL; next[1] = NULL;};\n        };\n        TreeNode* buildTree(vector<int>& nums) {\n            TreeNode* root = new TreeNode(), *cur;\n            int n = nums.size();\n            for (int i = 0; i < n; i++) {\n                int num = nums[i];\n                cur = root;\n                for (int j = 31; j >= 0; j--) {\n                    int index = ((num >> j) & 1);\n                    if (cur->next[index] ==  NULL)\n                        cur->next[index] = new TreeNode();\n                    cur = cur->next[index];\n                }\n            }\n            return root;\n        }\n\n        int helper(TreeNode* cur, int num) {\n            int res = 0;\n            for (int i = 31; i >= 0; i--) {\n                int index = ((num >> i) & 1) ? 0 : 1;\n                if (cur->next[index]) {\n                    res <<= 1;\n                    res |= 1;\n                    cur = cur->next[index];\n                } else {\n                    res <<= 1;\n                    res |= 0;\n                    cur = cur->next[index ? 0 : 1];\n                }\n            }\n            return res;\n        }\n\n        int findMaximumXOR(vector<int>& nums) {\n            int res = 0;\n            TreeNode* root = buildTree(nums);\n\n            for (auto i : nums) {\n                res = max(res, helper(root, i));\n            }\n\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/MaximumXORofTwoNumbersinanArray.md","raw":"---\ntitle: Maximum XOR of Two Numbers in an Array\ndate: 2017-02-09 23:05:44\ntags:\n    - Trie\n    - Bit Manipulation\n---\n\n> Given a non-empty array of numbers, a0, a1, a2,  , an-1, where 0  ai < 231.\n>\n> Find the maximum result of ai XOR aj, where 0  i, j < n.\n>\n> Could you do this in O(n) runtime?\n>\n> Example:\n>\n> + Input: [3, 10, 5, 25, 2, 8]\n> + Output: 28\n> + Explanation: The maximum result is 5 ^ 25 = 28.\n\n<!--more-->\n\nThis is Leetcode 421, and it is such a Trie problem. So, this is the result:\n\n```\nclass Solution {\n    public:\n        class TreeNode {\n        public:\n            TreeNode* next[2];\n            TreeNode () {next[0] = NULL; next[1] = NULL;};\n        };\n        TreeNode* buildTree(vector<int>& nums) {\n            TreeNode* root = new TreeNode(), *cur;\n            int n = nums.size();\n            for (int i = 0; i < n; i++) {\n                int num = nums[i];\n                cur = root;\n                for (int j = 31; j >= 0; j--) {\n                    int index = ((num >> j) & 1);\n                    if (cur->next[index] ==  NULL)\n                        cur->next[index] = new TreeNode();\n                    cur = cur->next[index];\n                }\n            }\n            return root;\n        }\n\n        int helper(TreeNode* cur, int num) {\n            int res = 0;\n            for (int i = 31; i >= 0; i--) {\n                int index = ((num >> i) & 1) ? 0 : 1;\n                if (cur->next[index]) {\n                    res <<= 1;\n                    res |= 1;\n                    cur = cur->next[index];\n                } else {\n                    res <<= 1;\n                    res |= 0;\n                    cur = cur->next[index ? 0 : 1];\n                }\n            }\n            return res;\n        }\n\n        int findMaximumXOR(vector<int>& nums) {\n            int res = 0;\n            TreeNode* root = buildTree(nums);\n\n            for (auto i : nums) {\n                res = max(res, helper(root, i));\n            }\n\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"MaximumXORofTwoNumbersinanArray","published":1,"updated":"2017-02-09T15:11:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwn0030g5f4o67i7k8m","content":"<blockquote>\n<p>Given a non-empty array of numbers, a0, a1, a2,  , an-1, where 0  ai &lt; 231.</p>\n<p>Find the maximum result of ai XOR aj, where 0  i, j &lt; n.</p>\n<p>Could you do this in O(n) runtime?</p>\n<p>Example:</p>\n<ul>\n<li>Input: [3, 10, 5, 25, 2, 8]</li>\n<li>Output: 28</li>\n<li>Explanation: The maximum result is 5 ^ 25 = 28.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 421, and it is such a Trie problem. So, this is the result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        class TreeNode &#123;</div><div class=\"line\">        public:</div><div class=\"line\">            TreeNode* next[2];</div><div class=\"line\">            TreeNode () &#123;next[0] = NULL; next[1] = NULL;&#125;;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        TreeNode* buildTree(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            TreeNode* root = new TreeNode(), *cur;</div><div class=\"line\">            int n = nums.size();</div><div class=\"line\">            for (int i = 0; i &lt; n; i++) &#123;</div><div class=\"line\">                int num = nums[i];</div><div class=\"line\">                cur = root;</div><div class=\"line\">                for (int j = 31; j &gt;= 0; j--) &#123;</div><div class=\"line\">                    int index = ((num &gt;&gt; j) &amp; 1);</div><div class=\"line\">                    if (cur-&gt;next[index] ==  NULL)</div><div class=\"line\">                        cur-&gt;next[index] = new TreeNode();</div><div class=\"line\">                    cur = cur-&gt;next[index];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return root;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int helper(TreeNode* cur, int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int i = 31; i &gt;= 0; i--) &#123;</div><div class=\"line\">                int index = ((num &gt;&gt; i) &amp; 1) ? 0 : 1;</div><div class=\"line\">                if (cur-&gt;next[index]) &#123;</div><div class=\"line\">                    res &lt;&lt;= 1;</div><div class=\"line\">                    res |= 1;</div><div class=\"line\">                    cur = cur-&gt;next[index];</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res &lt;&lt;= 1;</div><div class=\"line\">                    res |= 0;</div><div class=\"line\">                    cur = cur-&gt;next[index ? 0 : 1];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            TreeNode* root = buildTree(nums);</div><div class=\"line\"></div><div class=\"line\">            for (auto i : nums) &#123;</div><div class=\"line\">                res = max(res, helper(root, i));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty array of numbers, a0, a1, a2,  , an-1, where 0  ai &lt; 231.</p>\n<p>Find the maximum result of ai XOR aj, where 0  i, j &lt; n.</p>\n<p>Could you do this in O(n) runtime?</p>\n<p>Example:</p>\n<ul>\n<li>Input: [3, 10, 5, 25, 2, 8]</li>\n<li>Output: 28</li>\n<li>Explanation: The maximum result is 5 ^ 25 = 28.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 421, and it is such a Trie problem. So, this is the result:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        class TreeNode &#123;</div><div class=\"line\">        public:</div><div class=\"line\">            TreeNode* next[2];</div><div class=\"line\">            TreeNode () &#123;next[0] = NULL; next[1] = NULL;&#125;;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        TreeNode* buildTree(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            TreeNode* root = new TreeNode(), *cur;</div><div class=\"line\">            int n = nums.size();</div><div class=\"line\">            for (int i = 0; i &lt; n; i++) &#123;</div><div class=\"line\">                int num = nums[i];</div><div class=\"line\">                cur = root;</div><div class=\"line\">                for (int j = 31; j &gt;= 0; j--) &#123;</div><div class=\"line\">                    int index = ((num &gt;&gt; j) &amp; 1);</div><div class=\"line\">                    if (cur-&gt;next[index] ==  NULL)</div><div class=\"line\">                        cur-&gt;next[index] = new TreeNode();</div><div class=\"line\">                    cur = cur-&gt;next[index];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return root;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int helper(TreeNode* cur, int num) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            for (int i = 31; i &gt;= 0; i--) &#123;</div><div class=\"line\">                int index = ((num &gt;&gt; i) &amp; 1) ? 0 : 1;</div><div class=\"line\">                if (cur-&gt;next[index]) &#123;</div><div class=\"line\">                    res &lt;&lt;= 1;</div><div class=\"line\">                    res |= 1;</div><div class=\"line\">                    cur = cur-&gt;next[index];</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res &lt;&lt;= 1;</div><div class=\"line\">                    res |= 0;</div><div class=\"line\">                    cur = cur-&gt;next[index ? 0 : 1];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            TreeNode* root = buildTree(nums);</div><div class=\"line\"></div><div class=\"line\">            for (auto i : nums) &#123;</div><div class=\"line\">                res = max(res, helper(root, i));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Minimum Moves to Equal Array Elements II","date":"2017-01-26T14:41:39.000Z","_content":"\n> Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n>\n> You may assume the array's length is at most 10,000.\n>\n> Example:\n> + Input: [1,2,3]\n>\n> + Output: 2\n>\n> + Explanation: Only two moves are needed (remember each move increments or decrements one element):\n>  > [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n\n<!--more-->\n\nThis is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.\n\nBut, it's actually a Math problem, you can find the min result always is the mid one.\n\nSo, here comes a solution:\n\n```\nclass Solution {\n    public:\n        int minMoves2(vector<int>& nums) {\n            int res = 0;\n            sort(nums.begin(), nums.end());\n            int standard = nums[nums.size() / 2];\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res = res + abs(nums[i] - standard);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/MinimumMovestoEqualArrayElementsII.md","raw":"---\ntitle: Minimum Moves to Equal Array Elements II\ndate: 2017-01-26 22:41:39\ntags:\n    - Math\n---\n\n> Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\n>\n> You may assume the array's length is at most 10,000.\n>\n> Example:\n> + Input: [1,2,3]\n>\n> + Output: 2\n>\n> + Explanation: Only two moves are needed (remember each move increments or decrements one element):\n>  > [1,2,3]  =>  [2,2,3]  =>  [2,2,2]\n\n<!--more-->\n\nThis is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.\n\nBut, it's actually a Math problem, you can find the min result always is the mid one.\n\nSo, here comes a solution:\n\n```\nclass Solution {\n    public:\n        int minMoves2(vector<int>& nums) {\n            int res = 0;\n            sort(nums.begin(), nums.end());\n            int standard = nums[nums.size() / 2];\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res = res + abs(nums[i] - standard);\n            }\n            return res;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"MinimumMovestoEqualArrayElementsII","published":1,"updated":"2017-01-26T14:52:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwp0032g5f4qw0l8dkm","content":"<blockquote>\n<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n<p>You may assume the arrays length is at most 10,000.</p>\n<p>Example:</p>\n<ul>\n<li><p>Input: [1,2,3]</p>\n</li>\n<li><p>Output: 2</p>\n</li>\n<li><p>Explanation: Only two moves are needed (remember each move increments or decrements one element):</p>\n<blockquote>\n<p>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.</p>\n<p>But, its actually a Math problem, you can find the min result always is the mid one.</p>\n<p>So, here comes a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int minMoves2(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            int standard = nums[nums.size() / 2];</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res + abs(nums[i] - standard);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.</p>\n<p>You may assume the arrays length is at most 10,000.</p>\n<p>Example:</p>\n<ul>\n<li><p>Input: [1,2,3]</p>\n</li>\n<li><p>Output: 2</p>\n</li>\n<li><p>Explanation: Only two moves are needed (remember each move increments or decrements one element):</p>\n<blockquote>\n<p>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 462, it is a fun problem. You can quick find a solution by using hashmap to store the number and its appearance times and calculate the result one by one.</p>\n<p>But, its actually a Math problem, you can find the min result always is the mid one.</p>\n<p>So, here comes a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int minMoves2(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            sort(nums.begin(), nums.end());</div><div class=\"line\">            int standard = nums[nums.size() / 2];</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res + abs(nums[i] - standard);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Merge Intervals","date":"2017-03-30T02:09:26.000Z","_content":"\n> Given a collection of intervals, merge all overlapping intervals.\n>\n> For example:\n>```\nGiven [1,3],[2,6],[8,10],[15,18],\nreturn [1,6],[8,10],[15,18].\n```\n\n<!--more-->\n\nThis is Leetcode No.56. I think this is a easy-thought problem. The solution is simple but the corner cases are many.\n\nSo, what I do first is to sort the intervals first (by the start idx).\n\nFor example, [2, 3], [1, 4] I will make them [1, 4], [2, 3] order.\n\nThen, I start to merge them one by one until no one can be merged.\n\n```\nusing namespace std;\n\nstruct Interval {\n    int start;\n    int end;\n    Interval() : start(0), end(0) {}\n    Interval(int s, int e) : start(s), end(e) {}\n};\n\nint cmp(const Interval a, const Interval b) {\n    if (a.start == b.start && a.end == b.end) {\n        return 0;\n    } else {\n        return a.start < b.start;\n    }\n}\n\nclass Solution {\n    public:\n        vector<Interval> merge(vector<Interval>& intervals) {\n            sort(intervals.begin(), intervals.end(), cmp);\n            vector<Interval> current;\n\n            if (intervals.size() == 0) {\n                return current;\n            }\n\n            bool canMerge = false;\n\n            for (int idx = 0; idx < (int)intervals.size() - 1; idx++) {\n                if (intervals[idx].end >= intervals[idx + 1].start) {\n                    canMerge = true;\n                    intervals[idx].start = min(intervals[idx].start, intervals[idx + 1].start);\n                    intervals[idx + 1].start = min(intervals[idx].start, intervals[idx + 1].start);\n                    intervals[idx + 1].end = max(intervals[idx].end, intervals[idx + 1].end);\n                    intervals[idx].end = max(intervals[idx].end, intervals[idx + 1].end);\n                }\n            }\n\n            current.push_back(intervals[0]);\n            for (int idx = 1; idx < (int)intervals.size(); idx++) {\n                if (intervals[idx].start == current.back().start && intervals[idx].end == current.back().end) {\n                    continue;\n                } else {\n                    current.push_back(intervals[idx]);\n                }\n            }\n\n            if (canMerge) {\n                return merge(current);\n            } else {\n                return current;\n            }\n        }\n};\n```\n\nIt gets AC. However, if I can modify the class code block, I can overide the '==' operator then use set to keep Interval unique.\n\n\n","source":"_posts/MergeIntervals.md","raw":"---\ntitle: Merge Intervals\ndate: 2017-03-30 10:09:26\ntags:\n    - Array\n    - Sort\n---\n\n> Given a collection of intervals, merge all overlapping intervals.\n>\n> For example:\n>```\nGiven [1,3],[2,6],[8,10],[15,18],\nreturn [1,6],[8,10],[15,18].\n```\n\n<!--more-->\n\nThis is Leetcode No.56. I think this is a easy-thought problem. The solution is simple but the corner cases are many.\n\nSo, what I do first is to sort the intervals first (by the start idx).\n\nFor example, [2, 3], [1, 4] I will make them [1, 4], [2, 3] order.\n\nThen, I start to merge them one by one until no one can be merged.\n\n```\nusing namespace std;\n\nstruct Interval {\n    int start;\n    int end;\n    Interval() : start(0), end(0) {}\n    Interval(int s, int e) : start(s), end(e) {}\n};\n\nint cmp(const Interval a, const Interval b) {\n    if (a.start == b.start && a.end == b.end) {\n        return 0;\n    } else {\n        return a.start < b.start;\n    }\n}\n\nclass Solution {\n    public:\n        vector<Interval> merge(vector<Interval>& intervals) {\n            sort(intervals.begin(), intervals.end(), cmp);\n            vector<Interval> current;\n\n            if (intervals.size() == 0) {\n                return current;\n            }\n\n            bool canMerge = false;\n\n            for (int idx = 0; idx < (int)intervals.size() - 1; idx++) {\n                if (intervals[idx].end >= intervals[idx + 1].start) {\n                    canMerge = true;\n                    intervals[idx].start = min(intervals[idx].start, intervals[idx + 1].start);\n                    intervals[idx + 1].start = min(intervals[idx].start, intervals[idx + 1].start);\n                    intervals[idx + 1].end = max(intervals[idx].end, intervals[idx + 1].end);\n                    intervals[idx].end = max(intervals[idx].end, intervals[idx + 1].end);\n                }\n            }\n\n            current.push_back(intervals[0]);\n            for (int idx = 1; idx < (int)intervals.size(); idx++) {\n                if (intervals[idx].start == current.back().start && intervals[idx].end == current.back().end) {\n                    continue;\n                } else {\n                    current.push_back(intervals[idx]);\n                }\n            }\n\n            if (canMerge) {\n                return merge(current);\n            } else {\n                return current;\n            }\n        }\n};\n```\n\nIt gets AC. However, if I can modify the class code block, I can overide the '==' operator then use set to keep Interval unique.\n\n\n","slug":"MergeIntervals","published":1,"updated":"2017-03-30T04:41:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwq0035g5f4wknb78js","content":"<blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n<p>For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given [1,3],[2,6],[8,10],[15,18],</div><div class=\"line\">return [1,6],[8,10],[15,18].</div></pre></td></tr></table></figure></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.56. I think this is a easy-thought problem. The solution is simple but the corner cases are many.</p>\n<p>So, what I do first is to sort the intervals first (by the start idx).</p>\n<p>For example, [2, 3], [1, 4] I will make them [1, 4], [2, 3] order.</p>\n<p>Then, I start to merge them one by one until no one can be merged.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">struct Interval &#123;</div><div class=\"line\">    int start;</div><div class=\"line\">    int end;</div><div class=\"line\">    Interval() : start(0), end(0) &#123;&#125;</div><div class=\"line\">    Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">int cmp(const Interval a, const Interval b) &#123;</div><div class=\"line\">    if (a.start == b.start &amp;&amp; a.end == b.end) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return a.start &lt; b.start;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</div><div class=\"line\">            sort(intervals.begin(), intervals.end(), cmp);</div><div class=\"line\">            vector&lt;Interval&gt; current;</div><div class=\"line\"></div><div class=\"line\">            if (intervals.size() == 0) &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool canMerge = false;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)intervals.size() - 1; idx++) &#123;</div><div class=\"line\">                if (intervals[idx].end &gt;= intervals[idx + 1].start) &#123;</div><div class=\"line\">                    canMerge = true;</div><div class=\"line\">                    intervals[idx].start = min(intervals[idx].start, intervals[idx + 1].start);</div><div class=\"line\">                    intervals[idx + 1].start = min(intervals[idx].start, intervals[idx + 1].start);</div><div class=\"line\">                    intervals[idx + 1].end = max(intervals[idx].end, intervals[idx + 1].end);</div><div class=\"line\">                    intervals[idx].end = max(intervals[idx].end, intervals[idx + 1].end);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            current.push_back(intervals[0]);</div><div class=\"line\">            for (int idx = 1; idx &lt; (int)intervals.size(); idx++) &#123;</div><div class=\"line\">                if (intervals[idx].start == current.back().start &amp;&amp; intervals[idx].end == current.back().end) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    current.push_back(intervals[idx]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (canMerge) &#123;</div><div class=\"line\">                return merge(current);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. However, if I can modify the class code block, I can overide the == operator then use set to keep Interval unique.</p>\n","excerpt":"<blockquote>\n<p>Given a collection of intervals, merge all overlapping intervals.</p>\n<p>For example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given [1,3],[2,6],[8,10],[15,18],</div><div class=\"line\">return [1,6],[8,10],[15,18].</div></pre></td></tr></table></figure></p>\n</blockquote>","more":"<p>This is Leetcode No.56. I think this is a easy-thought problem. The solution is simple but the corner cases are many.</p>\n<p>So, what I do first is to sort the intervals first (by the start idx).</p>\n<p>For example, [2, 3], [1, 4] I will make them [1, 4], [2, 3] order.</p>\n<p>Then, I start to merge them one by one until no one can be merged.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">struct Interval &#123;</div><div class=\"line\">    int start;</div><div class=\"line\">    int end;</div><div class=\"line\">    Interval() : start(0), end(0) &#123;&#125;</div><div class=\"line\">    Interval(int s, int e) : start(s), end(e) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">int cmp(const Interval a, const Interval b) &#123;</div><div class=\"line\">    if (a.start == b.start &amp;&amp; a.end == b.end) &#123;</div><div class=\"line\">        return 0;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return a.start &lt; b.start;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</div><div class=\"line\">            sort(intervals.begin(), intervals.end(), cmp);</div><div class=\"line\">            vector&lt;Interval&gt; current;</div><div class=\"line\"></div><div class=\"line\">            if (intervals.size() == 0) &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            bool canMerge = false;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)intervals.size() - 1; idx++) &#123;</div><div class=\"line\">                if (intervals[idx].end &gt;= intervals[idx + 1].start) &#123;</div><div class=\"line\">                    canMerge = true;</div><div class=\"line\">                    intervals[idx].start = min(intervals[idx].start, intervals[idx + 1].start);</div><div class=\"line\">                    intervals[idx + 1].start = min(intervals[idx].start, intervals[idx + 1].start);</div><div class=\"line\">                    intervals[idx + 1].end = max(intervals[idx].end, intervals[idx + 1].end);</div><div class=\"line\">                    intervals[idx].end = max(intervals[idx].end, intervals[idx + 1].end);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            current.push_back(intervals[0]);</div><div class=\"line\">            for (int idx = 1; idx &lt; (int)intervals.size(); idx++) &#123;</div><div class=\"line\">                if (intervals[idx].start == current.back().start &amp;&amp; intervals[idx].end == current.back().end) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    current.push_back(intervals[idx]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (canMerge) &#123;</div><div class=\"line\">                return merge(current);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                return current;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. However, if I can modify the class code block, I can overide the == operator then use set to keep Interval unique.</p>"},{"title":"Minimum Absolute Difference in BST","date":"2017-03-03T02:00:29.000Z","_content":"\n> Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n>\n> Example:\n>\n>```\nInput:\n1\n \\\n  3\n /\n2\nOutput:\n1\n```\n> Explanation:\n> The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).\n>\n> Note: There are at least two nodes in this BST.\n\n<!--more-->\n\nThis is Leetcode No.530. At first I thought this problem wants us to find out the minimum absolute difference between in the neighbour nodes.\n\nSo the wrong result is as following:\n\n```\nclass Solution {\n    public:\n        int res;\n\n        int getMinimumDifference(TreeNode* root) {\n            res = INT_MAX;\n\n            _visit(root->left, root->val);\n            _visit(root->right, root->val);\n\n            return res;\n        }\n\n        void _visit(TreeNode *node, int pre) {\n            if (node == NULL) {\n                return;\n            }\n            if (abs(node->val - pre) < res) {\n                res = abs(node->val - pre);\n            }\n            _visit(node->left, node->val);\n            _visit(node->right, node->val);\n        }\n};\n```\n\nSo, I found the target is to find the minimum result between any node. So the result is:\n\n```\nclass Solution {\n    public:\n        int res;\n        vector<int> nodes;\n\n        int getMinimumDifference(TreeNode* root) {\n            res = INT_MAX;\n            nodes.clear();\n\n            _visit(root);\n\n            sort(nodes.begin(), nodes.end());\n\n            for (int i = 0; i < (int)nodes.size() - 1; i++) {\n                res = min(res, abs(nodes[i] - nodes[i + 1]));\n            }\n\n            return res;\n        }\n\n        void _visit(TreeNode *node) {\n            if (node == NULL) {\n                return;\n            }\n            nodes.push_back(node->val);\n            _visit(node->left);\n            _visit(node->right);\n        }\n};\n```\n\nHere I use a vector to store every node. Its time complex is O(nlogn), it's fast but I can be better. to use the feature of BST. to find the array in order.\n\nBut it already gets AC.\n","source":"_posts/MinimumAbsoluteDifferenceinBST.md","raw":"---\ntitle: Minimum Absolute Difference in BST\ndate: 2017-03-03 10:00:29\ntags:\n    - Binary Search Tree\n---\n\n> Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n>\n> Example:\n>\n>```\nInput:\n1\n \\\n  3\n /\n2\nOutput:\n1\n```\n> Explanation:\n> The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).\n>\n> Note: There are at least two nodes in this BST.\n\n<!--more-->\n\nThis is Leetcode No.530. At first I thought this problem wants us to find out the minimum absolute difference between in the neighbour nodes.\n\nSo the wrong result is as following:\n\n```\nclass Solution {\n    public:\n        int res;\n\n        int getMinimumDifference(TreeNode* root) {\n            res = INT_MAX;\n\n            _visit(root->left, root->val);\n            _visit(root->right, root->val);\n\n            return res;\n        }\n\n        void _visit(TreeNode *node, int pre) {\n            if (node == NULL) {\n                return;\n            }\n            if (abs(node->val - pre) < res) {\n                res = abs(node->val - pre);\n            }\n            _visit(node->left, node->val);\n            _visit(node->right, node->val);\n        }\n};\n```\n\nSo, I found the target is to find the minimum result between any node. So the result is:\n\n```\nclass Solution {\n    public:\n        int res;\n        vector<int> nodes;\n\n        int getMinimumDifference(TreeNode* root) {\n            res = INT_MAX;\n            nodes.clear();\n\n            _visit(root);\n\n            sort(nodes.begin(), nodes.end());\n\n            for (int i = 0; i < (int)nodes.size() - 1; i++) {\n                res = min(res, abs(nodes[i] - nodes[i + 1]));\n            }\n\n            return res;\n        }\n\n        void _visit(TreeNode *node) {\n            if (node == NULL) {\n                return;\n            }\n            nodes.push_back(node->val);\n            _visit(node->left);\n            _visit(node->right);\n        }\n};\n```\n\nHere I use a vector to store every node. Its time complex is O(nlogn), it's fast but I can be better. to use the feature of BST. to find the array in order.\n\nBut it already gets AC.\n","slug":"MinimumAbsoluteDifferenceinBST","published":1,"updated":"2017-03-03T03:02:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatws0037g5f4n8yq2hdw","content":"<blockquote>\n<p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">1</div><div class=\"line\"> \\</div><div class=\"line\">  3</div><div class=\"line\"> /</div><div class=\"line\">2</div><div class=\"line\">Output:</div><div class=\"line\">1</div></pre></td></tr></table></figure>\n<p>Explanation:<br>The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</p>\n<p>Note: There are at least two nodes in this BST.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.530. At first I thought this problem wants us to find out the minimum absolute difference between in the neighbour nodes.</p>\n<p>So the wrong result is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\"></div><div class=\"line\">        int getMinimumDifference(TreeNode* root) &#123;</div><div class=\"line\">            res = INT_MAX;</div><div class=\"line\"></div><div class=\"line\">            _visit(root-&gt;left, root-&gt;val);</div><div class=\"line\">            _visit(root-&gt;right, root-&gt;val);</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode *node, int pre) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (abs(node-&gt;val - pre) &lt; res) &#123;</div><div class=\"line\">                res = abs(node-&gt;val - pre);</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(node-&gt;left, node-&gt;val);</div><div class=\"line\">            _visit(node-&gt;right, node-&gt;val);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So, I found the target is to find the minimum result between any node. So the result is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        vector&lt;int&gt; nodes;</div><div class=\"line\"></div><div class=\"line\">        int getMinimumDifference(TreeNode* root) &#123;</div><div class=\"line\">            res = INT_MAX;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\"></div><div class=\"line\">            _visit(root);</div><div class=\"line\"></div><div class=\"line\">            sort(nodes.begin(), nodes.end());</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nodes.size() - 1; i++) &#123;</div><div class=\"line\">                res = min(res, abs(nodes[i] - nodes[i + 1]));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode *node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            nodes.push_back(node-&gt;val);</div><div class=\"line\">            _visit(node-&gt;left);</div><div class=\"line\">            _visit(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here I use a vector to store every node. Its time complex is O(nlogn), its fast but I can be better. to use the feature of BST. to find the array in order.</p>\n<p>But it already gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">1</div><div class=\"line\"> \\</div><div class=\"line\">  3</div><div class=\"line\"> /</div><div class=\"line\">2</div><div class=\"line\">Output:</div><div class=\"line\">1</div></pre></td></tr></table></figure>\n<p>Explanation:<br>The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).</p>\n<p>Note: There are at least two nodes in this BST.</p>\n</blockquote>","more":"<p>This is Leetcode No.530. At first I thought this problem wants us to find out the minimum absolute difference between in the neighbour nodes.</p>\n<p>So the wrong result is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\"></div><div class=\"line\">        int getMinimumDifference(TreeNode* root) &#123;</div><div class=\"line\">            res = INT_MAX;</div><div class=\"line\"></div><div class=\"line\">            _visit(root-&gt;left, root-&gt;val);</div><div class=\"line\">            _visit(root-&gt;right, root-&gt;val);</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode *node, int pre) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (abs(node-&gt;val - pre) &lt; res) &#123;</div><div class=\"line\">                res = abs(node-&gt;val - pre);</div><div class=\"line\">            &#125;</div><div class=\"line\">            _visit(node-&gt;left, node-&gt;val);</div><div class=\"line\">            _visit(node-&gt;right, node-&gt;val);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So, I found the target is to find the minimum result between any node. So the result is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int res;</div><div class=\"line\">        vector&lt;int&gt; nodes;</div><div class=\"line\"></div><div class=\"line\">        int getMinimumDifference(TreeNode* root) &#123;</div><div class=\"line\">            res = INT_MAX;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\"></div><div class=\"line\">            _visit(root);</div><div class=\"line\"></div><div class=\"line\">            sort(nodes.begin(), nodes.end());</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nodes.size() - 1; i++) &#123;</div><div class=\"line\">                res = min(res, abs(nodes[i] - nodes[i + 1]));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _visit(TreeNode *node) &#123;</div><div class=\"line\">            if (node == NULL) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            nodes.push_back(node-&gt;val);</div><div class=\"line\">            _visit(node-&gt;left);</div><div class=\"line\">            _visit(node-&gt;right);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Here I use a vector to store every node. Its time complex is O(nlogn), its fast but I can be better. to use the feature of BST. to find the array in order.</p>\n<p>But it already gets AC.</p>"},{"title":"Minesweeper","date":"2017-02-28T01:45:22.000Z","_content":"\n> You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.\n>\n> Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:\n>\n>  + If a mine ('M') is revealed, then the game is over - change it to 'X'.\n>  + If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.\n>  + If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.\n>  + Return the board when no more squares will be revealed.\n>\n<!--more-->\n>\n> Example 1:\n>\n> Input:\n>```\n[\n    ['E', 'E', 'E', 'E', 'E'],\n    ['E', 'E', 'M', 'E', 'E'],\n    ['E', 'E', 'E', 'E', 'E'],\n    ['E', 'E', 'E', 'E', 'E']\n]\n```\n> Click : [3,0]\n>\n> Output:\n>```\n[\n    ['B', '1', 'E', '1', 'B'],\n    ['B', '1', 'M', '1', 'B'],\n    ['B', '1', '1', '1', 'B'],\n    ['B', 'B', 'B', 'B', 'B']\n]\n```\n> Example 2:\n>\n> Input:\n>```\n[\n    ['B', '1', 'E', '1', 'B'],\n    ['B', '1', 'M', '1', 'B'],\n    ['B', '1', '1', '1', 'B'],\n    ['B', 'B', 'B', 'B', 'B']\n]\n```\n> Click : [1,2]\n>\n> Output:\n>```\n[\n    ['B', '1', 'E', '1', 'B'],\n    ['B', '1', 'X', '1', 'B'],\n    ['B', '1', '1', '1', 'B'],\n    ['B', 'B', 'B', 'B', 'B']\n]\n```\n> Note:\n>\n>  + The range of the input matrix's height and width is [1,50].\n>  + The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.\n>  + The input board won't be a stage when game is over (some mines have been revealed).\n>  + For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.\n\nThis is Leetcode No.529, and it is really a fun problem. Because you should find the way to discover the mines.\n\nThe most important thing is to find the order to do the steps.\n\n1. count the mines around the cell.\n2. if the mines is zero, you should check the cells around the cell.\n3. then, do 1 until the mines is not zero.\n\nSo, the solution is as following:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<char>> updateBoard(vector<vector<char> >& board, vector<int>& click) {\n        int idx = click[0];\n        int idy = click[1];\n\n        markBoard(idx, idy, board);\n\n        return board;\n    }\n\n    void markBoard(int x, int y, vector<vector<char> > &board) {\n        if (x < 0 || x >= (int)board.size() || y < 0 || y >= (int)board[0].size()) {\n            return;\n        }\n        if (board[x][y] != 'E' && board[x][y] != 'M') {\n            return;\n        }\n        int num = checkAround(x, y, board);\n        if (num == 0) {\n            board[x][y] = 'B';\n            markBoard(x - 1, y - 1, board);\n            markBoard(x - 1, y, board);\n            markBoard(x - 1, y + 1, board);\n            markBoard(x, y - 1, board);\n            markBoard(x, y + 1, board);\n            markBoard(x + 1, y - 1, board);\n            markBoard(x + 1, y, board);\n            markBoard(x + 1, y + 1, board);\n        } else if (num == -1) {\n            board[x][y] = 'X';\n            return;\n        } else {\n            board[x][y] = '0' + num;\n        }\n    }\n\n    int checkAround(int x, int y, vector<vector<char> > board) {\n        if (board[x][y] == 'M') {\n            return -1;\n        }\n        int num = 0;\n        for (int i = -1; i <= 1; i++) {\n            int idx = x + i;\n            for (int j = -1; j <= 1; j++) {\n                int idy = y + j;\n\n                if (idx >= 0 && idx < (int)board.size() && idy >= 0 && idy < (int)board[0].size()) {\n                    if (board[idx][idy] == 'M') {\n                        num++;\n                    }\n                }\n            }\n        }\n        return num;\n    }\n};\n```\n\nIt gets AC.\n","source":"_posts/Minesweeper.md","raw":"---\ntitle: Minesweeper\ndate: 2017-02-28 09:45:22\ntags:\n    - Depth-first Search\n    - Breadth-first Search\n---\n\n> You are given a 2D char matrix representing the game board. 'M' represents an unrevealed mine, 'E' represents an unrevealed empty square, 'B' represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit ('1' to '8') represents how many mines are adjacent to this revealed square, and finally 'X' represents a revealed mine.\n>\n> Now given the next click position (row and column indices) among all the unrevealed squares ('M' or 'E'), return the board after revealing this position according to the following rules:\n>\n>  + If a mine ('M') is revealed, then the game is over - change it to 'X'.\n>  + If an empty square ('E') with no adjacent mines is revealed, then change it to revealed blank ('B') and all of its adjacent unrevealed squares should be revealed recursively.\n>  + If an empty square ('E') with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.\n>  + Return the board when no more squares will be revealed.\n>\n<!--more-->\n>\n> Example 1:\n>\n> Input:\n>```\n[\n    ['E', 'E', 'E', 'E', 'E'],\n    ['E', 'E', 'M', 'E', 'E'],\n    ['E', 'E', 'E', 'E', 'E'],\n    ['E', 'E', 'E', 'E', 'E']\n]\n```\n> Click : [3,0]\n>\n> Output:\n>```\n[\n    ['B', '1', 'E', '1', 'B'],\n    ['B', '1', 'M', '1', 'B'],\n    ['B', '1', '1', '1', 'B'],\n    ['B', 'B', 'B', 'B', 'B']\n]\n```\n> Example 2:\n>\n> Input:\n>```\n[\n    ['B', '1', 'E', '1', 'B'],\n    ['B', '1', 'M', '1', 'B'],\n    ['B', '1', '1', '1', 'B'],\n    ['B', 'B', 'B', 'B', 'B']\n]\n```\n> Click : [1,2]\n>\n> Output:\n>```\n[\n    ['B', '1', 'E', '1', 'B'],\n    ['B', '1', 'X', '1', 'B'],\n    ['B', '1', '1', '1', 'B'],\n    ['B', 'B', 'B', 'B', 'B']\n]\n```\n> Note:\n>\n>  + The range of the input matrix's height and width is [1,50].\n>  + The click position will only be an unrevealed square ('M' or 'E'), which also means the input board contains at least one clickable square.\n>  + The input board won't be a stage when game is over (some mines have been revealed).\n>  + For simplicity, not mentioned rules should be ignored in this problem. For example, you don't need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.\n\nThis is Leetcode No.529, and it is really a fun problem. Because you should find the way to discover the mines.\n\nThe most important thing is to find the order to do the steps.\n\n1. count the mines around the cell.\n2. if the mines is zero, you should check the cells around the cell.\n3. then, do 1 until the mines is not zero.\n\nSo, the solution is as following:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<char>> updateBoard(vector<vector<char> >& board, vector<int>& click) {\n        int idx = click[0];\n        int idy = click[1];\n\n        markBoard(idx, idy, board);\n\n        return board;\n    }\n\n    void markBoard(int x, int y, vector<vector<char> > &board) {\n        if (x < 0 || x >= (int)board.size() || y < 0 || y >= (int)board[0].size()) {\n            return;\n        }\n        if (board[x][y] != 'E' && board[x][y] != 'M') {\n            return;\n        }\n        int num = checkAround(x, y, board);\n        if (num == 0) {\n            board[x][y] = 'B';\n            markBoard(x - 1, y - 1, board);\n            markBoard(x - 1, y, board);\n            markBoard(x - 1, y + 1, board);\n            markBoard(x, y - 1, board);\n            markBoard(x, y + 1, board);\n            markBoard(x + 1, y - 1, board);\n            markBoard(x + 1, y, board);\n            markBoard(x + 1, y + 1, board);\n        } else if (num == -1) {\n            board[x][y] = 'X';\n            return;\n        } else {\n            board[x][y] = '0' + num;\n        }\n    }\n\n    int checkAround(int x, int y, vector<vector<char> > board) {\n        if (board[x][y] == 'M') {\n            return -1;\n        }\n        int num = 0;\n        for (int i = -1; i <= 1; i++) {\n            int idx = x + i;\n            for (int j = -1; j <= 1; j++) {\n                int idy = y + j;\n\n                if (idx >= 0 && idx < (int)board.size() && idy >= 0 && idy < (int)board[0].size()) {\n                    if (board[idx][idy] == 'M') {\n                        num++;\n                    }\n                }\n            }\n        }\n        return num;\n    }\n};\n```\n\nIt gets AC.\n","slug":"Minesweeper","published":1,"updated":"2017-02-28T02:24:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwu003ag5f4qcdx8xs6","content":"<blockquote>\n<p>You are given a 2D char matrix representing the game board. M represents an unrevealed mine, E represents an unrevealed empty square, B represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (1 to 8) represents how many mines are adjacent to this revealed square, and finally X represents a revealed mine.</p>\n<p>Now given the next click position (row and column indices) among all the unrevealed squares (M or E), return the board after revealing this position according to the following rules:</p>\n<ul>\n<li>If a mine (M) is revealed, then the game is over - change it to X.</li>\n<li>If an empty square (E) with no adjacent mines is revealed, then change it to revealed blank (B) and all of its adjacent unrevealed squares should be revealed recursively.</li>\n<li>If an empty square (E) with at least one adjacent mine is revealed, then change it to a digit (1 to 8) representing the number of adjacent mines.</li>\n<li>Return the board when no more squares will be revealed.</li>\n</ul>\n<a id=\"more\"></a>\n<p>Example 1:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Click : [3,0]</p>\n<p>Output:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Example 2:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Click : [1,2]</p>\n<p>Output:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The range of the input matrixs height and width is [1,50].</li>\n<li>The click position will only be an unrevealed square (M or E), which also means the input board contains at least one clickable square.</li>\n<li>The input board wont be a stage when game is over (some mines have been revealed).</li>\n<li>For simplicity, not mentioned rules should be ignored in this problem. For example, you dont need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>\n</ul>\n</blockquote>\n<p>This is Leetcode No.529, and it is really a fun problem. Because you should find the way to discover the mines.</p>\n<p>The most important thing is to find the order to do the steps.</p>\n<ol>\n<li>count the mines around the cell.</li>\n<li>if the mines is zero, you should check the cells around the cell.</li>\n<li>then, do 1 until the mines is not zero.</li>\n</ol>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</div><div class=\"line\">        int idx = click[0];</div><div class=\"line\">        int idy = click[1];</div><div class=\"line\"></div><div class=\"line\">        markBoard(idx, idy, board);</div><div class=\"line\"></div><div class=\"line\">        return board;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    void markBoard(int x, int y, vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123;</div><div class=\"line\">        if (x &lt; 0 || x &gt;= (int)board.size() || y &lt; 0 || y &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (board[x][y] != &apos;E&apos; &amp;&amp; board[x][y] != &apos;M&apos;) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int num = checkAround(x, y, board);</div><div class=\"line\">        if (num == 0) &#123;</div><div class=\"line\">            board[x][y] = &apos;B&apos;;</div><div class=\"line\">            markBoard(x - 1, y - 1, board);</div><div class=\"line\">            markBoard(x - 1, y, board);</div><div class=\"line\">            markBoard(x - 1, y + 1, board);</div><div class=\"line\">            markBoard(x, y - 1, board);</div><div class=\"line\">            markBoard(x, y + 1, board);</div><div class=\"line\">            markBoard(x + 1, y - 1, board);</div><div class=\"line\">            markBoard(x + 1, y, board);</div><div class=\"line\">            markBoard(x + 1, y + 1, board);</div><div class=\"line\">        &#125; else if (num == -1) &#123;</div><div class=\"line\">            board[x][y] = &apos;X&apos;;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            board[x][y] = &apos;0&apos; + num;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int checkAround(int x, int y, vector&lt;vector&lt;char&gt; &gt; board) &#123;</div><div class=\"line\">        if (board[x][y] == &apos;M&apos;) &#123;</div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int num = 0;</div><div class=\"line\">        for (int i = -1; i &lt;= 1; i++) &#123;</div><div class=\"line\">            int idx = x + i;</div><div class=\"line\">            for (int j = -1; j &lt;= 1; j++) &#123;</div><div class=\"line\">                int idy = y + j;</div><div class=\"line\"></div><div class=\"line\">                if (idx &gt;= 0 &amp;&amp; idx &lt; (int)board.size() &amp;&amp; idy &gt;= 0 &amp;&amp; idy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;M&apos;) &#123;</div><div class=\"line\">                        num++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return num;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>You are given a 2D char matrix representing the game board. M represents an unrevealed mine, E represents an unrevealed empty square, B represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (1 to 8) represents how many mines are adjacent to this revealed square, and finally X represents a revealed mine.</p>\n<p>Now given the next click position (row and column indices) among all the unrevealed squares (M or E), return the board after revealing this position according to the following rules:</p>\n<ul>\n<li>If a mine (M) is revealed, then the game is over - change it to X.</li>\n<li>If an empty square (E) with no adjacent mines is revealed, then change it to revealed blank (B) and all of its adjacent unrevealed squares should be revealed recursively.</li>\n<li>If an empty square (E) with at least one adjacent mine is revealed, then change it to a digit (1 to 8) representing the number of adjacent mines.</li>\n<li>Return the board when no more squares will be revealed.</li>\n</ul>","more":"<p>Example 1:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;M&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;],</div><div class=\"line\">    [&apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;, &apos;E&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Click : [3,0]</p>\n<p>Output:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Example 2:</p>\n<p>Input:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;M&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Click : [1,2]</p>\n<p>Output:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;E&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;X&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;1&apos;, &apos;1&apos;, &apos;1&apos;, &apos;B&apos;],</div><div class=\"line\">    [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The range of the input matrixs height and width is [1,50].</li>\n<li>The click position will only be an unrevealed square (M or E), which also means the input board contains at least one clickable square.</li>\n<li>The input board wont be a stage when game is over (some mines have been revealed).</li>\n<li>For simplicity, not mentioned rules should be ignored in this problem. For example, you dont need to reveal all the unrevealed mines when the game is over, consider any cases that you will win the game or flag any squares.</li>\n</ul>\n</blockquote>\n<p>This is Leetcode No.529, and it is really a fun problem. Because you should find the way to discover the mines.</p>\n<p>The most important thing is to find the order to do the steps.</p>\n<ol>\n<li>count the mines around the cell.</li>\n<li>if the mines is zero, you should check the cells around the cell.</li>\n<li>then, do 1 until the mines is not zero.</li>\n</ol>\n<p>So, the solution is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    vector&lt;vector&lt;char&gt;&gt; updateBoard(vector&lt;vector&lt;char&gt; &gt;&amp; board, vector&lt;int&gt;&amp; click) &#123;</div><div class=\"line\">        int idx = click[0];</div><div class=\"line\">        int idy = click[1];</div><div class=\"line\"></div><div class=\"line\">        markBoard(idx, idy, board);</div><div class=\"line\"></div><div class=\"line\">        return board;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    void markBoard(int x, int y, vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123;</div><div class=\"line\">        if (x &lt; 0 || x &gt;= (int)board.size() || y &lt; 0 || y &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (board[x][y] != &apos;E&apos; &amp;&amp; board[x][y] != &apos;M&apos;) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int num = checkAround(x, y, board);</div><div class=\"line\">        if (num == 0) &#123;</div><div class=\"line\">            board[x][y] = &apos;B&apos;;</div><div class=\"line\">            markBoard(x - 1, y - 1, board);</div><div class=\"line\">            markBoard(x - 1, y, board);</div><div class=\"line\">            markBoard(x - 1, y + 1, board);</div><div class=\"line\">            markBoard(x, y - 1, board);</div><div class=\"line\">            markBoard(x, y + 1, board);</div><div class=\"line\">            markBoard(x + 1, y - 1, board);</div><div class=\"line\">            markBoard(x + 1, y, board);</div><div class=\"line\">            markBoard(x + 1, y + 1, board);</div><div class=\"line\">        &#125; else if (num == -1) &#123;</div><div class=\"line\">            board[x][y] = &apos;X&apos;;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            board[x][y] = &apos;0&apos; + num;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int checkAround(int x, int y, vector&lt;vector&lt;char&gt; &gt; board) &#123;</div><div class=\"line\">        if (board[x][y] == &apos;M&apos;) &#123;</div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        int num = 0;</div><div class=\"line\">        for (int i = -1; i &lt;= 1; i++) &#123;</div><div class=\"line\">            int idx = x + i;</div><div class=\"line\">            for (int j = -1; j &lt;= 1; j++) &#123;</div><div class=\"line\">                int idy = y + j;</div><div class=\"line\"></div><div class=\"line\">                if (idx &gt;= 0 &amp;&amp; idx &lt; (int)board.size() &amp;&amp; idy &gt;= 0 &amp;&amp; idy &lt; (int)board[0].size()) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;M&apos;) &#123;</div><div class=\"line\">                        num++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return num;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Minimum Time Difference","date":"2017-03-14T07:50:10.000Z","_content":"\n\n> Given a list of 24-hour clock time points in \"Hour:Minutes\" format, find the minimum minutes difference between any two time points in the list.\n>\n> Example 1:\n>```\nInput: [\"23:59\",\"00:00\"]\nOutput: 1\n```\n> Note:\n>\n> + The number of time points in the given list is at least 2 and won't exceed 20000.\n> + The input time is legal and ranges from 00:00 to 23:59.\n\n<!--more-->\n\nThis is Leetcode No.539. It is an esay problem, the most thing I think is that we should pay attention to the time convertion.\n\nI make the timestamp into minutes. So that I can find the order between them.\n\nThen, I sort the array and try to find the minimum value of the distance.\n\nI can make the solution more quick by just counting the neighbour and the head and tail value instead of count every pair.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinDifference(vector<string>& timePoints) {\n        vector<int> mins;\n\n        int res = INT_MAX;\n\n        for (int i = 0; i < (int)timePoints.size(); i++) {\n            int hour = atoi(timePoints[i].substr(0, 2).c_str()) * 60;\n            int minutes = atoi(timePoints[i].substr(3, 5).c_str()) + hour;\n            mins.push_back(minutes);\n        }\n\n        sort(mins.begin(), mins.end());\n\n        for (int idx = 0; idx < (int)mins.size(); idx++) {\n            for (int idy = idx + 1; idy < (int)mins.size(); idy++) {\n                res = min(res, mins[idy] - mins[idx]);\n                res = min(res, 60 * 24 - (mins[idy] - mins[idx]));\n            }\n        }\n\n        return res;\n    }\n};\n```\n\nBut, I AC the problem, the improvement? who cares.\n","source":"_posts/MinimumTimeDifference.md","raw":"---\ntitle: Minimum Time Difference\ndate: 2017-03-14 15:50:10\ntags:\n    - String\n---\n\n\n> Given a list of 24-hour clock time points in \"Hour:Minutes\" format, find the minimum minutes difference between any two time points in the list.\n>\n> Example 1:\n>```\nInput: [\"23:59\",\"00:00\"]\nOutput: 1\n```\n> Note:\n>\n> + The number of time points in the given list is at least 2 and won't exceed 20000.\n> + The input time is legal and ranges from 00:00 to 23:59.\n\n<!--more-->\n\nThis is Leetcode No.539. It is an esay problem, the most thing I think is that we should pay attention to the time convertion.\n\nI make the timestamp into minutes. So that I can find the order between them.\n\nThen, I sort the array and try to find the minimum value of the distance.\n\nI can make the solution more quick by just counting the neighbour and the head and tail value instead of count every pair.\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinDifference(vector<string>& timePoints) {\n        vector<int> mins;\n\n        int res = INT_MAX;\n\n        for (int i = 0; i < (int)timePoints.size(); i++) {\n            int hour = atoi(timePoints[i].substr(0, 2).c_str()) * 60;\n            int minutes = atoi(timePoints[i].substr(3, 5).c_str()) + hour;\n            mins.push_back(minutes);\n        }\n\n        sort(mins.begin(), mins.end());\n\n        for (int idx = 0; idx < (int)mins.size(); idx++) {\n            for (int idy = idx + 1; idy < (int)mins.size(); idy++) {\n                res = min(res, mins[idy] - mins[idx]);\n                res = min(res, 60 * 24 - (mins[idy] - mins[idx]));\n            }\n        }\n\n        return res;\n    }\n};\n```\n\nBut, I AC the problem, the improvement? who cares.\n","slug":"MinimumTimeDifference","published":1,"updated":"2017-03-14T08:07:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwv003cg5f4rqojrwep","content":"<blockquote>\n<p>Given a list of 24-hour clock time points in Hour:Minutes format, find the minimum minutes difference between any two time points in the list.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [&quot;23:59&quot;,&quot;00:00&quot;]</div><div class=\"line\">Output: 1</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The number of time points in the given list is at least 2 and wont exceed 20000.</li>\n<li>The input time is legal and ranges from 00:00 to 23:59.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.539. It is an esay problem, the most thing I think is that we should pay attention to the time convertion.</p>\n<p>I make the timestamp into minutes. So that I can find the order between them.</p>\n<p>Then, I sort the array and try to find the minimum value of the distance.</p>\n<p>I can make the solution more quick by just counting the neighbour and the head and tail value instead of count every pair.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123;</div><div class=\"line\">        vector&lt;int&gt; mins;</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MAX;</div><div class=\"line\"></div><div class=\"line\">        for (int i = 0; i &lt; (int)timePoints.size(); i++) &#123;</div><div class=\"line\">            int hour = atoi(timePoints[i].substr(0, 2).c_str()) * 60;</div><div class=\"line\">            int minutes = atoi(timePoints[i].substr(3, 5).c_str()) + hour;</div><div class=\"line\">            mins.push_back(minutes);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        sort(mins.begin(), mins.end());</div><div class=\"line\"></div><div class=\"line\">        for (int idx = 0; idx &lt; (int)mins.size(); idx++) &#123;</div><div class=\"line\">            for (int idy = idx + 1; idy &lt; (int)mins.size(); idy++) &#123;</div><div class=\"line\">                res = min(res, mins[idy] - mins[idx]);</div><div class=\"line\">                res = min(res, 60 * 24 - (mins[idy] - mins[idx]));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, I AC the problem, the improvement? who cares.</p>\n","excerpt":"<blockquote>\n<p>Given a list of 24-hour clock time points in Hour:Minutes format, find the minimum minutes difference between any two time points in the list.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [&quot;23:59&quot;,&quot;00:00&quot;]</div><div class=\"line\">Output: 1</div></pre></td></tr></table></figure></p>\n<p>Note:</p>\n<ul>\n<li>The number of time points in the given list is at least 2 and wont exceed 20000.</li>\n<li>The input time is legal and ranges from 00:00 to 23:59.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.539. It is an esay problem, the most thing I think is that we should pay attention to the time convertion.</p>\n<p>I make the timestamp into minutes. So that I can find the order between them.</p>\n<p>Then, I sort the array and try to find the minimum value of the distance.</p>\n<p>I can make the solution more quick by just counting the neighbour and the head and tail value instead of count every pair.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int findMinDifference(vector&lt;string&gt;&amp; timePoints) &#123;</div><div class=\"line\">        vector&lt;int&gt; mins;</div><div class=\"line\"></div><div class=\"line\">        int res = INT_MAX;</div><div class=\"line\"></div><div class=\"line\">        for (int i = 0; i &lt; (int)timePoints.size(); i++) &#123;</div><div class=\"line\">            int hour = atoi(timePoints[i].substr(0, 2).c_str()) * 60;</div><div class=\"line\">            int minutes = atoi(timePoints[i].substr(3, 5).c_str()) + hour;</div><div class=\"line\">            mins.push_back(minutes);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        sort(mins.begin(), mins.end());</div><div class=\"line\"></div><div class=\"line\">        for (int idx = 0; idx &lt; (int)mins.size(); idx++) &#123;</div><div class=\"line\">            for (int idy = idx + 1; idy &lt; (int)mins.size(); idy++) &#123;</div><div class=\"line\">                res = min(res, mins[idy] - mins[idx]);</div><div class=\"line\">                res = min(res, 60 * 24 - (mins[idy] - mins[idx]));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        return res;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>But, I AC the problem, the improvement? who cares.</p>"},{"title":"New Start","date":"2017-01-01T05:46:25.000Z","_content":"\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","source":"_posts/NewStart.md","raw":"---\ntitle: New Start\ndate: 2017-01-01 13:46:25\ntags: \n    - Description\n---\n\nAs I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.\n\n<!--more-->\n","slug":"NewStart","published":1,"updated":"2017-01-03T06:47:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwy003fg5f4hbiv4n0j","content":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>\n<a id=\"more\"></a>\n","excerpt":"<p>As I promised before. I will write blogs in two languages. And here, I will use English to write about my oj games in order to improve my interview skills.</p>","more":""},{"title":"Most Frequent Subtree Sum","date":"2017-02-07T01:23:57.000Z","_content":"\n> Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n>\n> Examples 1\n> + Input:\n> ```\n  5\n / \\\n2  -3\n```\n> + return [2, -3, 4], since all the values happen only once, return all of them in any order.\n>\n> Examples 2\n> + Input:\n> ```\n  5\n / \\\n2  -5\n```\n> + return [2], since 2 happens twice, however -5 only occur once.\n>\n> Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n\n<!--more-->\n\nThis is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.\n\nSo, the code is as following:\n\n```\nclass Solution {\n    map<int, int> nodes;\n    public:\n        vector<int> findFrequentTreeSum(TreeNode* root) {\n            nodes.clear();\n            _visit(root);\n\n            int maxTimes = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > maxTimes) {\n                    maxTimes = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == maxTimes) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        int _visit(TreeNode* currentNode) {\n            if (currentNode == NULL) {\n                return 0;\n            }\n\n            if (currentNode->left == NULL && currentNode->right == NULL) {\n                _record(currentNode->val);\n                return currentNode->val;\n            }\n\n            if (currentNode->left != NULL && currentNode->right == NULL) {\n                int value = currentNode->val + _visit(currentNode->left);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left == NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left != NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->left) + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            return 0;\n        }\n\n        void _record(int value) {\n            if (nodes.find(value) != nodes.end()) {\n                nodes.find(value)->second++;\n            } else {\n                nodes.insert(pair<int, int>(value, 1));\n            }\n        }\n};\n```\n\nDone, it gets AC.\n","source":"_posts/MostFrequentSubtreeSum.md","raw":"---\ntitle: Most Frequent Subtree Sum\ndate: 2017-02-07 09:23:57\ntags:\n    - Tree\n    - Hash Table\n---\n\n> Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.\n>\n> Examples 1\n> + Input:\n> ```\n  5\n / \\\n2  -3\n```\n> + return [2, -3, 4], since all the values happen only once, return all of them in any order.\n>\n> Examples 2\n> + Input:\n> ```\n  5\n / \\\n2  -5\n```\n> + return [2], since 2 happens twice, however -5 only occur once.\n>\n> Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.\n\n<!--more-->\n\nThis is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.\n\nSo, the code is as following:\n\n```\nclass Solution {\n    map<int, int> nodes;\n    public:\n        vector<int> findFrequentTreeSum(TreeNode* root) {\n            nodes.clear();\n            _visit(root);\n\n            int maxTimes = INT_MIN;\n            for (auto i : nodes) {\n                if (i.second > maxTimes) {\n                    maxTimes = i.second;\n                }\n            }\n\n            vector<int> res;\n            for (auto i : nodes) {\n                if (i.second == maxTimes) {\n                    res.push_back(i.first);\n                }\n            }\n\n            return res;\n        }\n\n        int _visit(TreeNode* currentNode) {\n            if (currentNode == NULL) {\n                return 0;\n            }\n\n            if (currentNode->left == NULL && currentNode->right == NULL) {\n                _record(currentNode->val);\n                return currentNode->val;\n            }\n\n            if (currentNode->left != NULL && currentNode->right == NULL) {\n                int value = currentNode->val + _visit(currentNode->left);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left == NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            if (currentNode->left != NULL && currentNode->right != NULL) {\n                int value = currentNode->val + _visit(currentNode->left) + _visit(currentNode->right);\n                _record(value);\n                return value;\n            }\n\n            return 0;\n        }\n\n        void _record(int value) {\n            if (nodes.find(value) != nodes.end()) {\n                nodes.find(value)->second++;\n            } else {\n                nodes.insert(pair<int, int>(value, 1));\n            }\n        }\n};\n```\n\nDone, it gets AC.\n","slug":"MostFrequentSubtreeSum","published":1,"updated":"2017-02-14T07:06:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatwz003hg5f452jf2eep","content":"<blockquote>\n<p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p>\n<p>Examples 1</p>\n<ul>\n<li><p>Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  5</div><div class=\"line\"> / \\</div><div class=\"line\">2  -3</div></pre></td></tr></table></figure>\n</li>\n<li><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p>\n</li>\n</ul>\n<p>Examples 2</p>\n<ul>\n<li><p>Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  5</div><div class=\"line\"> / \\</div><div class=\"line\">2  -5</div></pre></td></tr></table></figure>\n</li>\n<li><p>return [2], since 2 happens twice, however -5 only occur once.</p>\n</li>\n</ul>\n<p>Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.</p>\n<p>So, the code is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    map&lt;int, int&gt; nodes;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\">            _visit(root);</div><div class=\"line\"></div><div class=\"line\">            int maxTimes = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; maxTimes) &#123;</div><div class=\"line\">                    maxTimes = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == maxTimes) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _visit(TreeNode* currentNode) &#123;</div><div class=\"line\">            if (currentNode == NULL) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                _record(currentNode-&gt;val);</div><div class=\"line\">                return currentNode-&gt;val;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left) + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _record(int value) &#123;</div><div class=\"line\">            if (nodes.find(value) != nodes.end()) &#123;</div><div class=\"line\">                nodes.find(value)-&gt;second++;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(value, 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Done, it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</p>\n<p>Examples 1</p>\n<ul>\n<li><p>Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  5</div><div class=\"line\"> / \\</div><div class=\"line\">2  -3</div></pre></td></tr></table></figure>\n</li>\n<li><p>return [2, -3, 4], since all the values happen only once, return all of them in any order.</p>\n</li>\n</ul>\n<p>Examples 2</p>\n<ul>\n<li><p>Input:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">  5</div><div class=\"line\"> / \\</div><div class=\"line\">2  -5</div></pre></td></tr></table></figure>\n</li>\n<li><p>return [2], since 2 happens twice, however -5 only occur once.</p>\n</li>\n</ul>\n<p>Note: You may assume the sum of values in any subtree is in the range of 32-bit signed integer.</p>\n</blockquote>","more":"<p>This is Leetcode 508, and it is a standard problem based on Tree. We just need to mark the last condition of the subTree.</p>\n<p>So, the code is as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    map&lt;int, int&gt; nodes;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</div><div class=\"line\">            nodes.clear();</div><div class=\"line\">            _visit(root);</div><div class=\"line\"></div><div class=\"line\">            int maxTimes = INT_MIN;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second &gt; maxTimes) &#123;</div><div class=\"line\">                    maxTimes = i.second;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (auto i : nodes) &#123;</div><div class=\"line\">                if (i.second == maxTimes) &#123;</div><div class=\"line\">                    res.push_back(i.first);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int _visit(TreeNode* currentNode) &#123;</div><div class=\"line\">            if (currentNode == NULL) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                _record(currentNode-&gt;val);</div><div class=\"line\">                return currentNode-&gt;val;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right == NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left == NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (currentNode-&gt;left != NULL &amp;&amp; currentNode-&gt;right != NULL) &#123;</div><div class=\"line\">                int value = currentNode-&gt;val + _visit(currentNode-&gt;left) + _visit(currentNode-&gt;right);</div><div class=\"line\">                _record(value);</div><div class=\"line\">                return value;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return 0;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _record(int value) &#123;</div><div class=\"line\">            if (nodes.find(value) != nodes.end()) &#123;</div><div class=\"line\">                nodes.find(value)-&gt;second++;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                nodes.insert(pair&lt;int, int&gt;(value, 1));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Done, it gets AC.</p>"},{"title":"Number Complement","date":"2017-01-24T15:33:22.000Z","_content":"\n> Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\n>\n> Note:\n>\n>   + The given integer is guaranteed to fit within the range of a 32-bit signed integer.\n>   + You could assume no leading zero bit in the integers binary representation.\n>\n> Example 1:\n> + Input: 5 Output: 2\n> + Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n>\n> Example 2:\n> + Input: 1 Output: 0\n> + Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n<!--more-->\n\nThis is Leetcode 476. Easy problem. But here are many solutions.\n\nYou can divide the num by 2 and find the 1 bit and sum on the other hand.\n\nIt may cost O(logN) time complex.\n\nBut here I use another way:\n\n```\nclass Solution {\n    public:\n        int findComplement(int num) {\n            int level = 0;\n            while (pow(2, level) <= num) {\n                level++;\n            }\n            return (int)(pow(2, level) - 1) ^ num;\n        }\n};\n```\n\nYou can find that 0x101 ^ 0x111 = 0x010\n\nSo, That's what I use. And it gets AC.\n","source":"_posts/NumberComplement.md","raw":"---\ntitle: Number Complement\ndate: 2017-01-24 23:33:22\ntags:\n    - Bitmap\n---\n\n> Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\n>\n> Note:\n>\n>   + The given integer is guaranteed to fit within the range of a 32-bit signed integer.\n>   + You could assume no leading zero bit in the integers binary representation.\n>\n> Example 1:\n> + Input: 5 Output: 2\n> + Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n>\n> Example 2:\n> + Input: 1 Output: 0\n> + Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\n\n<!--more-->\n\nThis is Leetcode 476. Easy problem. But here are many solutions.\n\nYou can divide the num by 2 and find the 1 bit and sum on the other hand.\n\nIt may cost O(logN) time complex.\n\nBut here I use another way:\n\n```\nclass Solution {\n    public:\n        int findComplement(int num) {\n            int level = 0;\n            while (pow(2, level) <= num) {\n                level++;\n            }\n            return (int)(pow(2, level) - 1) ^ num;\n        }\n};\n```\n\nYou can find that 0x101 ^ 0x111 = 0x010\n\nSo, That's what I use. And it gets AC.\n","slug":"NumberComplement","published":1,"updated":"2017-01-24T15:51:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatx2003kg5f40ncpbuc1","content":"<blockquote>\n<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n<p>Note:</p>\n<ul>\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\n<li>You could assume no leading zero bit in the integers binary representation.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: 5 Output: 2</li>\n<li>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 1 Output: 0</li>\n<li>Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 476. Easy problem. But here are many solutions.</p>\n<p>You can divide the num by 2 and find the 1 bit and sum on the other hand.</p>\n<p>It may cost O(logN) time complex.</p>\n<p>But here I use another way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findComplement(int num) &#123;</div><div class=\"line\">            int level = 0;</div><div class=\"line\">            while (pow(2, level) &lt;= num) &#123;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return (int)(pow(2, level) - 1) ^ num;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>You can find that 0x101 ^ 0x111 = 0x010</p>\n<p>So, Thats what I use. And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\n<p>Note:</p>\n<ul>\n<li>The given integer is guaranteed to fit within the range of a 32-bit signed integer.</li>\n<li>You could assume no leading zero bit in the integers binary representation.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: 5 Output: 2</li>\n<li>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 1 Output: 0</li>\n<li>Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 476. Easy problem. But here are many solutions.</p>\n<p>You can divide the num by 2 and find the 1 bit and sum on the other hand.</p>\n<p>It may cost O(logN) time complex.</p>\n<p>But here I use another way:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findComplement(int num) &#123;</div><div class=\"line\">            int level = 0;</div><div class=\"line\">            while (pow(2, level) &lt;= num) &#123;</div><div class=\"line\">                level++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return (int)(pow(2, level) - 1) ^ num;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>You can find that 0x101 ^ 0x111 = 0x010</p>\n<p>So, Thats what I use. And it gets AC.</p>"},{"title":"Next Greater Element I","date":"2017-02-05T06:24:59.000Z","_content":"\n\n> You are given two arrays (without duplicates) nums1 and nums2 where nums1s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.\n>\n> The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n>\n> Example 1:\n> + Input: nums1 = [4,1,2], nums2 = [1,3,4,2].\n> + Output: [-1,3,-1]\n> + Explanation:\n>     + For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n>     + For number 1 in the first array, the next greater number for it in the second array is 3.\n>     + For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Example 2:\n> + Input: nums1 = [2,4], nums2 = [1,2,3,4].\n> + Output: [3,-1]\n> + Explanation:\n>     + For number 2 in the first array, the next greater number for it in the second array is 3.\n>     + For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Note:\n> + All elements in nums1 and nums2 are unique.\n> + The length of both nums1 and nums2 would not exceed 1000.\n\n<!--more-->\n\nThis is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.\n\n```\nclass Solution {\n    public:\n        vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {\n            vector<int> res;\n            for (int i = 0; i < (int)findNums.size(); i++) {\n                int standard = -1;\n                bool isOk = false;\n                for (int j = 0; j < (int)nums.size(); j++) {\n                    if (findNums[i] == nums[j]) {\n                        standard = j;\n                    }\n                    if (standard != -1 && j > standard && nums[j] > findNums[i]) {\n                        res.push_back(nums[j]);\n                        isOk = true;\n                        break;\n                    }\n                }\n                if (!isOk) {\n                    res.push_back(-1);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/NextGreaterElementI.md","raw":"---\ntitle: Next Greater Element I\ndate: 2017-02-05 14:24:59\ntags:\n    - Array\n---\n\n\n> You are given two arrays (without duplicates) nums1 and nums2 where nums1s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.\n>\n> The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n>\n> Example 1:\n> + Input: nums1 = [4,1,2], nums2 = [1,3,4,2].\n> + Output: [-1,3,-1]\n> + Explanation:\n>     + For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.\n>     + For number 1 in the first array, the next greater number for it in the second array is 3.\n>     + For number 2 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Example 2:\n> + Input: nums1 = [2,4], nums2 = [1,2,3,4].\n> + Output: [3,-1]\n> + Explanation:\n>     + For number 2 in the first array, the next greater number for it in the second array is 3.\n>     + For number 4 in the first array, there is no next greater number for it in the second array, so output -1.\n>\n> Note:\n> + All elements in nums1 and nums2 are unique.\n> + The length of both nums1 and nums2 would not exceed 1000.\n\n<!--more-->\n\nThis is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.\n\n```\nclass Solution {\n    public:\n        vector<int> nextGreaterElement(vector<int>& findNums, vector<int>& nums) {\n            vector<int> res;\n            for (int i = 0; i < (int)findNums.size(); i++) {\n                int standard = -1;\n                bool isOk = false;\n                for (int j = 0; j < (int)nums.size(); j++) {\n                    if (findNums[i] == nums[j]) {\n                        standard = j;\n                    }\n                    if (standard != -1 && j > standard && nums[j] > findNums[i]) {\n                        res.push_back(nums[j]);\n                        isOk = true;\n                        break;\n                    }\n                }\n                if (!isOk) {\n                    res.push_back(-1);\n                }\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"NextGreaterElementI","published":1,"updated":"2017-02-05T06:27:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatx3003mg5f4tf2h5ago","content":"<blockquote>\n<p>You are given two arrays (without duplicates) nums1 and nums2 where nums1s elements are subset of nums2. Find all the next greater numbers for nums1s elements in the corresponding places of nums2.</p>\n<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</li>\n<li>Output: [-1,3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</li>\n<li>For number 1 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: nums1 = [2,4], nums2 = [1,2,3,4].</li>\n<li>Output: [3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 2 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>All elements in nums1 and nums2 are unique.</li>\n<li>The length of both nums1 and nums2 would not exceed 1000.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (int i = 0; i &lt; (int)findNums.size(); i++) &#123;</div><div class=\"line\">                int standard = -1;</div><div class=\"line\">                bool isOk = false;</div><div class=\"line\">                for (int j = 0; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (findNums[i] == nums[j]) &#123;</div><div class=\"line\">                        standard = j;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (standard != -1 &amp;&amp; j &gt; standard &amp;&amp; nums[j] &gt; findNums[i]) &#123;</div><div class=\"line\">                        res.push_back(nums[j]);</div><div class=\"line\">                        isOk = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (!isOk) &#123;</div><div class=\"line\">                    res.push_back(-1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>You are given two arrays (without duplicates) nums1 and nums2 where nums1s elements are subset of nums2. Find all the next greater numbers for nums1s elements in the corresponding places of nums2.</p>\n<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].</li>\n<li>Output: [-1,3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.</li>\n<li>For number 1 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 2 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: nums1 = [2,4], nums2 = [1,2,3,4].</li>\n<li>Output: [3,-1]</li>\n<li>Explanation:<ul>\n<li>For number 2 in the first array, the next greater number for it in the second array is 3.</li>\n<li>For number 4 in the first array, there is no next greater number for it in the second array, so output -1.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>All elements in nums1 and nums2 are unique.</li>\n<li>The length of both nums1 and nums2 would not exceed 1000.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 496, and it is leetcode weekly contest in this week. Such an easy problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\">            for (int i = 0; i &lt; (int)findNums.size(); i++) &#123;</div><div class=\"line\">                int standard = -1;</div><div class=\"line\">                bool isOk = false;</div><div class=\"line\">                for (int j = 0; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                    if (findNums[i] == nums[j]) &#123;</div><div class=\"line\">                        standard = j;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (standard != -1 &amp;&amp; j &gt; standard &amp;&amp; nums[j] &gt; findNums[i]) &#123;</div><div class=\"line\">                        res.push_back(nums[j]);</div><div class=\"line\">                        isOk = true;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (!isOk) &#123;</div><div class=\"line\">                    res.push_back(-1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Ones and Zeroes","date":"2017-01-20T15:51:54.000Z","_content":"\n> In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\n>\n> For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\n>\n> Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n>\n> Note:\n> + The given numbers of 0s and 1s will both not exceed 100\n> + The size of given string array won't exceed 600.\n>\n> Example 1:\n> + Input: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3;\n> + Output: 4\n>\n> Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are 10,0001,1,0\n>\n> Example 2:\n> + Input: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n> + Output: 2\n>\n> Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\n\n<!-- more -->\nThis is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.\n\nIn this case, we can find the relationship:\n\nwe can use `m` 0s and `n` 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as `i` and `j` means how many 1s and 0s of the current num.\n\nWhat we should do next is to find the `m to x` and `n to y` to make sure we consider every conditions.\n\nSo, the solution is coming:\n\n```\nclass Solution {\n    public:\n        int findMaxForm(vector<string>& strs, int m, int n) {\n            int DP[600][600];\n            for (int i = 0; i < 600; i++) {\n                for (int j = 0; j < 600; j++) {\n                    DP[i][j] = 0;\n                }\n            }\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int num0 = 0;\n                int num1 = 0;\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    if (strs[i][j] == '0') {\n                        num0++;\n                    } else {\n                        num1++;\n                    }\n                }\n\n                for (int i = m; i >= num0; i--) {\n                    for (int j = n; j >= num1; j--) {\n                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);\n                    }\n                }\n            }\n            return DP[m][n];\n        }\n};\n```\n","source":"_posts/OnesandZeroes.md","raw":"---\ntitle: Ones and Zeroes\ndate: 2017-01-20 23:51:54\ntags:\n    - Dynamic Programming\n---\n\n> In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.\n>\n> For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.\n>\n> Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n>\n> Note:\n> + The given numbers of 0s and 1s will both not exceed 100\n> + The size of given string array won't exceed 600.\n>\n> Example 1:\n> + Input: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3;\n> + Output: 4\n>\n> Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are 10,0001,1,0\n>\n> Example 2:\n> + Input: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1\n> + Output: 2\n>\n> Explanation: You could form \"10\", but then you'd have nothing left. Better form \"0\" and \"1\".\n\n<!-- more -->\nThis is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.\n\nIn this case, we can find the relationship:\n\nwe can use `m` 0s and `n` 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as `i` and `j` means how many 1s and 0s of the current num.\n\nWhat we should do next is to find the `m to x` and `n to y` to make sure we consider every conditions.\n\nSo, the solution is coming:\n\n```\nclass Solution {\n    public:\n        int findMaxForm(vector<string>& strs, int m, int n) {\n            int DP[600][600];\n            for (int i = 0; i < 600; i++) {\n                for (int j = 0; j < 600; j++) {\n                    DP[i][j] = 0;\n                }\n            }\n            for (int i = 0; i < (int)strs.size(); i++) {\n                int num0 = 0;\n                int num1 = 0;\n                for (int j = 0; j < (int)strs[i].length(); j++) {\n                    if (strs[i][j] == '0') {\n                        num0++;\n                    } else {\n                        num1++;\n                    }\n                }\n\n                for (int i = m; i >= num0; i--) {\n                    for (int j = n; j >= num1; j--) {\n                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);\n                    }\n                }\n            }\n            return DP[m][n];\n        }\n};\n```\n","slug":"OnesandZeroes","published":1,"updated":"2017-01-20T16:23:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatx7003pg5f4dgt0va2p","content":"<blockquote>\n<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>\n<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>\n<p>Note:</p>\n<ul>\n<li>The given numbers of 0s and 1s will both not exceed 100</li>\n<li>The size of given string array wont exceed 600.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: Array = {10, 0001, 111001, 1, 0}, m = 5, n = 3;</li>\n<li>Output: 4</li>\n</ul>\n<p>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are 10,0001,1,0</p>\n<p>Example 2:</p>\n<ul>\n<li>Input: Array = {10, 0, 1}, m = 1, n = 1</li>\n<li>Output: 2</li>\n</ul>\n<p>Explanation: You could form 10, but then youd have nothing left. Better form 0 and 1.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.</p>\n<p>In this case, we can find the relationship:</p>\n<p>we can use <code>m</code> 0s and <code>n</code> 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as <code>i</code> and <code>j</code> means how many 1s and 0s of the current num.</p>\n<p>What we should do next is to find the <code>m to x</code> and <code>n to y</code> to make sure we consider every conditions.</p>\n<p>So, the solution is coming:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;</div><div class=\"line\">            int DP[600][600];</div><div class=\"line\">            for (int i = 0; i &lt; 600; i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; 600; j++) &#123;</div><div class=\"line\">                    DP[i][j] = 0;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int num0 = 0;</div><div class=\"line\">                int num1 = 0;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    if (strs[i][j] == &apos;0&apos;) &#123;</div><div class=\"line\">                        num0++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        num1++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                for (int i = m; i &gt;= num0; i--) &#123;</div><div class=\"line\">                    for (int j = n; j &gt;= num1; j--) &#123;</div><div class=\"line\">                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[m][n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n","excerpt":"<blockquote>\n<p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.</p>\n<p>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.</p>\n<p>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.</p>\n<p>Note:</p>\n<ul>\n<li>The given numbers of 0s and 1s will both not exceed 100</li>\n<li>The size of given string array wont exceed 600.</li>\n</ul>\n<p>Example 1:</p>\n<ul>\n<li>Input: Array = {10, 0001, 111001, 1, 0}, m = 5, n = 3;</li>\n<li>Output: 4</li>\n</ul>\n<p>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are 10,0001,1,0</p>\n<p>Example 2:</p>\n<ul>\n<li>Input: Array = {10, 0, 1}, m = 1, n = 1</li>\n<li>Output: 2</li>\n</ul>\n<p>Explanation: You could form 10, but then youd have nothing left. Better form 0 and 1.</p>\n</blockquote>","more":"<p>This is Leetcode 474. As a noraml DP problem, the most important thing is to find the relationship.</p>\n<p>In this case, we can find the relationship:</p>\n<p>we can use <code>m</code> 0s and <code>n</code> 1s to make the max(DP[x][y], DP[x-i][y-j] + 1) as <code>i</code> and <code>j</code> means how many 1s and 0s of the current num.</p>\n<p>What we should do next is to find the <code>m to x</code> and <code>n to y</code> to make sure we consider every conditions.</p>\n<p>So, the solution is coming:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123;</div><div class=\"line\">            int DP[600][600];</div><div class=\"line\">            for (int i = 0; i &lt; 600; i++) &#123;</div><div class=\"line\">                for (int j = 0; j &lt; 600; j++) &#123;</div><div class=\"line\">                    DP[i][j] = 0;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)strs.size(); i++) &#123;</div><div class=\"line\">                int num0 = 0;</div><div class=\"line\">                int num1 = 0;</div><div class=\"line\">                for (int j = 0; j &lt; (int)strs[i].length(); j++) &#123;</div><div class=\"line\">                    if (strs[i][j] == &apos;0&apos;) &#123;</div><div class=\"line\">                        num0++;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        num1++;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                for (int i = m; i &gt;= num0; i--) &#123;</div><div class=\"line\">                    for (int j = n; j &gt;= num1; j--) &#123;</div><div class=\"line\">                        DP[i][j] = max(DP[i][j], DP[i-num0][j-num1] + 1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[m][n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"Partition Equal Subset Sum","date":"2017-01-06T05:46:25.000Z","_content":"\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","source":"_posts/PartitionEqualSubsetSum.md","raw":"---\ntitle: Partition Equal Subset Sum\ndate: 2017-01-06 13:46:25\ntags:\n    - Dynamic Programming\n---\n\n> Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n>\n> Note:\n>\n> + Each of the array element will not exceed 100.\n> + The array size will not exceed 200.\n>\n> Example 1:\n>\n> Input: [1, 5, 11, 5]\n> Output: true\n>\n> Explanation: The array can be partitioned as [1, 5, 5] and [11].\n>\n> Example 2:\n>\n> Input: [1, 2, 3, 5]\n> Output: false\n>\n> Explanation: The array cannot be partitioned into equal sum subsets.\n\n<!-- more -->\n\nThis is Leetcode 416, and it is a leetweek problem. My last pass code like these:\n```\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            if (nums.size() < 2) {\n                return false;\n            }\n            int sum = 0;\n            for (int i = 0; i < (int)nums.size(); i++) {\n                sum = sum + nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            return check(0, 0, nums, sum);\n        }\n\n        bool check(int start, int current, vector<int> nums, int sum) {\n            bool res = false;\n            if (current > sum / 2) {\n                return false;\n            }\n            if (current == sum / 2) {\n                return true;\n            }\n            for (int i = start + 1; i < (int)nums.size(); i++) {\n                res = res || check(i, current + nums[i], nums, sum);\n            }\n            return res;\n        }\n};\n```\nBecause the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.\n\nFind a set of the subarray which its sum is sum / 2. And we can use the DP solution.\n\nBecause we know the sum of the array, so we make a array **dp** in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:\n```\nfor (auto num : nums) {\n    for(int i = target; i >= num; i--) { // to be quick we don't visit the whole dp array\n        dp[i] = dp[i] || dp[i - num];\n    }\n}\n```\n\nSo, here comes a better solution based on DP:\n\n```\nusing namespace std;\nclass Solution {\n    public:\n        bool canPartition(vector<int>& nums) {\n            int sum = accumulate(nums.begin(), nums.end(), 0);\n            if (sum & 1) return false;\n            int half = sum >> 1;\n\n            vector<bool> accessibility(half + 1, false);\n            accessibility[0] = true;    // '0' is always reachable\n            //For all num in nums, check the accessibility from half - num to 0.\n            //If 'i' is accessible by former numbers, then 'i + num' is also accessible. (DP Algorithm)\n            for(int num: nums)\n                //Below here we must start from 'half' downto 'num', otherwise current 'num' might be multiply used.\n                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.\n                for(int i = half; i >= num; i--){\n                    if (accessibility[i - num] == true){\n                        accessibility[i] = true;\n                    }\n                }\n            return accessibility[half];\n        }\n};\n```\n\nHowever it's space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.\n\n```\nbool canPartition(vector<int>& nums) {\n    bitset<5001> bits(1);\n    int sum = accumulate(nums.begin(), nums.end(), 0);\n    for (auto n : nums) bits |= bits << n;\n    return !(sum & 1) && bits[sum >> 1];\n}\n```\nWhy and how it works, remaining unknown.\n","slug":"PartitionEqualSubsetSum","published":1,"updated":"2017-01-13T03:10:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatx8003rg5f4ec8zm9q3","content":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]<br>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]<br>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However its space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>\n","excerpt":"<blockquote>\n<p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>\n<p>Note:</p>\n<ul>\n<li>Each of the array element will not exceed 100.</li>\n<li>The array size will not exceed 200.</li>\n</ul>\n<p>Example 1:</p>\n<p>Input: [1, 5, 11, 5]<br>Output: true</p>\n<p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>\n<p>Example 2:</p>\n<p>Input: [1, 2, 3, 5]<br>Output: false</p>\n<p>Explanation: The array cannot be partitioned into equal sum subsets.</p>\n</blockquote>","more":"<p>This is Leetcode 416, and it is a leetweek problem. My last pass code like these:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() &lt; 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int sum = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                sum = sum + nums[i];</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (sum % 2 != 0) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return check(0, 0, nums, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool check(int start, int current, vector&lt;int&gt; nums, int sum) &#123;</div><div class=\"line\">            bool res = false;</div><div class=\"line\">            if (current &gt; sum / 2) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (current == sum / 2) &#123;</div><div class=\"line\">                return true;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = start + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res = res || check(i, current + nums[i], nums, sum);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>Because the time complex of this recursive functoin is O(n!), the worst condition. So, we can change our mind to turn this problem into another one.</p>\n<p>Find a set of the subarray which its sum is sum / 2. And we can use the DP solution.</p>\n<p>Because we know the sum of the array, so we make a array <strong>dp</strong> in size sum/2. And after a for loop. we will know the dp[num] and dp[sum/2 - num] can achieve. So, when we for twice, like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (auto num : nums) &#123;</div><div class=\"line\">    for(int i = target; i &gt;= num; i--) &#123; // to be quick we don&apos;t visit the whole dp array</div><div class=\"line\">        dp[i] = dp[i] || dp[i - num];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>So, here comes a better solution based on DP:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">            if (sum &amp; 1) return false;</div><div class=\"line\">            int half = sum &gt;&gt; 1;</div><div class=\"line\"></div><div class=\"line\">            vector&lt;bool&gt; accessibility(half + 1, false);</div><div class=\"line\">            accessibility[0] = true;    // &apos;0&apos; is always reachable</div><div class=\"line\">            //For all num in nums, check the accessibility from half - num to 0.</div><div class=\"line\">            //If &apos;i&apos; is accessible by former numbers, then &apos;i + num&apos; is also accessible. (DP Algorithm)</div><div class=\"line\">            for(int num: nums)</div><div class=\"line\">                //Below here we must start from &apos;half&apos; downto &apos;num&apos;, otherwise current &apos;num&apos; might be multiply used.</div><div class=\"line\">                //e.g.: If num == 2, then we will have 2, 4, 6... will all be accessible and lead to wrong answer.</div><div class=\"line\">                for(int i = half; i &gt;= num; i--)&#123;</div><div class=\"line\">                    if (accessibility[i - num] == true)&#123;</div><div class=\"line\">                        accessibility[i] = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            return accessibility[half];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>However its space complex is O(n), so if you need a O(1) solution, I find a cool solution based on bitset.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    bitset&lt;5001&gt; bits(1);</div><div class=\"line\">    int sum = accumulate(nums.begin(), nums.end(), 0);</div><div class=\"line\">    for (auto n : nums) bits |= bits &lt;&lt; n;</div><div class=\"line\">    return !(sum &amp; 1) &amp;&amp; bits[sum &gt;&gt; 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Why and how it works, remaining unknown.</p>"},{"title":"Path Sum III","date":"2017-01-07T11:46:25.000Z","_content":"\n> You are given a binary tree in which each node contains an integer value.\n>\n> Find the number of paths that sum to a given value.\n>\n> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n>\n> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n>\n> Example:\n>\n> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n> ```\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n```\n> Return 3. The paths that sum to 8 are:\n>\n> 1.  5 -> 3\n> 2.  5 -> 2 -> 1\n> 3. -3 -> 11\n\n<!-- more -->\n\n\nThis is Leetcode 437, easy problem, and it's solution as following:\n\n```\nclass Solution {\n    public:\n        int pathSum(TreeNode* root, int sum) {\n            if(root == NULL)\n                return 0;\n            return visit(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n        }\n\n        int visit(TreeNode* node, int sum) {\n            int res = 0;\n            if(node == NULL)\n                return res;\n            if(sum == node->val)\n                res++;\n            res += visit(node->left, sum - node->val);\n            res += visit(node->right, sum - node->val);\n            return res;\n        }\n};\n```\n\nIt's time complex is O(nlogn) if it's a balanced tree while O(n^2) in the worst case.\n\nThe better solution is the DP solution using a map to store all the value of the tree node.\n\n```\nclass Solution {\n    public:\n        int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\n            if (!root) return 0;\n            root->val += pre;\n            int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\n            store[root->val]++;\n            res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\n            store[root->val]--;\n            return res;\n        }\n\n        int pathSum(TreeNode* root, int sum) {\n            unordered_map<int, int> store;\n            return help(root, sum, store, 0);\n        }\n};\n```\n\nThat's it.\n","source":"_posts/PathSumIII.md","raw":"---\ntitle: Path Sum III\ndate: 2017-01-07 19:46:25\ntags:\n    - Tree\n---\n\n> You are given a binary tree in which each node contains an integer value.\n>\n> Find the number of paths that sum to a given value.\n>\n> The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).\n>\n> The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\n>\n> Example:\n>\n> root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n> ```\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n```\n> Return 3. The paths that sum to 8 are:\n>\n> 1.  5 -> 3\n> 2.  5 -> 2 -> 1\n> 3. -3 -> 11\n\n<!-- more -->\n\n\nThis is Leetcode 437, easy problem, and it's solution as following:\n\n```\nclass Solution {\n    public:\n        int pathSum(TreeNode* root, int sum) {\n            if(root == NULL)\n                return 0;\n            return visit(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum);\n        }\n\n        int visit(TreeNode* node, int sum) {\n            int res = 0;\n            if(node == NULL)\n                return res;\n            if(sum == node->val)\n                res++;\n            res += visit(node->left, sum - node->val);\n            res += visit(node->right, sum - node->val);\n            return res;\n        }\n};\n```\n\nIt's time complex is O(nlogn) if it's a balanced tree while O(n^2) in the worst case.\n\nThe better solution is the DP solution using a map to store all the value of the tree node.\n\n```\nclass Solution {\n    public:\n        int help(TreeNode* root, int sum, unordered_map<int, int>& store, int pre) {\n            if (!root) return 0;\n            root->val += pre;\n            int res = (root->val == sum) + (store.count(root->val - sum) ? store[root->val - sum] : 0);\n            store[root->val]++;\n            res += help(root->left, sum, store, root->val) + help(root->right, sum, store, root->val);\n            store[root->val]--;\n            return res;\n        }\n\n        int pathSum(TreeNode* root, int sum) {\n            unordered_map<int, int> store;\n            return help(root, sum, store, 0);\n        }\n};\n```\n\nThat's it.\n","slug":"PathSumIII","published":1,"updated":"2017-02-14T07:07:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxa003ug5f42sz7zo48","content":"<blockquote>\n<p>You are given a binary tree in which each node contains an integer value.</p>\n<p>Find the number of paths that sum to a given value.</p>\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>\n<p>Example:</p>\n<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">      10</div><div class=\"line\">     /  \\</div><div class=\"line\">    5   -3</div><div class=\"line\">   / \\    \\</div><div class=\"line\">  3   2   11</div><div class=\"line\"> / \\   \\</div><div class=\"line\">3  -2   1</div></pre></td></tr></table></figure></p>\n<p>Return 3. The paths that sum to 8 are:</p>\n<ol>\n<li>5 -&gt; 3</li>\n<li>5 -&gt; 2 -&gt; 1</li>\n<li>-3 -&gt; 11</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 437, easy problem, and its solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            if(root == NULL)</div><div class=\"line\">                return 0;</div><div class=\"line\">            return visit(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int visit(TreeNode* node, int sum) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            if(node == NULL)</div><div class=\"line\">                return res;</div><div class=\"line\">            if(sum == node-&gt;val)</div><div class=\"line\">                res++;</div><div class=\"line\">            res += visit(node-&gt;left, sum - node-&gt;val);</div><div class=\"line\">            res += visit(node-&gt;right, sum - node-&gt;val);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(nlogn) if its a balanced tree while O(n^2) in the worst case.</p>\n<p>The better solution is the DP solution using a map to store all the value of the tree node.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123;</div><div class=\"line\">            if (!root) return 0;</div><div class=\"line\">            root-&gt;val += pre;</div><div class=\"line\">            int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0);</div><div class=\"line\">            store[root-&gt;val]++;</div><div class=\"line\">            res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val);</div><div class=\"line\">            store[root-&gt;val]--;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            unordered_map&lt;int, int&gt; store;</div><div class=\"line\">            return help(root, sum, store, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Thats it.</p>\n","excerpt":"<blockquote>\n<p>You are given a binary tree in which each node contains an integer value.</p>\n<p>Find the number of paths that sum to a given value.</p>\n<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>\n<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>\n<p>Example:</p>\n<p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">      10</div><div class=\"line\">     /  \\</div><div class=\"line\">    5   -3</div><div class=\"line\">   / \\    \\</div><div class=\"line\">  3   2   11</div><div class=\"line\"> / \\   \\</div><div class=\"line\">3  -2   1</div></pre></td></tr></table></figure></p>\n<p>Return 3. The paths that sum to 8 are:</p>\n<ol>\n<li>5 -&gt; 3</li>\n<li>5 -&gt; 2 -&gt; 1</li>\n<li>-3 -&gt; 11</li>\n</ol>\n</blockquote>","more":"<p>This is Leetcode 437, easy problem, and its solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            if(root == NULL)</div><div class=\"line\">                return 0;</div><div class=\"line\">            return visit(root, sum) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int visit(TreeNode* node, int sum) &#123;</div><div class=\"line\">            int res = 0;</div><div class=\"line\">            if(node == NULL)</div><div class=\"line\">                return res;</div><div class=\"line\">            if(sum == node-&gt;val)</div><div class=\"line\">                res++;</div><div class=\"line\">            res += visit(node-&gt;left, sum - node-&gt;val);</div><div class=\"line\">            res += visit(node-&gt;right, sum - node-&gt;val);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Its time complex is O(nlogn) if its a balanced tree while O(n^2) in the worst case.</p>\n<p>The better solution is the DP solution using a map to store all the value of the tree node.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int help(TreeNode* root, int sum, unordered_map&lt;int, int&gt;&amp; store, int pre) &#123;</div><div class=\"line\">            if (!root) return 0;</div><div class=\"line\">            root-&gt;val += pre;</div><div class=\"line\">            int res = (root-&gt;val == sum) + (store.count(root-&gt;val - sum) ? store[root-&gt;val - sum] : 0);</div><div class=\"line\">            store[root-&gt;val]++;</div><div class=\"line\">            res += help(root-&gt;left, sum, store, root-&gt;val) + help(root-&gt;right, sum, store, root-&gt;val);</div><div class=\"line\">            store[root-&gt;val]--;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int pathSum(TreeNode* root, int sum) &#123;</div><div class=\"line\">            unordered_map&lt;int, int&gt; store;</div><div class=\"line\">            return help(root, sum, store, 0);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Thats it.</p>"},{"title":"Next Greater Element II","date":"2017-02-27T06:15:55.000Z","_content":"\n> Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n>\n> Example 1:\n>\n> + Input: [1,2,1]\n> + Output: [2,-1,2]\n> + Explanation:\n>   - The first 1's next greater number is 2;\n>   - The number 2 can't find next greater number;\n>   - The second 1's next greater number needs to search circularly, which is also 2.\n>\n> Note: The length of given array won't exceed 10000.\n\n<!--more-->\n\nThis is Leetcode No.503, it seems like its brother problem \"Next Greater Element I\". The different thing is that if you can't find the greater elment at the end of the array, you should start from the beginning.\n\nSo, I can quickly find the solution as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<int> nextGreaterElements(vector<int>& nums) {\n            vector<int> res;\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res.push_back(findNextGreaterElement(i, nums));\n            }\n\n            return res;\n        }\n\n        int findNextGreaterElement(int idx, vector<int> nums) {\n            for (int i = idx + 1; i < (int)nums.size(); i++) {\n                if (nums[i] > nums[idx]) {\n                    return nums[i];\n                }\n            }\n\n            for (int i = 0; i < idx; i++) {\n                if (nums[i] > nums[idx]) {\n                    return nums[i];\n                }\n            }\n\n            return -1;\n        }\n};\n```\n\nIt obsolutly gets a AC... I thought it will be a TLE...\n","source":"_posts/NextGreaterElementII.md","raw":"---\ntitle: Next Greater Element II\ndate: 2017-02-27 14:15:55\ntags:\n    - Stack\n---\n\n> Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n>\n> Example 1:\n>\n> + Input: [1,2,1]\n> + Output: [2,-1,2]\n> + Explanation:\n>   - The first 1's next greater number is 2;\n>   - The number 2 can't find next greater number;\n>   - The second 1's next greater number needs to search circularly, which is also 2.\n>\n> Note: The length of given array won't exceed 10000.\n\n<!--more-->\n\nThis is Leetcode No.503, it seems like its brother problem \"Next Greater Element I\". The different thing is that if you can't find the greater elment at the end of the array, you should start from the beginning.\n\nSo, I can quickly find the solution as following:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        vector<int> nextGreaterElements(vector<int>& nums) {\n            vector<int> res;\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                res.push_back(findNextGreaterElement(i, nums));\n            }\n\n            return res;\n        }\n\n        int findNextGreaterElement(int idx, vector<int> nums) {\n            for (int i = idx + 1; i < (int)nums.size(); i++) {\n                if (nums[i] > nums[idx]) {\n                    return nums[i];\n                }\n            }\n\n            for (int i = 0; i < idx; i++) {\n                if (nums[i] > nums[idx]) {\n                    return nums[i];\n                }\n            }\n\n            return -1;\n        }\n};\n```\n\nIt obsolutly gets a AC... I thought it will be a TLE...\n","slug":"NextGreaterElementII","published":1,"updated":"2017-02-27T06:55:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxb003wg5f402bhjvbu","content":"<blockquote>\n<p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesnt exist, output -1 for this number.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,2,1]</li>\n<li>Output: [2,-1,2]</li>\n<li>Explanation:<ul>\n<li>The first 1s next greater number is 2;</li>\n<li>The number 2 cant find next greater number;</li>\n<li>The second 1s next greater number needs to search circularly, which is also 2.</li>\n</ul>\n</li>\n</ul>\n<p>Note: The length of given array wont exceed 10000.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.503, it seems like its brother problem Next Greater Element I. The different thing is that if you cant find the greater elment at the end of the array, you should start from the beginning.</p>\n<p>So, I can quickly find the solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res.push_back(findNextGreaterElement(i, nums));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int findNextGreaterElement(int idx, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            for (int i = idx + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] &gt; nums[idx]) &#123;</div><div class=\"line\">                    return nums[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; idx; i++) &#123;</div><div class=\"line\">                if (nums[i] &gt; nums[idx]) &#123;</div><div class=\"line\">                    return nums[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It obsolutly gets a AC I thought it will be a TLE</p>\n","excerpt":"<blockquote>\n<p>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesnt exist, output -1 for this number.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,2,1]</li>\n<li>Output: [2,-1,2]</li>\n<li>Explanation:<ul>\n<li>The first 1s next greater number is 2;</li>\n<li>The number 2 cant find next greater number;</li>\n<li>The second 1s next greater number needs to search circularly, which is also 2.</li>\n</ul>\n</li>\n</ul>\n<p>Note: The length of given array wont exceed 10000.</p>\n</blockquote>","more":"<p>This is Leetcode No.503, it seems like its brother problem Next Greater Element I. The different thing is that if you cant find the greater elment at the end of the array, you should start from the beginning.</p>\n<p>So, I can quickly find the solution as following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; res;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                res.push_back(findNextGreaterElement(i, nums));</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        int findNextGreaterElement(int idx, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            for (int i = idx + 1; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (nums[i] &gt; nums[idx]) &#123;</div><div class=\"line\">                    return nums[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; idx; i++) &#123;</div><div class=\"line\">                if (nums[i] &gt; nums[idx]) &#123;</div><div class=\"line\">                    return nums[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It obsolutly gets a AC I thought it will be a TLE</p>"},{"title":"Perfect Squares","date":"2017-01-16T07:31:29.000Z","_content":"\n>  Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n>\n>  For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\n<!--more-->\n\nIt is Leetcode 279 and a quite easy DP problem.\n\nI used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,\n\nI will find 2(1+1), 5(1+4), 10(1+9)... are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.\n\nHowever, this solution gets a TLE. And, I just find another way to solve:\n\n```\nclass Solution {\n    public:\n        int numSquares(int n) {\n            vector<long> DP(n + 1, INT_MAX);\n            DP[0] = 0;\n            for (int i = 0; i <= n; i++) {\n                for (int idx = 0; idx <= (int)sqrt(i); idx++) {\n                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);\n                }\n            }\n            return DP[n];\n        }\n};\n```\n\nMuch easier than the former one. And it gets AC.\n","source":"_posts/PerfectSquares.md","raw":"---\ntitle: Perfect Squares\ndate: 2017-01-16 15:31:29\ntags:\n    - Dynamic Programming\n    - Math\n    - Breadth-first Search\n---\n\n>  Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n>\n>  For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.\n\n<!--more-->\n\nIt is Leetcode 279 and a quite easy DP problem.\n\nI used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,\n\nI will find 2(1+1), 5(1+4), 10(1+9)... are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.\n\nHowever, this solution gets a TLE. And, I just find another way to solve:\n\n```\nclass Solution {\n    public:\n        int numSquares(int n) {\n            vector<long> DP(n + 1, INT_MAX);\n            DP[0] = 0;\n            for (int i = 0; i <= n; i++) {\n                for (int idx = 0; idx <= (int)sqrt(i); idx++) {\n                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);\n                }\n            }\n            return DP[n];\n        }\n};\n```\n\nMuch easier than the former one. And it gets AC.\n","slug":"PerfectSquares","published":1,"updated":"2017-01-16T08:11:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxd003zg5f4fywu8z6v","content":"<blockquote>\n<p> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ) which sum to n.</p>\n<p> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is Leetcode 279 and a quite easy DP problem.</p>\n<p>I used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,</p>\n<p>I will find 2(1+1), 5(1+4), 10(1+9) are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.</p>\n<p>However, this solution gets a TLE. And, I just find another way to solve:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int numSquares(int n) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(n + 1, INT_MAX);</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int i = 0; i &lt;= n; i++) &#123;</div><div class=\"line\">                for (int idx = 0; idx &lt;= (int)sqrt(i); idx++) &#123;</div><div class=\"line\">                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Much easier than the former one. And it gets AC.</p>\n","excerpt":"<blockquote>\n<p> Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ) which sum to n.</p>\n<p> For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>\n</blockquote>","more":"<p>It is Leetcode 279 and a quite easy DP problem.</p>\n<p>I used to find a hard way, for example, 1 4 9 16 25 are square numbers, and I use it as a seed to find the second level numbers. Use 1 as a example,</p>\n<p>I will find 2(1+1), 5(1+4), 10(1+9) are level 2 square numbers, and so on. I will find level N. Once if find the target number, return the level number, and the problem is done.</p>\n<p>However, this solution gets a TLE. And, I just find another way to solve:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int numSquares(int n) &#123;</div><div class=\"line\">            vector&lt;long&gt; DP(n + 1, INT_MAX);</div><div class=\"line\">            DP[0] = 0;</div><div class=\"line\">            for (int i = 0; i &lt;= n; i++) &#123;</div><div class=\"line\">                for (int idx = 0; idx &lt;= (int)sqrt(i); idx++) &#123;</div><div class=\"line\">                    DP[i] = min(1 + DP[i - idx*idx], DP[i]);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return DP[n];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Much easier than the former one. And it gets AC.</p>"},{"title":"Predict the Winner","date":"2017-02-03T11:48:26.000Z","_content":"\n> Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.\n>\n> Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.\n>\n> Example 1:\n> + Input: [1, 5, 2]\n> + Output: False\n> + Explanation:\n>   + Initially, player 1 can choose between 1 and 2.\n>   + If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.\n>   + Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.\n>   + Hence, player 1 will never be the winner and you need to return False.\n>\n> Example 2:\n> + Input: [1, 5, 233, 7]\n> + Output: True\n> + Explanation:\n>   + Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.\n>   + No matter which number player 2 choose, player 1 can choose 233.\n>   + Finally, player 1 has more score (234) than player 2 (12).\n>   + So you need to return True representing player1 can win.\n>\n> Note:\n> + 1 <= length of the array <= 20.\n> + Any scores in the given array are non-negative integers and will not exceed 10,000,000.\n> + If the scores of both players are equal, then player 1 is still the winner.\n\n<!--more-->\n\nThis is Leetcode 486, and its No. is like the comic(\"[Re:](http://www.imdb.com/title/tt5607616/)\") male role called \"Subaru Natsuki\".\n\nIt is actually an interesting problem. You can find its solution is like \"Tower of Hanoi\", you need to find the conditions needed by player 1 to win.\n\nSo, here is his conditions, if his turn, he just need one choice to win, for the other's turn, he need both choice to win.\n\nHere is the condition section of code:\n\n```\nbool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n    if (endIdx == startIdx) {\n        if (isA) {\n            return currentA + nums[startIdx] >= currentB;\n        } else {\n            return currentA >= currentB + nums[startIdx];\n        }\n    } else {\n        if (isA) {\n            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n        } else {\n            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n        }\n    }\n}\n```\n\nAnd my solution is:\n\n```\nclass Solution {\n    public:\n        bool PredictTheWinner(vector<int>& nums) {\n            return _calc(0, nums.size() - 1, true, 0, 0, nums);\n        }\n\n        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n            if (endIdx == startIdx) {\n                if (isA) {\n                    return currentA + nums[startIdx] >= currentB;\n                } else {\n                    return currentA >= currentB + nums[startIdx];\n                }\n            } else {\n                if (isA) {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n                } else {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                        && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/PredicttheWinner.md","raw":"---\ntitle: Predict the Winner\ndate: 2017-02-03 19:48:26\ntags:\n    - Dynamic Programming\n    - Minimax\n---\n\n> Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.\n>\n> Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.\n>\n> Example 1:\n> + Input: [1, 5, 2]\n> + Output: False\n> + Explanation:\n>   + Initially, player 1 can choose between 1 and 2.\n>   + If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.\n>   + Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.\n>   + Hence, player 1 will never be the winner and you need to return False.\n>\n> Example 2:\n> + Input: [1, 5, 233, 7]\n> + Output: True\n> + Explanation:\n>   + Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.\n>   + No matter which number player 2 choose, player 1 can choose 233.\n>   + Finally, player 1 has more score (234) than player 2 (12).\n>   + So you need to return True representing player1 can win.\n>\n> Note:\n> + 1 <= length of the array <= 20.\n> + Any scores in the given array are non-negative integers and will not exceed 10,000,000.\n> + If the scores of both players are equal, then player 1 is still the winner.\n\n<!--more-->\n\nThis is Leetcode 486, and its No. is like the comic(\"[Re:](http://www.imdb.com/title/tt5607616/)\") male role called \"Subaru Natsuki\".\n\nIt is actually an interesting problem. You can find its solution is like \"Tower of Hanoi\", you need to find the conditions needed by player 1 to win.\n\nSo, here is his conditions, if his turn, he just need one choice to win, for the other's turn, he need both choice to win.\n\nHere is the condition section of code:\n\n```\nbool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n    if (endIdx == startIdx) {\n        if (isA) {\n            return currentA + nums[startIdx] >= currentB;\n        } else {\n            return currentA >= currentB + nums[startIdx];\n        }\n    } else {\n        if (isA) {\n            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n        } else {\n            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n        }\n    }\n}\n```\n\nAnd my solution is:\n\n```\nclass Solution {\n    public:\n        bool PredictTheWinner(vector<int>& nums) {\n            return _calc(0, nums.size() - 1, true, 0, 0, nums);\n        }\n\n        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector<int> nums) {\n            if (endIdx == startIdx) {\n                if (isA) {\n                    return currentA + nums[startIdx] >= currentB;\n                } else {\n                    return currentA >= currentB + nums[startIdx];\n                }\n            } else {\n                if (isA) {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)\n                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);\n                } else {\n                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)\n                        && _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);\n                }\n            }\n        }\n};\n```\n\nIt gets AC.\n","slug":"PredicttheWinner","published":1,"updated":"2017-02-04T07:50:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxf0041g5f4q35an8et","content":"<blockquote>\n<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>\n<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1, 5, 2]</li>\n<li>Output: False</li>\n<li>Explanation:<ul>\n<li>Initially, player 1 can choose between 1 and 2.</li>\n<li>If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.</li>\n<li>Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.</li>\n<li>Hence, player 1 will never be the winner and you need to return False.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1, 5, 233, 7]</li>\n<li>Output: True</li>\n<li>Explanation:<ul>\n<li>Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.</li>\n<li>No matter which number player 2 choose, player 1 can choose 233.</li>\n<li>Finally, player 1 has more score (234) than player 2 (12).</li>\n<li>So you need to return True representing player1 can win.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>1 &lt;= length of the array &lt;= 20.</li>\n<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>\n<li>If the scores of both players are equal, then player 1 is still the winner.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 486, and its No. is like the comic(<a href=\"http://www.imdb.com/title/tt5607616/\" target=\"_blank\" rel=\"external\">Re:</a>) male role called Subaru Natsuki.</p>\n<p>It is actually an interesting problem. You can find its solution is like Tower of Hanoi, you need to find the conditions needed by player 1 to win.</p>\n<p>So, here is his conditions, if his turn, he just need one choice to win, for the others turn, he need both choice to win.</p>\n<p>Here is the condition section of code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">    if (endIdx == startIdx) &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And my solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            return _calc(0, nums.size() - 1, true, 0, 0, nums);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            if (endIdx == startIdx) &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                        &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p>\n<p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1, 5, 2]</li>\n<li>Output: False</li>\n<li>Explanation:<ul>\n<li>Initially, player 1 can choose between 1 and 2.</li>\n<li>If he chooses 2 (or 1). Then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5.</li>\n<li>Then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.</li>\n<li>Hence, player 1 will never be the winner and you need to return False.</li>\n</ul>\n</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1, 5, 233, 7]</li>\n<li>Output: True</li>\n<li>Explanation:<ul>\n<li>Player 1 first chooses 1. Then player 2 have to choose between 5 and 7.</li>\n<li>No matter which number player 2 choose, player 1 can choose 233.</li>\n<li>Finally, player 1 has more score (234) than player 2 (12).</li>\n<li>So you need to return True representing player1 can win.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>1 &lt;= length of the array &lt;= 20.</li>\n<li>Any scores in the given array are non-negative integers and will not exceed 10,000,000.</li>\n<li>If the scores of both players are equal, then player 1 is still the winner.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 486, and its No. is like the comic(<a href=\"http://www.imdb.com/title/tt5607616/\">Re:</a>) male role called Subaru Natsuki.</p>\n<p>It is actually an interesting problem. You can find its solution is like Tower of Hanoi, you need to find the conditions needed by player 1 to win.</p>\n<p>So, here is his conditions, if his turn, he just need one choice to win, for the others turn, he need both choice to win.</p>\n<p>Here is the condition section of code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">    if (endIdx == startIdx) &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        if (isA) &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And my solution is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            return _calc(0, nums.size() - 1, true, 0, 0, nums);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        bool _calc(int startIdx, int endIdx, bool isA, int currentA, int currentB, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            if (endIdx == startIdx) &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return currentA + nums[startIdx] &gt;= currentB;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return currentA &gt;= currentB + nums[startIdx];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                if (isA) &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA + nums[startIdx], currentB, nums)</div><div class=\"line\">                        || _calc(startIdx, endIdx - 1, !isA, currentA + nums[endIdx], currentB, nums);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    return _calc(startIdx + 1, endIdx, !isA, currentA, currentB + nums[startIdx], nums)</div><div class=\"line\">                        &amp;&amp; _calc(startIdx, endIdx - 1, !isA, currentA, currentB + nums[endIdx], nums);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Permutations","date":"2017-02-13T02:00:16.000Z","_content":"\n> Given a collection of distinct numbers, return all possible permutations.\n>\n> For example:\n>\n> [1,2,3] have the following permutations:\n> ```\n[\n    [1,2,3],\n    [1,3,2],\n    [2,1,3],\n    [2,3,1],\n    [3,1,2],\n    [3,2,1]\n]\n```\n\n<!--more-->\n\nIt is leetcode No.46, and it is a simple backtracking problem.\n\nYou can just do such a tail reversation to solve the problem.\n\n```\nclass Solution {\n    public:\n        set<int> visited;\n        vector<vector<int> > res;\n        vector<vector<int> > permute(vector<int>& nums) {\n            vector<int> current;\n            backTrace(current, nums);\n            return res;\n        }\n\n        void backTrace(vector<int> current, vector<int> nums) {\n            if (current.size() == nums.size()) {\n                res.push_back(current);\n            }\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (visited.find(nums[i]) == visited.end()) {\n                    current.push_back(nums[i]);\n                    visited.insert(nums[i]);\n                    backTrace(current, nums);\n                    visited.erase(nums[i]);\n                    current.pop_back();\n                }\n            }\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/Permutations.md","raw":"---\ntitle: Permutations\ndate: 2017-02-13 10:00:16\ntags:\n    - Backtracking\n---\n\n> Given a collection of distinct numbers, return all possible permutations.\n>\n> For example:\n>\n> [1,2,3] have the following permutations:\n> ```\n[\n    [1,2,3],\n    [1,3,2],\n    [2,1,3],\n    [2,3,1],\n    [3,1,2],\n    [3,2,1]\n]\n```\n\n<!--more-->\n\nIt is leetcode No.46, and it is a simple backtracking problem.\n\nYou can just do such a tail reversation to solve the problem.\n\n```\nclass Solution {\n    public:\n        set<int> visited;\n        vector<vector<int> > res;\n        vector<vector<int> > permute(vector<int>& nums) {\n            vector<int> current;\n            backTrace(current, nums);\n            return res;\n        }\n\n        void backTrace(vector<int> current, vector<int> nums) {\n            if (current.size() == nums.size()) {\n                res.push_back(current);\n            }\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (visited.find(nums[i]) == visited.end()) {\n                    current.push_back(nums[i]);\n                    visited.insert(nums[i]);\n                    backTrace(current, nums);\n                    visited.erase(nums[i]);\n                    current.pop_back();\n                }\n            }\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"Permutations","published":1,"updated":"2017-02-14T07:08:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxh0044g5f4gbh7493w","content":"<blockquote>\n<p>Given a collection of distinct numbers, return all possible permutations.</p>\n<p>For example:</p>\n<p>[1,2,3] have the following permutations:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [1,2,3],</div><div class=\"line\">    [1,3,2],</div><div class=\"line\">    [2,1,3],</div><div class=\"line\">    [2,3,1],</div><div class=\"line\">    [3,1,2],</div><div class=\"line\">    [3,2,1]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>It is leetcode No.46, and it is a simple backtracking problem.</p>\n<p>You can just do such a tail reversation to solve the problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        set&lt;int&gt; visited;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; current;</div><div class=\"line\">            backTrace(current, nums);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void backTrace(vector&lt;int&gt; current, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            if (current.size() == nums.size()) &#123;</div><div class=\"line\">                res.push_back(current);</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (visited.find(nums[i]) == visited.end()) &#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    visited.insert(nums[i]);</div><div class=\"line\">                    backTrace(current, nums);</div><div class=\"line\">                    visited.erase(nums[i]);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a collection of distinct numbers, return all possible permutations.</p>\n<p>For example:</p>\n<p>[1,2,3] have the following permutations:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">[</div><div class=\"line\">    [1,2,3],</div><div class=\"line\">    [1,3,2],</div><div class=\"line\">    [2,1,3],</div><div class=\"line\">    [2,3,1],</div><div class=\"line\">    [3,1,2],</div><div class=\"line\">    [3,2,1]</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n</blockquote>","more":"<p>It is leetcode No.46, and it is a simple backtracking problem.</p>\n<p>You can just do such a tail reversation to solve the problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        set&lt;int&gt; visited;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; res;</div><div class=\"line\">        vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;int&gt; current;</div><div class=\"line\">            backTrace(current, nums);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void backTrace(vector&lt;int&gt; current, vector&lt;int&gt; nums) &#123;</div><div class=\"line\">            if (current.size() == nums.size()) &#123;</div><div class=\"line\">                res.push_back(current);</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (visited.find(nums[i]) == visited.end()) &#123;</div><div class=\"line\">                    current.push_back(nums[i]);</div><div class=\"line\">                    visited.insert(nums[i]);</div><div class=\"line\">                    backTrace(current, nums);</div><div class=\"line\">                    visited.erase(nums[i]);</div><div class=\"line\">                    current.pop_back();</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Ransom Note","date":"2017-01-12T15:45:36.000Z","_content":"\n> Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n>\n> Each letter in the magazine string can only be used once in your ransom note.\n>\n> Note:\n> You may assume that both strings contain only lowercase letters.\n>\n> canConstruct(\"a\", \"b\") -> false\n> canConstruct(\"aa\", \"ab\") -> false\n> canConstruct(\"aa\", \"aab\") -> true\n\n<!--more-->\n\nThis is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.\n\n\n```\nclass Solution {\n    public:\n        bool canConstruct(string ransomNote, string magazine) {\n            int chars[512] = {0};\n            for (int i = 0; i < (int)magazine.size(); i++) {\n                chars[(int)magazine[i]]++;\n            }\n            for (int i = 0; i < (int)ransomNote.size(); i++) {\n                chars[(int)ransomNote[i]]--;\n                if (chars[(int)ransomNote[i]] < 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n};\n```\n\nAnd it gets AC.\n","source":"_posts/RansomNote.md","raw":"---\ntitle: Ransom Note\ndate: 2017-01-12 23:45:36\ntags:\n    - String\n---\n\n> Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\n>\n> Each letter in the magazine string can only be used once in your ransom note.\n>\n> Note:\n> You may assume that both strings contain only lowercase letters.\n>\n> canConstruct(\"a\", \"b\") -> false\n> canConstruct(\"aa\", \"ab\") -> false\n> canConstruct(\"aa\", \"aab\") -> true\n\n<!--more-->\n\nThis is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.\n\n\n```\nclass Solution {\n    public:\n        bool canConstruct(string ransomNote, string magazine) {\n            int chars[512] = {0};\n            for (int i = 0; i < (int)magazine.size(); i++) {\n                chars[(int)magazine[i]]++;\n            }\n            for (int i = 0; i < (int)ransomNote.size(); i++) {\n                chars[(int)ransomNote[i]]--;\n                if (chars[(int)ransomNote[i]] < 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n};\n```\n\nAnd it gets AC.\n","slug":"RansomNote","published":1,"updated":"2017-01-12T15:58:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxi0046g5f4yqwie4p9","content":"<blockquote>\n<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>\n<p>Each letter in the magazine string can only be used once in your ransom note.</p>\n<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>\n<p>canConstruct(a, b) -&gt; false<br>canConstruct(aa, ab) -&gt; false<br>canConstruct(aa, aab) -&gt; true</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canConstruct(string ransomNote, string magazine) &#123;</div><div class=\"line\">            int chars[512] = &#123;0&#125;;</div><div class=\"line\">            for (int i = 0; i &lt; (int)magazine.size(); i++) &#123;</div><div class=\"line\">                chars[(int)magazine[i]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)ransomNote.size(); i++) &#123;</div><div class=\"line\">                chars[(int)ransomNote[i]]--;</div><div class=\"line\">                if (chars[(int)ransomNote[i]] &lt; 0) &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>\n<p>Each letter in the magazine string can only be used once in your ransom note.</p>\n<p>Note:<br>You may assume that both strings contain only lowercase letters.</p>\n<p>canConstruct(a, b) -&gt; false<br>canConstruct(aa, ab) -&gt; false<br>canConstruct(aa, aab) -&gt; true</p>\n</blockquote>","more":"<p>This is Leetcode 383 and it is an easy problem. Just notice one thing: whiteSpace, numbers, should be taken into consideration. So the length of the char array should not be only 26.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool canConstruct(string ransomNote, string magazine) &#123;</div><div class=\"line\">            int chars[512] = &#123;0&#125;;</div><div class=\"line\">            for (int i = 0; i &lt; (int)magazine.size(); i++) &#123;</div><div class=\"line\">                chars[(int)magazine[i]]++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int i = 0; i &lt; (int)ransomNote.size(); i++) &#123;</div><div class=\"line\">                chars[(int)ransomNote[i]]--;</div><div class=\"line\">                if (chars[(int)ransomNote[i]] &lt; 0) &#123;</div><div class=\"line\">                    return false;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And it gets AC.</p>"},{"title":"Power of Four","date":"2017-03-23T12:39:55.000Z","_content":"\n> Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\n>\n> Example:\n>\n> Given num = 16, return true. Given num = 5, return false.\n>\n> Follow up: Could you solve it without loops/recursion?\n\n<!--more-->\n\nThis is Leetcode No.342. Due to the surprise the USTC prepared for me. I have no attention to focus on my promise to solve one problem a day. \n\nSo, today I just finish one Easy problem. Here is my solution for the problem.\n\n```\nusing namaspace std;\n\nclass Solution {\n    public:\n        boolean isPowerOfFour(int num) {\n            return (num > 0) && ((num & (num - 1)) == 0) && ((num & 0x55555555) == num);\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/PowerofFour.md","raw":"---\ntitle: Power of Four\ndate: 2017-03-23 20:39:55\ntags:\n    - Bit Manipulation\n---\n\n> Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\n>\n> Example:\n>\n> Given num = 16, return true. Given num = 5, return false.\n>\n> Follow up: Could you solve it without loops/recursion?\n\n<!--more-->\n\nThis is Leetcode No.342. Due to the surprise the USTC prepared for me. I have no attention to focus on my promise to solve one problem a day. \n\nSo, today I just finish one Easy problem. Here is my solution for the problem.\n\n```\nusing namaspace std;\n\nclass Solution {\n    public:\n        boolean isPowerOfFour(int num) {\n            return (num > 0) && ((num & (num - 1)) == 0) && ((num & 0x55555555) == num);\n        }\n};\n```\n\nIt gets AC.\n","slug":"PowerofFour","published":1,"updated":"2017-03-23T13:41:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxk0049g5f4yk7muxr1","content":"<blockquote>\n<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>\n<p>Example:</p>\n<p>Given num = 16, return true. Given num = 5, return false.</p>\n<p>Follow up: Could you solve it without loops/recursion?</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.342. Due to the surprise the USTC prepared for me. I have no attention to focus on my promise to solve one problem a day. </p>\n<p>So, today I just finish one Easy problem. Here is my solution for the problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namaspace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        boolean isPowerOfFour(int num) &#123;</div><div class=\"line\">            return (num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0) &amp;&amp; ((num &amp; 0x55555555) == num);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p>\n<p>Example:</p>\n<p>Given num = 16, return true. Given num = 5, return false.</p>\n<p>Follow up: Could you solve it without loops/recursion?</p>\n</blockquote>","more":"<p>This is Leetcode No.342. Due to the surprise the USTC prepared for me. I have no attention to focus on my promise to solve one problem a day. </p>\n<p>So, today I just finish one Easy problem. Here is my solution for the problem.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namaspace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        boolean isPowerOfFour(int num) &#123;</div><div class=\"line\">            return (num &gt; 0) &amp;&amp; ((num &amp; (num - 1)) == 0) &amp;&amp; ((num &amp; 0x55555555) == num);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Relative Ranks","date":"2017-02-05T06:23:59.000Z","_content":"\n\n> Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>\n> Example 1:\n>\n> + Input: [5, 4, 3, 2, 1]\n> + Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\n> + Explanation:\n>     + The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>     + For the left two athletes, you just need to output their relative ranks according to their scores.\n>\n> Note:\n> + N is a positive integer and won't exceed 10,000.\n> + All the scores of athletes are guaranteed to be unique.\n\n<!--more-->\n\nThis is Leetcode 506, and it is one of this week's weekly contest.\n\nEasy one.\n\n```\nbool msort( const int &v1, const int &v2) {\n    return v1 > v2;\n}\nclass Solution {\n    public:\n        vector<string> findRelativeRanks(vector<int>& nums) {\n            vector<string> res;\n            vector<int> origin(nums);\n            map<int, string> rankmap;\n\n            string ranks[3] = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n\n            sort(nums.begin(), nums.end(), msort);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (i < 3) {\n                    rankmap.insert(pair<int, string>(nums[i], ranks[i]));\n                } else {\n                    ostringstream stm;\n                    stm << i + 1;\n                    rankmap.insert(pair<int, string>(nums[i], stm.str()));\n                }\n            }\n\n            for (int i = 0; i < (int)origin.size(); i++) {\n                res.push_back(rankmap.find(origin[i])->second);\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/RelativeRanks.md","raw":"---\ntitle: Relative Ranks\ndate: 2017-02-05 14:23:59\ntags:\n    - Array\n---\n\n\n> Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>\n> Example 1:\n>\n> + Input: [5, 4, 3, 2, 1]\n> + Output: [\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]\n> + Explanation:\n>     + The first three athletes got the top three highest scores, so they got \"Gold Medal\", \"Silver Medal\" and \"Bronze Medal\".\n>     + For the left two athletes, you just need to output their relative ranks according to their scores.\n>\n> Note:\n> + N is a positive integer and won't exceed 10,000.\n> + All the scores of athletes are guaranteed to be unique.\n\n<!--more-->\n\nThis is Leetcode 506, and it is one of this week's weekly contest.\n\nEasy one.\n\n```\nbool msort( const int &v1, const int &v2) {\n    return v1 > v2;\n}\nclass Solution {\n    public:\n        vector<string> findRelativeRanks(vector<int>& nums) {\n            vector<string> res;\n            vector<int> origin(nums);\n            map<int, string> rankmap;\n\n            string ranks[3] = {\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\"};\n\n            sort(nums.begin(), nums.end(), msort);\n\n            for (int i = 0; i < (int)nums.size(); i++) {\n                if (i < 3) {\n                    rankmap.insert(pair<int, string>(nums[i], ranks[i]));\n                } else {\n                    ostringstream stm;\n                    stm << i + 1;\n                    rankmap.insert(pair<int, string>(nums[i], stm.str()));\n                }\n            }\n\n            for (int i = 0; i < (int)origin.size(); i++) {\n                res.push_back(rankmap.find(origin[i])->second);\n            }\n            return res;\n        }\n};\n```\n\nIt gets AC.\n","slug":"RelativeRanks","published":1,"updated":"2017-02-05T06:48:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxl004bg5f411suxpup","content":"<blockquote>\n<p>Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: Gold Medal, Silver Medal and Bronze Medal.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [5, 4, 3, 2, 1]</li>\n<li>Output: [Gold Medal, Silver Medal, Bronze Medal, 4, 5]</li>\n<li>Explanation:<ul>\n<li>The first three athletes got the top three highest scores, so they got Gold Medal, Silver Medal and Bronze Medal.</li>\n<li>For the left two athletes, you just need to output their relative ranks according to their scores.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>N is a positive integer and wont exceed 10,000.</li>\n<li>All the scores of athletes are guaranteed to be unique.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 506, and it is one of this weeks weekly contest.</p>\n<p>Easy one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool msort( const int &amp;v1, const int &amp;v2) &#123;</div><div class=\"line\">    return v1 &gt; v2;</div><div class=\"line\">&#125;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;string&gt; res;</div><div class=\"line\">            vector&lt;int&gt; origin(nums);</div><div class=\"line\">            map&lt;int, string&gt; rankmap;</div><div class=\"line\"></div><div class=\"line\">            string ranks[3] = &#123;&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;&#125;;</div><div class=\"line\"></div><div class=\"line\">            sort(nums.begin(), nums.end(), msort);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (i &lt; 3) &#123;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], ranks[i]));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    ostringstream stm;</div><div class=\"line\">                    stm &lt;&lt; i + 1;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], stm.str()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)origin.size(); i++) &#123;</div><div class=\"line\">                res.push_back(rankmap.find(origin[i])-&gt;second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given scores of N athletes, find their relative ranks and the men with the top three highest scores, who will be awarded medals: Gold Medal, Silver Medal and Bronze Medal.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [5, 4, 3, 2, 1]</li>\n<li>Output: [Gold Medal, Silver Medal, Bronze Medal, 4, 5]</li>\n<li>Explanation:<ul>\n<li>The first three athletes got the top three highest scores, so they got Gold Medal, Silver Medal and Bronze Medal.</li>\n<li>For the left two athletes, you just need to output their relative ranks according to their scores.</li>\n</ul>\n</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>N is a positive integer and wont exceed 10,000.</li>\n<li>All the scores of athletes are guaranteed to be unique.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 506, and it is one of this weeks weekly contest.</p>\n<p>Easy one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">bool msort( const int &amp;v1, const int &amp;v2) &#123;</div><div class=\"line\">    return v1 &gt; v2;</div><div class=\"line\">&#125;</div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            vector&lt;string&gt; res;</div><div class=\"line\">            vector&lt;int&gt; origin(nums);</div><div class=\"line\">            map&lt;int, string&gt; rankmap;</div><div class=\"line\"></div><div class=\"line\">            string ranks[3] = &#123;&quot;Gold Medal&quot;, &quot;Silver Medal&quot;, &quot;Bronze Medal&quot;&#125;;</div><div class=\"line\"></div><div class=\"line\">            sort(nums.begin(), nums.end(), msort);</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">                if (i &lt; 3) &#123;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], ranks[i]));</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    ostringstream stm;</div><div class=\"line\">                    stm &lt;&lt; i + 1;</div><div class=\"line\">                    rankmap.insert(pair&lt;int, string&gt;(nums[i], stm.str()));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)origin.size(); i++) &#123;</div><div class=\"line\">                res.push_back(rankmap.find(origin[i])-&gt;second);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Target Sum","date":"2017-01-28T14:49:36.000Z","_content":"\n\n> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n>\n> Find out how many ways to assign symbols to make sum of integers equal to target S.\n>\n> Example 1:\n>\n> Input: nums is [1, 1, 1, 1, 1], S is 3.\n> Output: 5\n>\n> Explanation:\n>\n> + -1+1+1+1+1 = 3\n> + +1-1+1+1+1 = 3\n> + +1+1-1+1+1 = 3\n> + +1+1+1-1+1 = 3\n> + +1+1+1+1-1 = 3\n>\n> There are 5 ways to assign symbols to make the sum of nums be target 3.\n>\n> Note:\n>\n> + The length of the given array is positive and will not exceed 20.\n> + The sum of elements in the given array will not exceed 1000.\n> + Your output answer is guaranteed to be fitted in a 32-bit integer.\n\n<!--more-->\n\nThis is Leetcode 494. And I tried a not best solution, just use the DFS:\n\n```\nclass Solution {\n    public:\n\n        int res;\n\n        int findTargetSumWays(vector<int>& nums, int target) {\n            res = 0;\n            _calc(nums, 0, target, 0);\n            return res;\n        }\n\n        void _calc(vector<int>& nums, int idx, int target, int current) {\n            if ((int)(nums.size()) == idx) {\n                if (current == target) {\n                    res++;\n                }\n            } else {\n                _calc(nums, idx + 1, target, current + nums[idx]);\n                _calc(nums, idx + 1, target, current - nums[idx]);\n            }\n        }\n};\n```\n\nAnd, it passed ?!\n\nSo, I try to find a better way to solve the problem, and I find I can try with DP.\n\nYou can use the following Java code:\n\n```\npublic class Solution {\n    public int findTargetSumWays(int[] nums, int s) {\n        int sum = 0;\n        for(int i: nums) sum+=i;\n        if(s>sum || s<-sum) return 0;\n        int[] dp = new int[2*sum+1];\n        dp[0+sum] = 1;\n        for(int i = 0; i<nums.length; i++){\n            int[] next = new int[2*sum+1];\n            for(int k = 0; k<2*sum+1; k++){\n                if(dp[k]!=0){\n                    next[k + nums[i]] += dp[k];\n                    next[k - nums[i]] += dp[k];\n                }\n            }\n            dp = next;\n        }\n        return dp[sum+s];\n    }\n}\n```\n\nExplaination:\n> ![](https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg)\n","source":"_posts/TargetSum.md","raw":"---\ntitle: Target Sum\ndate: 2017-01-28 22:49:36\ntags:\n    - Depth-first Search\n    - Dynamic Programming\n---\n\n\n> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\n>\n> Find out how many ways to assign symbols to make sum of integers equal to target S.\n>\n> Example 1:\n>\n> Input: nums is [1, 1, 1, 1, 1], S is 3.\n> Output: 5\n>\n> Explanation:\n>\n> + -1+1+1+1+1 = 3\n> + +1-1+1+1+1 = 3\n> + +1+1-1+1+1 = 3\n> + +1+1+1-1+1 = 3\n> + +1+1+1+1-1 = 3\n>\n> There are 5 ways to assign symbols to make the sum of nums be target 3.\n>\n> Note:\n>\n> + The length of the given array is positive and will not exceed 20.\n> + The sum of elements in the given array will not exceed 1000.\n> + Your output answer is guaranteed to be fitted in a 32-bit integer.\n\n<!--more-->\n\nThis is Leetcode 494. And I tried a not best solution, just use the DFS:\n\n```\nclass Solution {\n    public:\n\n        int res;\n\n        int findTargetSumWays(vector<int>& nums, int target) {\n            res = 0;\n            _calc(nums, 0, target, 0);\n            return res;\n        }\n\n        void _calc(vector<int>& nums, int idx, int target, int current) {\n            if ((int)(nums.size()) == idx) {\n                if (current == target) {\n                    res++;\n                }\n            } else {\n                _calc(nums, idx + 1, target, current + nums[idx]);\n                _calc(nums, idx + 1, target, current - nums[idx]);\n            }\n        }\n};\n```\n\nAnd, it passed ?!\n\nSo, I try to find a better way to solve the problem, and I find I can try with DP.\n\nYou can use the following Java code:\n\n```\npublic class Solution {\n    public int findTargetSumWays(int[] nums, int s) {\n        int sum = 0;\n        for(int i: nums) sum+=i;\n        if(s>sum || s<-sum) return 0;\n        int[] dp = new int[2*sum+1];\n        dp[0+sum] = 1;\n        for(int i = 0; i<nums.length; i++){\n            int[] next = new int[2*sum+1];\n            for(int k = 0; k<2*sum+1; k++){\n                if(dp[k]!=0){\n                    next[k + nums[i]] += dp[k];\n                    next[k - nums[i]] += dp[k];\n                }\n            }\n            dp = next;\n        }\n        return dp[sum+s];\n    }\n}\n```\n\nExplaination:\n> ![](https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg)\n","slug":"TargetSum","published":1,"updated":"2017-01-28T15:41:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxm004eg5f48xb6z4q1","content":"<blockquote>\n<p>You are given a list of non-negative integers, a1, a2, , an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.</p>\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>\n<p>Example 1:</p>\n<p>Input: nums is [1, 1, 1, 1, 1], S is 3.<br>Output: 5</p>\n<p>Explanation:</p>\n<ul>\n<li>-1+1+1+1+1 = 3</li>\n<li>+1-1+1+1+1 = 3</li>\n<li>+1+1-1+1+1 = 3</li>\n<li>+1+1+1-1+1 = 3</li>\n<li>+1+1+1+1-1 = 3</li>\n</ul>\n<p>There are 5 ways to assign symbols to make the sum of nums be target 3.</p>\n<p>Note:</p>\n<ul>\n<li>The length of the given array is positive and will not exceed 20.</li>\n<li>The sum of elements in the given array will not exceed 1000.</li>\n<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 494. And I tried a not best solution, just use the DFS:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\"></div><div class=\"line\">        int res;</div><div class=\"line\"></div><div class=\"line\">        int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            _calc(nums, 0, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _calc(vector&lt;int&gt;&amp; nums, int idx, int target, int current) &#123;</div><div class=\"line\">            if ((int)(nums.size()) == idx) &#123;</div><div class=\"line\">                if (current == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                _calc(nums, idx + 1, target, current + nums[idx]);</div><div class=\"line\">                _calc(nums, idx + 1, target, current - nums[idx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it passed ?!</p>\n<p>So, I try to find a better way to solve the problem, and I find I can try with DP.</p>\n<p>You can use the following Java code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public int findTargetSumWays(int[] nums, int s) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for(int i: nums) sum+=i;</div><div class=\"line\">        if(s&gt;sum || s&lt;-sum) return 0;</div><div class=\"line\">        int[] dp = new int[2*sum+1];</div><div class=\"line\">        dp[0+sum] = 1;</div><div class=\"line\">        for(int i = 0; i&lt;nums.length; i++)&#123;</div><div class=\"line\">            int[] next = new int[2*sum+1];</div><div class=\"line\">            for(int k = 0; k&lt;2*sum+1; k++)&#123;</div><div class=\"line\">                if(dp[k]!=0)&#123;</div><div class=\"line\">                    next[k + nums[i]] += dp[k];</div><div class=\"line\">                    next[k - nums[i]] += dp[k];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            dp = next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return dp[sum+s];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Explaination:</p>\n<blockquote>\n<p><img src=\"https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg\" alt=\"\"></p>\n</blockquote>\n","excerpt":"<blockquote>\n<p>You are given a list of non-negative integers, a1, a2, , an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.</p>\n<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>\n<p>Example 1:</p>\n<p>Input: nums is [1, 1, 1, 1, 1], S is 3.<br>Output: 5</p>\n<p>Explanation:</p>\n<ul>\n<li>-1+1+1+1+1 = 3</li>\n<li>+1-1+1+1+1 = 3</li>\n<li>+1+1-1+1+1 = 3</li>\n<li>+1+1+1-1+1 = 3</li>\n<li>+1+1+1+1-1 = 3</li>\n</ul>\n<p>There are 5 ways to assign symbols to make the sum of nums be target 3.</p>\n<p>Note:</p>\n<ul>\n<li>The length of the given array is positive and will not exceed 20.</li>\n<li>The sum of elements in the given array will not exceed 1000.</li>\n<li>Your output answer is guaranteed to be fitted in a 32-bit integer.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 494. And I tried a not best solution, just use the DFS:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\"></div><div class=\"line\">        int res;</div><div class=\"line\"></div><div class=\"line\">        int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;</div><div class=\"line\">            res = 0;</div><div class=\"line\">            _calc(nums, 0, target, 0);</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void _calc(vector&lt;int&gt;&amp; nums, int idx, int target, int current) &#123;</div><div class=\"line\">            if ((int)(nums.size()) == idx) &#123;</div><div class=\"line\">                if (current == target) &#123;</div><div class=\"line\">                    res++;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                _calc(nums, idx + 1, target, current + nums[idx]);</div><div class=\"line\">                _calc(nums, idx + 1, target, current - nums[idx]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it passed ?!</p>\n<p>So, I try to find a better way to solve the problem, and I find I can try with DP.</p>\n<p>You can use the following Java code:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Solution &#123;</div><div class=\"line\">    public int findTargetSumWays(int[] nums, int s) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for(int i: nums) sum+=i;</div><div class=\"line\">        if(s&gt;sum || s&lt;-sum) return 0;</div><div class=\"line\">        int[] dp = new int[2*sum+1];</div><div class=\"line\">        dp[0+sum] = 1;</div><div class=\"line\">        for(int i = 0; i&lt;nums.length; i++)&#123;</div><div class=\"line\">            int[] next = new int[2*sum+1];</div><div class=\"line\">            for(int k = 0; k&lt;2*sum+1; k++)&#123;</div><div class=\"line\">                if(dp[k]!=0)&#123;</div><div class=\"line\">                    next[k + nums[i]] += dp[k];</div><div class=\"line\">                    next[k - nums[i]] += dp[k];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            dp = next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return dp[sum+s];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Explaination:</p>\n<blockquote>\n<p><img src=\"https://discuss.leetcode.com/uploads/files/1485048726667-screen-shot-2017-01-21-at-8.31.48-pm.jpg\" alt=\"\"></p>\n</blockquote>"},{"title":"Teemo Attacking","date":"2017-02-02T12:17:16.000Z","_content":"\n> In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n>\n> You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n>\n> Example 1:\n> + Input: [1,4], 2\n> + Output: 4\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\n>\n> Example 2:\n> + Input: [1,2], 2\n> + Output: 3\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\n>\n> Note:\n> + You may assume the length of given time series array won't exceed 10000.\n> + You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.\n\n<!--more-->\n\nThis is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.\n\nIts tag is Array but I think use bitset will be a better solution if the time number is small.\n\nHere is the solution:\n\n```\nclass Solution {\n    public:\n        int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n            if (timeSeries.size() == 0) {\n                return 0;\n            }\n\n            int res = 0;\n\n            sort(timeSeries.begin(), timeSeries.end());\n\n            for (int i = 0; i < (int)timeSeries.size() - 1; i++) {\n                if (timeSeries[i] + duration >= timeSeries[i + 1]) {\n                    res = res + (timeSeries[i + 1] - timeSeries[i]);\n                } else {\n                    res = res + duration;\n                }\n            }\n\n            return res + duration;\n        }\n};\n```\n\nSo easy, and it gets AC.\n","source":"_posts/TeemoAttacking.md","raw":"---\ntitle: Teemo Attacking\ndate: 2017-02-02 20:17:16\ntags:\n    - Array\n---\n\n> In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\n>\n> You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n>\n> Example 1:\n> + Input: [1,4], 2\n> + Output: 4\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.\n>\n> Example 2:\n> + Input: [1,2], 2\n> + Output: 3\n> + Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status won't add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.\n>\n> Note:\n> + You may assume the length of given time series array won't exceed 10000.\n> + You may assume the numbers in the Teemo's attacking time series and his poisoning time duration per attacking are non-negative integers, which won't exceed 10,000,000.\n\n<!--more-->\n\nThis is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.\n\nIts tag is Array but I think use bitset will be a better solution if the time number is small.\n\nHere is the solution:\n\n```\nclass Solution {\n    public:\n        int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n            if (timeSeries.size() == 0) {\n                return 0;\n            }\n\n            int res = 0;\n\n            sort(timeSeries.begin(), timeSeries.end());\n\n            for (int i = 0; i < (int)timeSeries.size() - 1; i++) {\n                if (timeSeries[i] + duration >= timeSeries[i + 1]) {\n                    res = res + (timeSeries[i + 1] - timeSeries[i]);\n                } else {\n                    res = res + duration;\n                }\n            }\n\n            return res + duration;\n        }\n};\n```\n\nSo easy, and it gets AC.\n","slug":"TeemoAttacking","published":1,"updated":"2017-02-02T12:46:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxn004gg5f4qnfkpa33","content":"<blockquote>\n<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemos attacking ascending time series towards Ashe and the poisoning time duration per Teemos attacking, you need to output the total time that Ashe is in poisoned condition.</p>\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,4], 2</li>\n<li>Output: 4</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1,2], 2</li>\n<li>Output: 3</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status wont add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>You may assume the length of given time series array wont exceed 10000.</li>\n<li>You may assume the numbers in the Teemos attacking time series and his poisoning time duration per attacking are non-negative integers, which wont exceed 10,000,000.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.</p>\n<p>Its tag is Array but I think use bitset will be a better solution if the time number is small.</p>\n<p>Here is the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) &#123;</div><div class=\"line\">            if (timeSeries.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\"></div><div class=\"line\">            sort(timeSeries.begin(), timeSeries.end());</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)timeSeries.size() - 1; i++) &#123;</div><div class=\"line\">                if (timeSeries[i] + duration &gt;= timeSeries[i + 1]) &#123;</div><div class=\"line\">                    res = res + (timeSeries[i + 1] - timeSeries[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = res + duration;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res + duration;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So easy, and it gets AC.</p>\n","excerpt":"<blockquote>\n<p>In LLP world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemos attacking ascending time series towards Ashe and the poisoning time duration per Teemos attacking, you need to output the total time that Ashe is in poisoned condition.</p>\n<p>You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: [1,4], 2</li>\n<li>Output: 4</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned immediately. This poisoned status will last 2 seconds until the end of time point 2. And at time point 4, Teemo attacks Ashe again, and causes Ashe to be in poisoned status for another 2 seconds. So you finally need to output 4.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: [1,2], 2</li>\n<li>Output: 3</li>\n<li>Explanation: At time point 1, Teemo starts attacking Ashe and makes Ashe be poisoned. This poisoned status will last 2 seconds until the end of time point 2. However, at the beginning of time point 2, Teemo attacks Ashe again who is already in poisoned status. Since the poisoned status wont add up together, though the second poisoning attack will still work at time point 2, it will stop at the end of time point 3. So you finally need to output 3.</li>\n</ul>\n<p>Note:</p>\n<ul>\n<li>You may assume the length of given time series array wont exceed 10000.</li>\n<li>You may assume the numbers in the Teemos attacking time series and his poisoning time duration per attacking are non-negative integers, which wont exceed 10,000,000.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 495. It is an interesting problem, I like LLP, and Teemo is my favorite hero. So, I understand the problem description quickly and figure it out rapidly.</p>\n<p>Its tag is Array but I think use bitset will be a better solution if the time number is small.</p>\n<p>Here is the solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int findPoisonedDuration(vector&lt;int&gt;&amp; timeSeries, int duration) &#123;</div><div class=\"line\">            if (timeSeries.size() == 0) &#123;</div><div class=\"line\">                return 0;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            int res = 0;</div><div class=\"line\"></div><div class=\"line\">            sort(timeSeries.begin(), timeSeries.end());</div><div class=\"line\"></div><div class=\"line\">            for (int i = 0; i &lt; (int)timeSeries.size() - 1; i++) &#123;</div><div class=\"line\">                if (timeSeries[i] + duration &gt;= timeSeries[i + 1]) &#123;</div><div class=\"line\">                    res = res + (timeSeries[i + 1] - timeSeries[i]);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    res = res + duration;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return res + duration;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So easy, and it gets AC.</p>"},{"title":"Total Hamming Distance","date":"2017-01-02T05:46:25.000Z","_content":"\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","source":"_posts/TotalHammingDistance.md","raw":"---\ntitle: Total Hamming Distance\ndate: 2017-01-02 13:46:25\ntags: \n    - Bitmap\n---\n\n> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n>\n> Now your job is to find the total Hamming distance between all pairs of the given numbers.\n>\n> Example:\n>\n> Input: 4, 14, 2\n> Output: 6\n>\n> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just\n> showing the four bits relevant in this case). So the answer will be:\n> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n>\n> Note:\n> + Elements of the given array are in the range of 0 to 10^9\n> + Length of the array will not exceed 10^4.\n>\n> Subscribe to see which companies asked this question\n\n<!--more-->\n\nThis is the leetcode No.477, we can quickly find a solution like this:\n\n```\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalHammingDistance(vector<int>& nums) {\n        int sum = 0;\n        for (int i = 0; i < (int)nums.size() - 1; i++) {\n            for (int j = i + 1; j < (int)nums.size(); j++) {\n                sum += hamming_distance(nums[i], nums[j]);\n            }\n        }\n        return sum;\n    }\n\n    int hamming_distance(unsigned long long x, unsigned long long y) {\n        return __builtin_popcountll(x ^ y);\n    }\n};\n```\n\nIt is correct, however it time complex is O(n^2), and the result is TLE.\n\nSo, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.\n\n```\n0000 0000\n1110 0010\n1101 0101\n```\n\nWe get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)*(1) which stands for (n - bitCount) * bitCount.\n\nSo, what we should do is to add the total 32 bits.\n\nLast, here comes to a solution:\n\n```\nint totalHammingDistance(vector<int>& nums) {\n    int total = 0, bitCount = 0;\n    for (int idx = 0; idx < 32; idx++) {\n        for (int i = 0; i < (int)nums.size(); i++) {\n            bitCount += (nums[i] >> idx) & 1;\n        }\n        total += bitCount * (nums.size() - bitCount);\n    }\n    return total;\n}\n```\n\nAnd it's time complex is O(n*32) which means O(n) and it's accepted.\n","slug":"TotalHammingDistance","published":1,"updated":"2017-01-13T03:10:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxp004jg5f4rt6zt2yn","content":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2<br>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And its time complex is O(n*32) which means O(n) and its accepted.</p>\n","excerpt":"<blockquote>\n<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n<p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p>\n<p>Example:</p>\n<p>Input: 4, 14, 2<br>Output: 6</p>\n<p>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p>\n<p>Note:</p>\n<ul>\n<li>Elements of the given array are in the range of 0 to 10^9</li>\n<li>Length of the array will not exceed 10^4.</li>\n</ul>\n<p>Subscribe to see which companies asked this question</p>\n</blockquote>","more":"<p>This is the leetcode No.477, we can quickly find a solution like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">public:</div><div class=\"line\">    int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">        int sum = 0;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">            for (int j = i + 1; j &lt; (int)nums.size(); j++) &#123;</div><div class=\"line\">                sum += hamming_distance(nums[i], nums[j]);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return sum;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int hamming_distance(unsigned long long x, unsigned long long y) &#123;</div><div class=\"line\">        return __builtin_popcountll(x ^ y);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It is correct, however it time complex is O(n^2), and the result is TLE.</p>\n<p>So, I found a better solution here. As we can see from the question, we can find the number is int type, and no larger than 2^32 in that we use a 32 bit size bitmap. For better explaination, I use 8 bit size as example.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">0000 0000</div><div class=\"line\">1110 0010</div><div class=\"line\">1101 0101</div></pre></td></tr></table></figure>\n<p>We get such an array, and we just need to figure out how many 1s in each index. Take 1st index as an example, we get one 1 bit, and the total distance for the 1st index is (3-1)<em>(1) which stands for (n - bitCount) </em> bitCount.</p>\n<p>So, what we should do is to add the total 32 bits.</p>\n<p>Last, here comes to a solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">    int total = 0, bitCount = 0;</div><div class=\"line\">    for (int idx = 0; idx &lt; 32; idx++) &#123;</div><div class=\"line\">        for (int i = 0; i &lt; (int)nums.size(); i++) &#123;</div><div class=\"line\">            bitCount += (nums[i] &gt;&gt; idx) &amp; 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">        total += bitCount * (nums.size() - bitCount);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return total;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>And its time complex is O(n*32) which means O(n) and its accepted.</p>"},{"title":"Surrounded Regions","date":"2017-03-12T06:12:21.000Z","_content":"\n> Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\n>\n> A region is captured by flipping all 'O's into 'X's in that surrounded region.\n>\n> For example,\n>```\nX X X X\nX O O X\nX X O X\nX O X X\n```\n> After running your function, the board should be:\n>```\nX X X X\nX X X X\nX X X X\nX O X X\n```\n\n<!--more-->\n\nThis is Leetcode No.130. It is a easy one. This is my solution:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        void solve(vector<vector<char> >& board) {\n            if (board.size() == 0 || board[0].size() == 0) {\n                return;\n            }\n\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                if (board[idx][0] == 'O') {\n                    visit(board, idx, 0);\n                }\n\n                if (board[idx][board[0].size() - 1] == 'O') {\n                    visit(board, idx, board[0].size() - 1);\n                }\n            }\n\n            for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                if (board[0][idy] == 'O') {\n                    visit(board, 0, idy);\n                }\n\n                if (board[board.size() - 1][idy] == 'O') {\n                    visit(board, board.size() - 1, idy);\n                }\n            }\n\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'O') {\n                        board[idx][idy] = 'X';\n                    }\n                }\n            }\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'V') {\n                        board[idx][idy] = 'O';\n                    }\n                }\n            }\n        }\n\n        void visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idx >= (int)board.size()) {\n                return;\n            }\n\n            if (idy < 0 || idy >= (int)board[0].size()) {\n                return;\n            }\n\n            if (board[idx][idy] != 'O') {\n                return;\n            }\n\n            if (board[idx][idy] == 'O') {\n                board[idx][idy] = 'V';\n                visit(board, idx + 1, idy);\n                visit(board, idx, idy + 1);\n                visit(board, idx - 1, idy);\n                visit(board, idx , idy - 1);\n            }\n        }\n};\n```\n\nFind the 'O' on the border then find the related ones. Mark them with 'V', then mark every remaining 'O' to X, then mark the 'V' to 'O'.\n\nIt gets AC.\n","source":"_posts/SurroundedRegions.md","raw":"---\ntitle: Surrounded Regions\ndate: 2017-03-12 14:12:21\ntags:\n    - Union Find\n    - Breadth-first Search\n---\n\n> Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\n>\n> A region is captured by flipping all 'O's into 'X's in that surrounded region.\n>\n> For example,\n>```\nX X X X\nX O O X\nX X O X\nX O X X\n```\n> After running your function, the board should be:\n>```\nX X X X\nX X X X\nX X X X\nX O X X\n```\n\n<!--more-->\n\nThis is Leetcode No.130. It is a easy one. This is my solution:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        void solve(vector<vector<char> >& board) {\n            if (board.size() == 0 || board[0].size() == 0) {\n                return;\n            }\n\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                if (board[idx][0] == 'O') {\n                    visit(board, idx, 0);\n                }\n\n                if (board[idx][board[0].size() - 1] == 'O') {\n                    visit(board, idx, board[0].size() - 1);\n                }\n            }\n\n            for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                if (board[0][idy] == 'O') {\n                    visit(board, 0, idy);\n                }\n\n                if (board[board.size() - 1][idy] == 'O') {\n                    visit(board, board.size() - 1, idy);\n                }\n            }\n\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'O') {\n                        board[idx][idy] = 'X';\n                    }\n                }\n            }\n            for (int idx = 0; idx < (int)board.size(); idx++) {\n                for (int idy = 0; idy < (int)board[0].size(); idy++) {\n                    if (board[idx][idy] == 'V') {\n                        board[idx][idy] = 'O';\n                    }\n                }\n            }\n        }\n\n        void visit(vector<vector<char> > &board, int idx, int idy) {\n            if (idx < 0 || idx >= (int)board.size()) {\n                return;\n            }\n\n            if (idy < 0 || idy >= (int)board[0].size()) {\n                return;\n            }\n\n            if (board[idx][idy] != 'O') {\n                return;\n            }\n\n            if (board[idx][idy] == 'O') {\n                board[idx][idy] = 'V';\n                visit(board, idx + 1, idy);\n                visit(board, idx, idy + 1);\n                visit(board, idx - 1, idy);\n                visit(board, idx , idy - 1);\n            }\n        }\n};\n```\n\nFind the 'O' on the border then find the related ones. Mark them with 'V', then mark every remaining 'O' to X, then mark the 'V' to 'O'.\n\nIt gets AC.\n","slug":"SurroundedRegions","published":1,"updated":"2017-03-12T06:35:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxr004lg5f4rc6ezqdk","content":"<blockquote>\n<p>Given a 2D board containing X and O (the letter O), capture all regions surrounded by X.</p>\n<p>A region is captured by flipping all Os into Xs in that surrounded region.</p>\n<p>For example,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">X X X X</div><div class=\"line\">X O O X</div><div class=\"line\">X X O X</div><div class=\"line\">X O X X</div></pre></td></tr></table></figure></p>\n<p>After running your function, the board should be:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">X X X X</div><div class=\"line\">X X X X</div><div class=\"line\">X X X X</div><div class=\"line\">X O X X</div></pre></td></tr></table></figure></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.130. It is a easy one. This is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            if (board.size() == 0 || board[0].size() == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                if (board[idx][0] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, idx, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (board[idx][board[0].size() - 1] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, idx, board[0].size() - 1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                if (board[0][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, 0, idy);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (board[board.size() - 1][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, board.size() - 1, idy);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                        board[idx][idy] = &apos;X&apos;;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;V&apos;) &#123;</div><div class=\"line\">                        board[idx][idy] = &apos;O&apos;;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idx &gt;= (int)board.size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (idy &lt; 0 || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (board[idx][idy] != &apos;O&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (board[idx][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                board[idx][idy] = &apos;V&apos;;</div><div class=\"line\">                visit(board, idx + 1, idy);</div><div class=\"line\">                visit(board, idx, idy + 1);</div><div class=\"line\">                visit(board, idx - 1, idy);</div><div class=\"line\">                visit(board, idx , idy - 1);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Find the O on the border then find the related ones. Mark them with V, then mark every remaining O to X, then mark the V to O.</p>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a 2D board containing X and O (the letter O), capture all regions surrounded by X.</p>\n<p>A region is captured by flipping all Os into Xs in that surrounded region.</p>\n<p>For example,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">X X X X</div><div class=\"line\">X O O X</div><div class=\"line\">X X O X</div><div class=\"line\">X O X X</div></pre></td></tr></table></figure></p>\n<p>After running your function, the board should be:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">X X X X</div><div class=\"line\">X X X X</div><div class=\"line\">X X X X</div><div class=\"line\">X O X X</div></pre></td></tr></table></figure></p>\n</blockquote>","more":"<p>This is Leetcode No.130. It is a easy one. This is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        void solve(vector&lt;vector&lt;char&gt; &gt;&amp; board) &#123;</div><div class=\"line\">            if (board.size() == 0 || board[0].size() == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                if (board[idx][0] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, idx, 0);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (board[idx][board[0].size() - 1] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, idx, board[0].size() - 1);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                if (board[0][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, 0, idy);</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (board[board.size() - 1][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                    visit(board, board.size() - 1, idy);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                        board[idx][idy] = &apos;X&apos;;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            for (int idx = 0; idx &lt; (int)board.size(); idx++) &#123;</div><div class=\"line\">                for (int idy = 0; idy &lt; (int)board[0].size(); idy++) &#123;</div><div class=\"line\">                    if (board[idx][idy] == &apos;V&apos;) &#123;</div><div class=\"line\">                        board[idx][idy] = &apos;O&apos;;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        void visit(vector&lt;vector&lt;char&gt; &gt; &amp;board, int idx, int idy) &#123;</div><div class=\"line\">            if (idx &lt; 0 || idx &gt;= (int)board.size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (idy &lt; 0 || idy &gt;= (int)board[0].size()) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (board[idx][idy] != &apos;O&apos;) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (board[idx][idy] == &apos;O&apos;) &#123;</div><div class=\"line\">                board[idx][idy] = &apos;V&apos;;</div><div class=\"line\">                visit(board, idx + 1, idy);</div><div class=\"line\">                visit(board, idx, idy + 1);</div><div class=\"line\">                visit(board, idx - 1, idy);</div><div class=\"line\">                visit(board, idx , idy - 1);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>Find the O on the border then find the related ones. Mark them with V, then mark every remaining O to X, then mark the V to O.</p>\n<p>It gets AC.</p>"},{"title":"Unique Substrings in Wraparound String","date":"2017-01-30T14:33:40.000Z","_content":"\n> Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n>\n> Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\n>\n> Note: p consists of only lowercase English letters and the size of p might be over 10000.\n>\n> Example 1:\n> + Input: \"a\"\n> + Output: 1\n> + Explanation: Only the substring \"a\" of string \"a\" is in the string \u0010s.\n>\n> Example 2:\n> + Input: \"cac\"\n> + Output: 2\n> + Explanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\n>\n> Example 3:\n> + Input: \"zab\"\n> + Output: 6\n> + Explanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\n\n<!--more-->\n\nThis is Leetcode 467. And it's a easy DP problem. Here is my solution:\n\n```\nclass Solution {\n\n    public:\n        int findSubstringInWraproundString(string p) {\n            vector<int> letters(26, 0);\n            int res = 0, len = 0;\n            for (int i = 0; i < (int)p.size(); i++) {\n                int cur = p[i] - 'a';\n                if (i > 0 && p[i - 1] != (cur + 26 - 1) % 26 + 'a') len = 0;\n                if (++len > letters[cur]) {\n                    res += len - letters[cur];\n                    letters[cur] = len;\n                }\n            }\n            return res;\n        }\n};\n\n```\n\nAnd, it gets AC.\n","source":"_posts/UniqueSubstringsinWraparoundString.md","raw":"---\ntitle: Unique Substrings in Wraparound String\ndate: 2017-01-30 22:33:40\ntags:\n    - Dynamic Programming\n---\n\n> Consider the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n>\n> Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.\n>\n> Note: p consists of only lowercase English letters and the size of p might be over 10000.\n>\n> Example 1:\n> + Input: \"a\"\n> + Output: 1\n> + Explanation: Only the substring \"a\" of string \"a\" is in the string \u0010s.\n>\n> Example 2:\n> + Input: \"cac\"\n> + Output: 2\n> + Explanation: There are two substrings \"a\", \"c\" of string \"cac\" in the string s.\n>\n> Example 3:\n> + Input: \"zab\"\n> + Output: 6\n> + Explanation: There are six substrings \"z\", \"a\", \"b\", \"za\", \"ab\", \"zab\" of string \"zab\" in the string s.\n\n<!--more-->\n\nThis is Leetcode 467. And it's a easy DP problem. Here is my solution:\n\n```\nclass Solution {\n\n    public:\n        int findSubstringInWraproundString(string p) {\n            vector<int> letters(26, 0);\n            int res = 0, len = 0;\n            for (int i = 0; i < (int)p.size(); i++) {\n                int cur = p[i] - 'a';\n                if (i > 0 && p[i - 1] != (cur + 26 - 1) % 26 + 'a') len = 0;\n                if (++len > letters[cur]) {\n                    res += len - letters[cur];\n                    letters[cur] = len;\n                }\n            }\n            return res;\n        }\n};\n\n```\n\nAnd, it gets AC.\n","slug":"UniqueSubstringsinWraparoundString","published":1,"updated":"2017-01-30T15:07:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxt004og5f47l9w23ug","content":"<blockquote>\n<p>Consider the string s to be the infinite wraparound string of abcdefghijklmnopqrstuvwxyz, so s will look like this: zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd..</p>\n<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>\n<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: a</li>\n<li>Output: 1</li>\n<li>Explanation: Only the substring a of string a is in the string \u0010s.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: cac</li>\n<li>Output: 2</li>\n<li>Explanation: There are two substrings a, c of string cac in the string s.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Input: zab</li>\n<li>Output: 6</li>\n<li>Explanation: There are six substrings z, a, b, za, ab, zab of string zab in the string s.</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode 467. And its a easy DP problem. Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\"></div><div class=\"line\">    public:</div><div class=\"line\">        int findSubstringInWraproundString(string p) &#123;</div><div class=\"line\">            vector&lt;int&gt; letters(26, 0);</div><div class=\"line\">            int res = 0, len = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)p.size(); i++) &#123;</div><div class=\"line\">                int cur = p[i] - &apos;a&apos;;</div><div class=\"line\">                if (i &gt; 0 &amp;&amp; p[i - 1] != (cur + 26 - 1) % 26 + &apos;a&apos;) len = 0;</div><div class=\"line\">                if (++len &gt; letters[cur]) &#123;</div><div class=\"line\">                    res += len - letters[cur];</div><div class=\"line\">                    letters[cur] = len;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it gets AC.</p>\n","excerpt":"<blockquote>\n<p>Consider the string s to be the infinite wraparound string of abcdefghijklmnopqrstuvwxyz, so s will look like this: zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd..</p>\n<p>Now we have another string p. Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.</p>\n<p>Note: p consists of only lowercase English letters and the size of p might be over 10000.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: a</li>\n<li>Output: 1</li>\n<li>Explanation: Only the substring a of string a is in the string \u0010s.</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: cac</li>\n<li>Output: 2</li>\n<li>Explanation: There are two substrings a, c of string cac in the string s.</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li>Input: zab</li>\n<li>Output: 6</li>\n<li>Explanation: There are six substrings z, a, b, za, ab, zab of string zab in the string s.</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode 467. And its a easy DP problem. Here is my solution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\"></div><div class=\"line\">    public:</div><div class=\"line\">        int findSubstringInWraproundString(string p) &#123;</div><div class=\"line\">            vector&lt;int&gt; letters(26, 0);</div><div class=\"line\">            int res = 0, len = 0;</div><div class=\"line\">            for (int i = 0; i &lt; (int)p.size(); i++) &#123;</div><div class=\"line\">                int cur = p[i] - &apos;a&apos;;</div><div class=\"line\">                if (i &gt; 0 &amp;&amp; p[i - 1] != (cur + 26 - 1) % 26 + &apos;a&apos;) len = 0;</div><div class=\"line\">                if (++len &gt; letters[cur]) &#123;</div><div class=\"line\">                    res += len - letters[cur];</div><div class=\"line\">                    letters[cur] = len;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return res;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>And, it gets AC.</p>"},{"title":"Single Element in a Sorted Array","date":"2017-03-09T02:29:04.000Z","_content":"\n> Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.\n>\n> Example 1:\n>```\nInput: [1,1,2,3,3,4,4,8,8]\nOutput: 2\n```\n> Example 2:\n>```\nInput: [3,3,7,7,10,11,11]\nOutput: 10\n```\n> Note: Your solution should run in O(log n) time and O(1) space.\n\n<!--more-->\n\nThis is Leetcode No.540. For some reason it will be a easy problem if the time limit is O(n).\n\nIts answer will be like these:\n\n```\nclass Solution {\n    public:\n        int singleNonDuplicate(vector<int>& nums) {\n            if (nums.size() == 1) {\n                return nums[0];\n            }\n\n            if (nums[0] != nums[1]) {\n                return nums[0];\n            }\n\n            for (int i = 1; i < (int)nums.size() - 1; i++) {\n                if (!(nums[i - 1] == nums[i] || nums[i] == nums[i + 1])) {\n                    return nums[i];\n                }\n            }\n\n            if (nums[nums.size() - 1] != nums[nums.size() - 2]) {\n                return nums[nums.size() - 1];\n            }\n\n            return -1;\n        }\n};\n```\n\nIt gets AC. However its time complex is O(n). So, it is not the best solution. So, what do you think of O(logN), I first come up with binary search.\n\nWe can understand that every number in this array appearing twice. So, the number must be times of 2.\n\nPicutre this:\n\n```\nidx: 0 1 2 3 4 5 6 7 8\n     1 1 2 3 3 4 4 5 5\nmid:         4\n     1 1 2 3 3 4 4 5 5\n```\n\nWe find that nums[mid] = 4 and it's pre is 3. So we can quickly conclude that the single one is between 0 ~ 4.\n\nSo, the solution will be improved by these ways:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int singleNonDuplicate(vector<int>& nums) {\n            int n = nums.size(), left = 0, right = n - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (mid % 2 == 0) {\n                    if (nums[mid] == nums[mid-1]) right = mid - 2;\n                    else if (nums[mid] == nums[mid+1]) left = mid + 2;\n                    else return nums[mid];\n                }\n                else {\n                    if (nums[mid] == nums[mid-1]) left = mid + 1;\n                    else if (nums[mid] == nums[mid+1]) right = mid - 1;\n                }\n            }\n            return nums[left];\n        }\n};\n```\n\nSo, the time complex is O(logN), the problem is solved.\n","source":"_posts/SingleElementinaSortedArray.md","raw":"---\ntitle: Single Element in a Sorted Array\ndate: 2017-03-09 10:29:04\ntags:\n    - Array\n    - Binary Search\n---\n\n> Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.\n>\n> Example 1:\n>```\nInput: [1,1,2,3,3,4,4,8,8]\nOutput: 2\n```\n> Example 2:\n>```\nInput: [3,3,7,7,10,11,11]\nOutput: 10\n```\n> Note: Your solution should run in O(log n) time and O(1) space.\n\n<!--more-->\n\nThis is Leetcode No.540. For some reason it will be a easy problem if the time limit is O(n).\n\nIts answer will be like these:\n\n```\nclass Solution {\n    public:\n        int singleNonDuplicate(vector<int>& nums) {\n            if (nums.size() == 1) {\n                return nums[0];\n            }\n\n            if (nums[0] != nums[1]) {\n                return nums[0];\n            }\n\n            for (int i = 1; i < (int)nums.size() - 1; i++) {\n                if (!(nums[i - 1] == nums[i] || nums[i] == nums[i + 1])) {\n                    return nums[i];\n                }\n            }\n\n            if (nums[nums.size() - 1] != nums[nums.size() - 2]) {\n                return nums[nums.size() - 1];\n            }\n\n            return -1;\n        }\n};\n```\n\nIt gets AC. However its time complex is O(n). So, it is not the best solution. So, what do you think of O(logN), I first come up with binary search.\n\nWe can understand that every number in this array appearing twice. So, the number must be times of 2.\n\nPicutre this:\n\n```\nidx: 0 1 2 3 4 5 6 7 8\n     1 1 2 3 3 4 4 5 5\nmid:         4\n     1 1 2 3 3 4 4 5 5\n```\n\nWe find that nums[mid] = 4 and it's pre is 3. So we can quickly conclude that the single one is between 0 ~ 4.\n\nSo, the solution will be improved by these ways:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        int singleNonDuplicate(vector<int>& nums) {\n            int n = nums.size(), left = 0, right = n - 1;\n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (mid % 2 == 0) {\n                    if (nums[mid] == nums[mid-1]) right = mid - 2;\n                    else if (nums[mid] == nums[mid+1]) left = mid + 2;\n                    else return nums[mid];\n                }\n                else {\n                    if (nums[mid] == nums[mid-1]) left = mid + 1;\n                    else if (nums[mid] == nums[mid+1]) right = mid - 1;\n                }\n            }\n            return nums[left];\n        }\n};\n```\n\nSo, the time complex is O(logN), the problem is solved.\n","slug":"SingleElementinaSortedArray","published":1,"updated":"2017-03-09T07:56:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxv004qg5f4fks7y3m9","content":"<blockquote>\n<p>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [1,1,2,3,3,4,4,8,8]</div><div class=\"line\">Output: 2</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [3,3,7,7,10,11,11]</div><div class=\"line\">Output: 10</div></pre></td></tr></table></figure></p>\n<p>Note: Your solution should run in O(log n) time and O(1) space.</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.540. For some reason it will be a easy problem if the time limit is O(n).</p>\n<p>Its answer will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 1) &#123;</div><div class=\"line\">                return nums[0];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (nums[0] != nums[1]) &#123;</div><div class=\"line\">                return nums[0];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 1; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">                if (!(nums[i - 1] == nums[i] || nums[i] == nums[i + 1])) &#123;</div><div class=\"line\">                    return nums[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (nums[nums.size() - 1] != nums[nums.size() - 2]) &#123;</div><div class=\"line\">                return nums[nums.size() - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. However its time complex is O(n). So, it is not the best solution. So, what do you think of O(logN), I first come up with binary search.</p>\n<p>We can understand that every number in this array appearing twice. So, the number must be times of 2.</p>\n<p>Picutre this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">idx: 0 1 2 3 4 5 6 7 8</div><div class=\"line\">     1 1 2 3 3 4 4 5 5</div><div class=\"line\">mid:         4</div><div class=\"line\">     1 1 2 3 3 4 4 5 5</div></pre></td></tr></table></figure>\n<p>We find that nums[mid] = 4 and its pre is 3. So we can quickly conclude that the single one is between 0 ~ 4.</p>\n<p>So, the solution will be improved by these ways:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int n = nums.size(), left = 0, right = n - 1;</div><div class=\"line\">            while (left &lt; right) &#123;</div><div class=\"line\">                int mid = left + (right - left) / 2;</div><div class=\"line\">                if (mid % 2 == 0) &#123;</div><div class=\"line\">                    if (nums[mid] == nums[mid-1]) right = mid - 2;</div><div class=\"line\">                    else if (nums[mid] == nums[mid+1]) left = mid + 2;</div><div class=\"line\">                    else return nums[mid];</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123;</div><div class=\"line\">                    if (nums[mid] == nums[mid-1]) left = mid + 1;</div><div class=\"line\">                    else if (nums[mid] == nums[mid+1]) right = mid - 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return nums[left];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So, the time complex is O(logN), the problem is solved.</p>\n","excerpt":"<blockquote>\n<p>Given a sorted array consisting of only integers where every element appears twice except for one element which appears once. Find this single element that appears only once.</p>\n<p>Example 1:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [1,1,2,3,3,4,4,8,8]</div><div class=\"line\">Output: 2</div></pre></td></tr></table></figure></p>\n<p>Example 2:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [3,3,7,7,10,11,11]</div><div class=\"line\">Output: 10</div></pre></td></tr></table></figure></p>\n<p>Note: Your solution should run in O(log n) time and O(1) space.</p>\n</blockquote>","more":"<p>This is Leetcode No.540. For some reason it will be a easy problem if the time limit is O(n).</p>\n<p>Its answer will be like these:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            if (nums.size() == 1) &#123;</div><div class=\"line\">                return nums[0];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (nums[0] != nums[1]) &#123;</div><div class=\"line\">                return nums[0];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            for (int i = 1; i &lt; (int)nums.size() - 1; i++) &#123;</div><div class=\"line\">                if (!(nums[i - 1] == nums[i] || nums[i] == nums[i + 1])) &#123;</div><div class=\"line\">                    return nums[i];</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            if (nums[nums.size() - 1] != nums[nums.size() - 2]) &#123;</div><div class=\"line\">                return nums[nums.size() - 1];</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return -1;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC. However its time complex is O(n). So, it is not the best solution. So, what do you think of O(logN), I first come up with binary search.</p>\n<p>We can understand that every number in this array appearing twice. So, the number must be times of 2.</p>\n<p>Picutre this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">idx: 0 1 2 3 4 5 6 7 8</div><div class=\"line\">     1 1 2 3 3 4 4 5 5</div><div class=\"line\">mid:         4</div><div class=\"line\">     1 1 2 3 3 4 4 5 5</div></pre></td></tr></table></figure>\n<p>We find that nums[mid] = 4 and its pre is 3. So we can quickly conclude that the single one is between 0 ~ 4.</p>\n<p>So, the solution will be improved by these ways:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;</div><div class=\"line\">            int n = nums.size(), left = 0, right = n - 1;</div><div class=\"line\">            while (left &lt; right) &#123;</div><div class=\"line\">                int mid = left + (right - left) / 2;</div><div class=\"line\">                if (mid % 2 == 0) &#123;</div><div class=\"line\">                    if (nums[mid] == nums[mid-1]) right = mid - 2;</div><div class=\"line\">                    else if (nums[mid] == nums[mid+1]) left = mid + 2;</div><div class=\"line\">                    else return nums[mid];</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123;</div><div class=\"line\">                    if (nums[mid] == nums[mid-1]) left = mid + 1;</div><div class=\"line\">                    else if (nums[mid] == nums[mid+1]) right = mid - 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return nums[left];</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>So, the time complex is O(logN), the problem is solved.</p>"},{"title":"Valid Perfect Square","date":"2017-01-25T14:15:29.000Z","_content":"\n> Given a positive integer num, write a function which returns True if num is a perfect square else False.\n>\n> Note: Do not use any built-in library function such as sqrt.\n>\n> Example 1:\n> + Input: 16\n> + Returns: True\n>\n> Example 2:\n> + Input: 14\n> + Returns: False\n\n<!--more-->\n\nIt's Leetcode 367. Easy problem, but it's easy to get wrong when the mid * mid is larger than the INT_MAX.\n\n```\nclass Solution {\n    public:\n        bool isPerfectSquare(int num) {\n            long long start = 0, end = num; // use long long to avoid such a case\n            while (start <= end) {\n                long long mid = end - ((end - start) / 2);\n                if (mid * mid == num) {\n                    return true;\n                } else if (mid * mid > num) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n            return false;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/ValidPerfectSquare.md","raw":"---\ntitle: Valid Perfect Square\ndate: 2017-01-25 22:15:29\ntags:\n    - Binary Search\n    - Math\n---\n\n> Given a positive integer num, write a function which returns True if num is a perfect square else False.\n>\n> Note: Do not use any built-in library function such as sqrt.\n>\n> Example 1:\n> + Input: 16\n> + Returns: True\n>\n> Example 2:\n> + Input: 14\n> + Returns: False\n\n<!--more-->\n\nIt's Leetcode 367. Easy problem, but it's easy to get wrong when the mid * mid is larger than the INT_MAX.\n\n```\nclass Solution {\n    public:\n        bool isPerfectSquare(int num) {\n            long long start = 0, end = num; // use long long to avoid such a case\n            while (start <= end) {\n                long long mid = end - ((end - start) / 2);\n                if (mid * mid == num) {\n                    return true;\n                } else if (mid * mid > num) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            }\n            return false;\n        }\n};\n```\n\nIt gets AC.\n","slug":"ValidPerfectSquare","published":1,"updated":"2017-01-25T14:25:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzatxy004tg5f49r3lsb5w","content":"<blockquote>\n<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>\n<p>Note: Do not use any built-in library function such as sqrt.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 16</li>\n<li>Returns: True</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 14</li>\n<li>Returns: False</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>Its Leetcode 367. Easy problem, but its easy to get wrong when the mid * mid is larger than the INT_MAX.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isPerfectSquare(int num) &#123;</div><div class=\"line\">            long long start = 0, end = num; // use long long to avoid such a case</div><div class=\"line\">            while (start &lt;= end) &#123;</div><div class=\"line\">                long long mid = end - ((end - start) / 2);</div><div class=\"line\">                if (mid * mid == num) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else if (mid * mid &gt; num) &#123;</div><div class=\"line\">                    end = mid - 1;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    start = mid + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>\n<p>Note: Do not use any built-in library function such as sqrt.</p>\n<p>Example 1:</p>\n<ul>\n<li>Input: 16</li>\n<li>Returns: True</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li>Input: 14</li>\n<li>Returns: False</li>\n</ul>\n</blockquote>","more":"<p>Its Leetcode 367. Easy problem, but its easy to get wrong when the mid * mid is larger than the INT_MAX.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        bool isPerfectSquare(int num) &#123;</div><div class=\"line\">            long long start = 0, end = num; // use long long to avoid such a case</div><div class=\"line\">            while (start &lt;= end) &#123;</div><div class=\"line\">                long long mid = end - ((end - start) / 2);</div><div class=\"line\">                if (mid * mid == num) &#123;</div><div class=\"line\">                    return true;</div><div class=\"line\">                &#125; else if (mid * mid &gt; num) &#123;</div><div class=\"line\">                    end = mid - 1;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    start = mid + 1;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"},{"title":"Reverse String II","date":"2017-03-16T06:24:59.000Z","_content":"\n> Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n>\n> Example:\n>```\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n```\n> Restrictions:\n>\n> + The string consists of lower English letters only.\n> + Length of the given string and k will in the range [1, 10000]\n\n<!--more-->\n\nThis is Leetcode No.541, It is a problem with easy tag which means this problem can be solved in hundreds ways.\n\nFirst I think about use a stack to store the chars. But it will use O(k) extra space.\n\nSo, I use two marks to mark the start and end of the reversed string.\n\nHere comes the answer:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        string reverseStr(string str, int k) {\n            stack<char> chars;\n            int idx = 0;\n            while (idx < (int)str.length()) {\n                int start = idx, end = idx + k - 1;\n                if (end >= (int)str.length()) {\n                    end = str.length() - 1;\n                }\n\n                idx = end + k + k;\n                while (start < end) {\n                    char tmp = str[end];\n                    str[end] = str[start];\n                    str[start] = tmp;\n\n                    start++;\n                    end--;\n                }\n\n            }\n\n            return str;\n        }\n};\n```\n\nIt gets AC.\n","source":"_posts/ReverseStringII.md","raw":"---\ntitle: Reverse String II\ndate: 2017-03-16 14:24:59\ntags:\n    - String\n---\n\n> Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n>\n> Example:\n>```\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n```\n> Restrictions:\n>\n> + The string consists of lower English letters only.\n> + Length of the given string and k will in the range [1, 10000]\n\n<!--more-->\n\nThis is Leetcode No.541, It is a problem with easy tag which means this problem can be solved in hundreds ways.\n\nFirst I think about use a stack to store the chars. But it will use O(k) extra space.\n\nSo, I use two marks to mark the start and end of the reversed string.\n\nHere comes the answer:\n\n```\nusing namespace std;\n\nclass Solution {\n    public:\n        string reverseStr(string str, int k) {\n            stack<char> chars;\n            int idx = 0;\n            while (idx < (int)str.length()) {\n                int start = idx, end = idx + k - 1;\n                if (end >= (int)str.length()) {\n                    end = str.length() - 1;\n                }\n\n                idx = end + k + k;\n                while (start < end) {\n                    char tmp = str[end];\n                    str[end] = str[start];\n                    str[start] = tmp;\n\n                    start++;\n                    end--;\n                }\n\n            }\n\n            return str;\n        }\n};\n```\n\nIt gets AC.\n","slug":"ReverseStringII","published":1,"updated":"2017-03-16T07:55:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj0vzaty1004vg5f4vt83vk2i","content":"<blockquote>\n<p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: s = &quot;abcdefg&quot;, k = 2</div><div class=\"line\">Output: &quot;bacdfeg&quot;</div></pre></td></tr></table></figure></p>\n<p>Restrictions:</p>\n<ul>\n<li>The string consists of lower English letters only.</li>\n<li>Length of the given string and k will in the range [1, 10000]</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>This is Leetcode No.541, It is a problem with easy tag which means this problem can be solved in hundreds ways.</p>\n<p>First I think about use a stack to store the chars. But it will use O(k) extra space.</p>\n<p>So, I use two marks to mark the start and end of the reversed string.</p>\n<p>Here comes the answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string reverseStr(string str, int k) &#123;</div><div class=\"line\">            stack&lt;char&gt; chars;</div><div class=\"line\">            int idx = 0;</div><div class=\"line\">            while (idx &lt; (int)str.length()) &#123;</div><div class=\"line\">                int start = idx, end = idx + k - 1;</div><div class=\"line\">                if (end &gt;= (int)str.length()) &#123;</div><div class=\"line\">                    end = str.length() - 1;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                idx = end + k + k;</div><div class=\"line\">                while (start &lt; end) &#123;</div><div class=\"line\">                    char tmp = str[end];</div><div class=\"line\">                    str[end] = str[start];</div><div class=\"line\">                    str[start] = tmp;</div><div class=\"line\"></div><div class=\"line\">                    start++;</div><div class=\"line\">                    end--;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return str;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>\n","excerpt":"<blockquote>\n<p>Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: s = &quot;abcdefg&quot;, k = 2</div><div class=\"line\">Output: &quot;bacdfeg&quot;</div></pre></td></tr></table></figure></p>\n<p>Restrictions:</p>\n<ul>\n<li>The string consists of lower English letters only.</li>\n<li>Length of the given string and k will in the range [1, 10000]</li>\n</ul>\n</blockquote>","more":"<p>This is Leetcode No.541, It is a problem with easy tag which means this problem can be solved in hundreds ways.</p>\n<p>First I think about use a stack to store the chars. But it will use O(k) extra space.</p>\n<p>So, I use two marks to mark the start and end of the reversed string.</p>\n<p>Here comes the answer:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Solution &#123;</div><div class=\"line\">    public:</div><div class=\"line\">        string reverseStr(string str, int k) &#123;</div><div class=\"line\">            stack&lt;char&gt; chars;</div><div class=\"line\">            int idx = 0;</div><div class=\"line\">            while (idx &lt; (int)str.length()) &#123;</div><div class=\"line\">                int start = idx, end = idx + k - 1;</div><div class=\"line\">                if (end &gt;= (int)str.length()) &#123;</div><div class=\"line\">                    end = str.length() - 1;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                idx = end + k + k;</div><div class=\"line\">                while (start &lt; end) &#123;</div><div class=\"line\">                    char tmp = str[end];</div><div class=\"line\">                    str[end] = str[start];</div><div class=\"line\">                    str[start] = tmp;</div><div class=\"line\"></div><div class=\"line\">                    start++;</div><div class=\"line\">                    end--;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            return str;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>It gets AC.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj0vzattt0000g5f4e6eeeleu","tag_id":"cj0vzatu40003g5f4mby5q95y","_id":"cj0vzatud0008g5f4q7gq86su"},{"post_id":"cj0vzatu10002g5f4sgkyfsk1","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatum000gg5f4fbdgk7q9"},{"post_id":"cj0vzatu10002g5f4sgkyfsk1","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatun000ig5f4d0i0p6bk"},{"post_id":"cj0vzatuy000lg5f4nluq4ba4","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatv1000og5f4skr7ln5c"},{"post_id":"cj0vzatu60004g5f4ofzf7m3x","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatv2000qg5f4l8noewze"},{"post_id":"cj0vzatu60004g5f4ofzf7m3x","tag_id":"cj0vzatuw000jg5f4qls7qdbe","_id":"cj0vzatv4000tg5f4fkov08d6"},{"post_id":"cj0vzatv5000vg5f4onfoauik","tag_id":"cj0vzatu40003g5f4mby5q95y","_id":"cj0vzatv8000yg5f4h9lplssj"},{"post_id":"cj0vzatv5000vg5f4onfoauik","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatv90011g5f474lmqryb"},{"post_id":"cj0vzatua0005g5f4xv55sexb","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatva0013g5f4wdx7vd6j"},{"post_id":"cj0vzatua0005g5f4xv55sexb","tag_id":"cj0vzatv4000sg5f488hep0na","_id":"cj0vzatvc0015g5f4e2of1vkj"},{"post_id":"cj0vzatua0005g5f4xv55sexb","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatvd0018g5f4sl4n6ym5"},{"post_id":"cj0vzatva0012g5f400bq9772","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatve001ag5f4rpgq5v4j"},{"post_id":"cj0vzatuc0006g5f4ypdcfx8c","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatvg001dg5f42i1whnsj"},{"post_id":"cj0vzatvc0017g5f4rt7fprr0","tag_id":"cj0vzatu40003g5f4mby5q95y","_id":"cj0vzatvh001fg5f4tcuc2glk"},{"post_id":"cj0vzatue0009g5f4oxqpjsgf","tag_id":"cj0vzatvc0016g5f46e2275mf","_id":"cj0vzatvk001ig5f4hr8y2yyd"},{"post_id":"cj0vzatui000ag5f4vega6uko","tag_id":"cj0vzatvg001cg5f4ovyk6vyo","_id":"cj0vzatvn001kg5f4u2deemuw"},{"post_id":"cj0vzatvl001jg5f42aq89azv","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatvq001ng5f49y59vj7h"},{"post_id":"cj0vzatuj000cg5f4fbr1gn6o","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatvr001pg5f47luropek"},{"post_id":"cj0vzatvt001qg5f4tnr6trad","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatvx001tg5f4jc8oudkl"},{"post_id":"cj0vzatvw001sg5f46f33e7n4","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatvz001vg5f4keum0kcy"},{"post_id":"cj0vzatvw001sg5f46f33e7n4","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatw0001yg5f4uremyduk"},{"post_id":"cj0vzatuk000dg5f4qldcq2md","tag_id":"cj0vzatvq001mg5f4phbf5jrn","_id":"cj0vzatw10020g5f41nml5vrw"},{"post_id":"cj0vzatuk000dg5f4qldcq2md","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatw20023g5f483gp61wd"},{"post_id":"cj0vzatvy001ug5f4ym52m7oe","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatw40025g5f4wf4hucld"},{"post_id":"cj0vzatvy001ug5f4ym52m7oe","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatw50028g5f45q4n7nig"},{"post_id":"cj0vzatul000fg5f4kyw9sowc","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatw6002ag5f4k0w99tay"},{"post_id":"cj0vzatw10022g5f4rcktbelh","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatw7002dg5f4cg9gnupb"},{"post_id":"cj0vzatw10022g5f4rcktbelh","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatw8002fg5f45kmiapze"},{"post_id":"cj0vzatw50029g5f4ect5snlw","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatwa002ig5f4kaowotm6"},{"post_id":"cj0vzatum000hg5f41nhmriun","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatwb002kg5f48ngyeqd5"},{"post_id":"cj0vzatum000hg5f41nhmriun","tag_id":"cj0vzatw40026g5f4pim4xslw","_id":"cj0vzatwd002ng5f4efo5q2sa"},{"post_id":"cj0vzatw8002eg5f4zt6z83tu","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatwh002pg5f47oq5cpoc"},{"post_id":"cj0vzatw8002eg5f4zt6z83tu","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatwj002sg5f4brozzqzg"},{"post_id":"cj0vzatuw000kg5f4nsiw2irk","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatwk002ug5f4c7pjljxb"},{"post_id":"cj0vzatw9002gg5f4cax8w5ix","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatwm002wg5f4rmqtmzik"},{"post_id":"cj0vzatw9002gg5f4cax8w5ix","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatwn002zg5f4q31unpoo"},{"post_id":"cj0vzatwa002jg5f45x91xf36","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatwo0031g5f4zc5q3toa"},{"post_id":"cj0vzatuz000mg5f4cnashw5x","tag_id":"cj0vzatw9002hg5f427tjneoa","_id":"cj0vzatwq0034g5f48ecv26gf"},{"post_id":"cj0vzatwb002lg5f4x5a1lzom","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatws0036g5f4y9gbwhk7"},{"post_id":"cj0vzatv1000pg5f4tn48mfjw","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatwt0039g5f4qyyjqm7e"},{"post_id":"cj0vzatv1000pg5f4tn48mfjw","tag_id":"cj0vzatwd002mg5f4jw8ibgkl","_id":"cj0vzatwv003bg5f45jr1see6"},{"post_id":"cj0vzatwj002tg5f4cikdr4la","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatwx003eg5f4440kzpux"},{"post_id":"cj0vzatv3000rg5f4dgjhyqdi","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzatwz003gg5f4bjf51twj"},{"post_id":"cj0vzatwk002vg5f44zbmqkla","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatx1003jg5f4mrtgkgrz"},{"post_id":"cj0vzatwm002yg5f437k03ube","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzatx2003lg5f4y1h7muuv"},{"post_id":"cj0vzatv4000ug5f4kb5o56ru","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzatx7003og5f4xk5025o2"},{"post_id":"cj0vzatwp0032g5f4qw0l8dkm","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatx8003qg5f43w04lxqh"},{"post_id":"cj0vzatws0037g5f4n8yq2hdw","tag_id":"cj0vzatw9002hg5f427tjneoa","_id":"cj0vzatx9003tg5f45ajuncbp"},{"post_id":"cj0vzatwu003ag5f4qcdx8xs6","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatxb003vg5f42xtelphq"},{"post_id":"cj0vzatwu003ag5f4qcdx8xs6","tag_id":"cj0vzatuw000jg5f4qls7qdbe","_id":"cj0vzatxd003yg5f4k1uzerx3"},{"post_id":"cj0vzatv7000xg5f4zm3tu3ii","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatxe0040g5f4xepel298"},{"post_id":"cj0vzatv7000xg5f4zm3tu3ii","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatxg0043g5f4jdevtm24"},{"post_id":"cj0vzatwv003cg5f4rqojrwep","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzatxi0045g5f4vnvurplw"},{"post_id":"cj0vzatwz003hg5f452jf2eep","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzatxk0048g5f4xfez5bgt"},{"post_id":"cj0vzatwz003hg5f452jf2eep","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatxl004ag5f4r535av62"},{"post_id":"cj0vzatx3003mg5f4tf2h5ago","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatxm004dg5f4vruedxl8"},{"post_id":"cj0vzatx7003pg5f4dgt0va2p","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatxn004fg5f41rcp92is"},{"post_id":"cj0vzatv8000zg5f403vixdt0","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatxp004ig5f4qh3co0qq"},{"post_id":"cj0vzatv8000zg5f403vixdt0","tag_id":"cj0vzatvg001cg5f4ovyk6vyo","_id":"cj0vzatxr004kg5f48klsjpnd"},{"post_id":"cj0vzatv8000zg5f403vixdt0","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatxt004ng5f4dpt4ntwh"},{"post_id":"cj0vzatx8003rg5f4ec8zm9q3","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatxv004pg5f4n1kijz0n"},{"post_id":"cj0vzatxa003ug5f42sz7zo48","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzatxy004sg5f4gem0dcnf"},{"post_id":"cj0vzatvb0014g5f4hnsnd0oo","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzaty0004ug5f4hkoant7o"},{"post_id":"cj0vzatxb003wg5f402bhjvbu","tag_id":"cj0vzatu40003g5f4mby5q95y","_id":"cj0vzaty3004xg5f4m78asuwe"},{"post_id":"cj0vzatxd003zg5f4fywu8z6v","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzaty4004yg5f4uzv45w3e"},{"post_id":"cj0vzatxd003zg5f4fywu8z6v","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzaty50050g5f4odl67cst"},{"post_id":"cj0vzatxd003zg5f4fywu8z6v","tag_id":"cj0vzatuw000jg5f4qls7qdbe","_id":"cj0vzaty50051g5f4qxjk1d9y"},{"post_id":"cj0vzatvd0019g5f4zvysltfm","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzaty50053g5f42pf1k6ab"},{"post_id":"cj0vzatxf0041g5f4q35an8et","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzaty60054g5f473inyrux"},{"post_id":"cj0vzatxf0041g5f4q35an8et","tag_id":"cj0vzatvq001mg5f4phbf5jrn","_id":"cj0vzaty60056g5f4s6c8kmir"},{"post_id":"cj0vzatxh0044g5f4gbh7493w","tag_id":"cj0vzatvg001cg5f4ovyk6vyo","_id":"cj0vzaty60057g5f4vc991d83"},{"post_id":"cj0vzatvf001bg5f4m26ligf3","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzaty70059g5f4nqm3qjwp"},{"post_id":"cj0vzatvf001bg5f4m26ligf3","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzaty7005ag5f432u7c1hs"},{"post_id":"cj0vzatxi0046g5f4yqwie4p9","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzaty7005bg5f4skdyxx4f"},{"post_id":"cj0vzatvg001eg5f4do3gmbo1","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzaty7005dg5f4xaoz0ipg"},{"post_id":"cj0vzatxl004bg5f411suxpup","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzaty8005eg5f43wdnyh55"},{"post_id":"cj0vzatxm004eg5f48xb6z4q1","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzaty8005gg5f4ea67h02z"},{"post_id":"cj0vzatxm004eg5f48xb6z4q1","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzaty9005hg5f4fatwwvqu"},{"post_id":"cj0vzatvi001gg5f4ljq8tu1b","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatya005jg5f4x4z27p96"},{"post_id":"cj0vzatvi001gg5f4ljq8tu1b","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzatyb005kg5f4rmxxyq0h"},{"post_id":"cj0vzatxn004gg5f4qnfkpa33","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatyb005mg5f4r36b3gu9"},{"post_id":"cj0vzatvo001lg5f4fl660weq","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatyb005ng5f4trs0a81f"},{"post_id":"cj0vzatvo001lg5f4fl660weq","tag_id":"cj0vzatwm002xg5f46odptgye","_id":"cj0vzatyc005pg5f4atij5o2q"},{"post_id":"cj0vzatxt004og5f47l9w23ug","tag_id":"cj0vzatvk001hg5f4zapgy0fb","_id":"cj0vzatyc005qg5f4a6fdnv98"},{"post_id":"cj0vzatvq001og5f43p5f6jyu","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatyd005sg5f47xwmu05e"},{"post_id":"cj0vzatvq001og5f43p5f6jyu","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatyd005tg5f42zawh7lh"},{"post_id":"cj0vzatvq001og5f43p5f6jyu","tag_id":"cj0vzatwd002mg5f4jw8ibgkl","_id":"cj0vzatyd005vg5f4h8ipku07"},{"post_id":"cj0vzatxv004qg5f4fks7y3m9","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatye005wg5f4q32bnv92"},{"post_id":"cj0vzatxv004qg5f4fks7y3m9","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatye005yg5f4jypmr5zq"},{"post_id":"cj0vzatxy004tg5f49r3lsb5w","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatye005zg5f4m4pjyzmo"},{"post_id":"cj0vzatxy004tg5f49r3lsb5w","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatyf0061g5f4ml3fygi6"},{"post_id":"cj0vzatvz001xg5f4fpb1tgcn","tag_id":"cj0vzatv90010g5f4esmx66v2","_id":"cj0vzatyf0062g5f44u8x2t29"},{"post_id":"cj0vzatvz001xg5f4fpb1tgcn","tag_id":"cj0vzatxw004rg5f4f77iv7xd","_id":"cj0vzatyg0064g5f4wz5wy2d5"},{"post_id":"cj0vzaty1004vg5f4vt83vk2i","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzatyg0065g5f4r1oyt0dh"},{"post_id":"cj0vzatw0001zg5f4c3257cju","tag_id":"cj0vzatwj002rg5f4xq2ew06q","_id":"cj0vzatyg0066g5f4nmpar05t"},{"post_id":"cj0vzatw30024g5f4msi6904a","tag_id":"cj0vzatuc0007g5f4x1wgk7ci","_id":"cj0vzatyh0067g5f4z2jkayc1"},{"post_id":"cj0vzatw30024g5f4msi6904a","tag_id":"cj0vzatuj000bg5f4ykjmjiy5","_id":"cj0vzatyh0068g5f4p1llf06o"},{"post_id":"cj0vzatw30024g5f4msi6904a","tag_id":"cj0vzatwd002mg5f4jw8ibgkl","_id":"cj0vzatyh0069g5f4f0hnchfb"},{"post_id":"cj0vzatw30024g5f4msi6904a","tag_id":"cj0vzaty50052g5f4xrmjwbxp","_id":"cj0vzatyh006ag5f4limy2squ"},{"post_id":"cj0vzatw40027g5f4awano6gh","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatyh006bg5f43ajf9xwg"},{"post_id":"cj0vzatw40027g5f4awano6gh","tag_id":"cj0vzatwd002mg5f4jw8ibgkl","_id":"cj0vzatyh006cg5f4ydi2pvoc"},{"post_id":"cj0vzatw6002bg5f40gndouwz","tag_id":"cj0vzatul000eg5f4zzk3696p","_id":"cj0vzatyh006dg5f4v1tzdhxz"},{"post_id":"cj0vzatw6002bg5f40gndouwz","tag_id":"cj0vzaty60058g5f4ssddd4ju","_id":"cj0vzatyh006eg5f475sv3l0d"},{"post_id":"cj0vzatw6002bg5f40gndouwz","tag_id":"cj0vzaty7005cg5f4mcmv5g3a","_id":"cj0vzatyh006fg5f4pct5kghz"},{"post_id":"cj0vzatwd002og5f4mkj239ev","tag_id":"cj0vzatwd002mg5f4jw8ibgkl","_id":"cj0vzatyh006gg5f4khtz42vu"},{"post_id":"cj0vzatwd002og5f4mkj239ev","tag_id":"cj0vzaty50052g5f4xrmjwbxp","_id":"cj0vzatyh006hg5f4r8stmm5g"},{"post_id":"cj0vzatwh002qg5f4ui8hwu7e","tag_id":"cj0vzatxw004rg5f4f77iv7xd","_id":"cj0vzatyh006ig5f4udadvvlb"},{"post_id":"cj0vzatwn0030g5f4o67i7k8m","tag_id":"cj0vzatv4000sg5f488hep0na","_id":"cj0vzatyh006jg5f4jyidxkl5"},{"post_id":"cj0vzatwn0030g5f4o67i7k8m","tag_id":"cj0vzatyb005lg5f45sz8eggk","_id":"cj0vzatyh006kg5f4q05fcvw5"},{"post_id":"cj0vzatwq0035g5f4wknb78js","tag_id":"cj0vzatv0000ng5f44drpcg12","_id":"cj0vzatyi006lg5f4bpr41f1o"},{"post_id":"cj0vzatwq0035g5f4wknb78js","tag_id":"cj0vzaty50052g5f4xrmjwbxp","_id":"cj0vzatyi006mg5f4npi89l3w"},{"post_id":"cj0vzatwy003fg5f4hbiv4n0j","tag_id":"cj0vzatyc005rg5f4nqnqmxmt","_id":"cj0vzatyi006ng5f4oox4osu8"},{"post_id":"cj0vzatx2003kg5f40ncpbuc1","tag_id":"cj0vzatxw004rg5f4f77iv7xd","_id":"cj0vzatyi006og5f47j0xclxk"},{"post_id":"cj0vzatxk0049g5f4yk7muxr1","tag_id":"cj0vzatyb005lg5f45sz8eggk","_id":"cj0vzatyi006pg5f4mz35jx9q"},{"post_id":"cj0vzatxp004jg5f4rt6zt2yn","tag_id":"cj0vzatxw004rg5f4f77iv7xd","_id":"cj0vzatyi006qg5f4k1bt41ss"},{"post_id":"cj0vzatxr004lg5f4rc6ezqdk","tag_id":"cj0vzatyf0063g5f4jq7s6k6x","_id":"cj0vzatyi006rg5f4bshj1vkg"},{"post_id":"cj0vzatxr004lg5f4rc6ezqdk","tag_id":"cj0vzatuw000jg5f4qls7qdbe","_id":"cj0vzatyi006sg5f4bth4grk2"}],"Tag":[{"name":"Stack","_id":"cj0vzatu40003g5f4mby5q95y"},{"name":"Binary Search","_id":"cj0vzatuc0007g5f4x1wgk7ci"},{"name":"Hash Table","_id":"cj0vzatuj000bg5f4ykjmjiy5"},{"name":"Depth-first Search","_id":"cj0vzatul000eg5f4zzk3696p"},{"name":"Breadth-first Search","_id":"cj0vzatuw000jg5f4qls7qdbe"},{"name":"Array","_id":"cj0vzatv0000ng5f44drpcg12"},{"name":"Trie","_id":"cj0vzatv4000sg5f488hep0na"},{"name":"Math","_id":"cj0vzatv90010g5f4esmx66v2"},{"name":"Simulation","_id":"cj0vzatvc0016g5f46e2275mf"},{"name":"Backtracking","_id":"cj0vzatvg001cg5f4ovyk6vyo"},{"name":"Dynamic Programming","_id":"cj0vzatvk001hg5f4zapgy0fb"},{"name":"Minimax","_id":"cj0vzatvq001mg5f4phbf5jrn"},{"name":"Brainteaser","_id":"cj0vzatw40026g5f4pim4xslw"},{"name":"Binary Search Tree","_id":"cj0vzatw9002hg5f427tjneoa"},{"name":"Two Pointers","_id":"cj0vzatwd002mg5f4jw8ibgkl"},{"name":"String","_id":"cj0vzatwj002rg5f4xq2ew06q"},{"name":"Tree","_id":"cj0vzatwm002xg5f46odptgye"},{"name":"Bitmap","_id":"cj0vzatxw004rg5f4f77iv7xd"},{"name":"Sort","_id":"cj0vzaty50052g5f4xrmjwbxp"},{"name":"Memoization","_id":"cj0vzaty60058g5f4ssddd4ju"},{"name":"Topological sort","_id":"cj0vzaty7005cg5f4mcmv5g3a"},{"name":"Bit Manipulation","_id":"cj0vzatyb005lg5f45sz8eggk"},{"name":"Description","_id":"cj0vzatyc005rg5f4nqnqmxmt"},{"name":"Union Find","_id":"cj0vzatyf0063g5f4jq7s6k6x"}]}}